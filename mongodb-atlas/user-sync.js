
// Generated by MonkEC - targeting Goja runtime
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);

// lib/src/base.ts
var ACTION_METADATA_KEY = Symbol("monk:actions");
var _MonkEntity = class _MonkEntity {
  /**
   * Creates a new MonkEntity instance
   * @param definition - The entity definition
   * @param state - The entity state
   * @param ctx - The context object
   */
  constructor(definition, state, ctx) {
    this.definition = definition;
    this.state = state;
    this.path = ctx?.path || "";
  }
  /**
   * Main entry point called by the Monk runtime
   * @param ctx - The context object
   * @returns The updated state
   */
  main(ctx) {
    const action2 = ctx.action;
    if (!action2) {
      console.log("No action provided");
      return this.state;
    }
    if (this.isMethodImplemented("before")) {
      this.before();
    }
    try {
      if (this.tryBuiltinAction(action2, ctx.args)) {
        return this.state;
      }
      if (this.tryRegisteredAction(action2, ctx.args)) {
        return this.state;
      }
      this.handleUnknownAction(action2, ctx.args);
      return this.state;
    } finally {
      if (this.isMethodImplemented("after")) {
        try {
          this.after();
        } catch (afterError) {
          console.error("Error in after() hook:", afterError);
        }
      }
    }
  }
  /**
   * Try to execute a built-in action if it's implemented
   */
  tryBuiltinAction(action2, _args) {
    switch (action2) {
      case "create":
        if (this.isMethodImplemented("create")) {
          this.create();
          return true;
        }
        break;
      case "start":
        if (this.isMethodImplemented("start")) {
          this.start();
          return true;
        }
        break;
      case "stop":
        if (this.isMethodImplemented("stop")) {
          this.stop();
          return true;
        }
        break;
      case "purge":
        if (this.isMethodImplemented("delete")) {
          this.delete();
          return true;
        }
        break;
      case "update":
        if (this.isMethodImplemented("update")) {
          this.update();
          return true;
        }
        break;
      case "check-readiness":
        if (this.isMethodImplemented("checkReadiness")) {
          const isReady = this.checkReadiness();
          if (!isReady) {
            throw new Error("not ready");
          }
          return true;
        }
        break;
    }
    return false;
  }
  /**
   * Try to execute a registered @action method
   */
  tryRegisteredAction(action2, args) {
    const actions = this.getRegisteredActions();
    console.log(
      "monkec debug tryRegisteredAction",
      action2,
      Array.from(actions.keys())
    );
    const methodName = actions.get(action2);
    if (methodName && typeof this[methodName] === "function") {
      this[methodName].call(this, args);
      return true;
    }
    return false;
  }
  /**
   * Get all registered actions from the instance
   */
  getRegisteredActions() {
    const actions = this[ACTION_METADATA_KEY];
    if (actions instanceof Map) {
      return new Map(actions);
    }
    return /* @__PURE__ */ new Map();
  }
  /**
   * Check if a method has been overridden from the base implementation
   */
  isMethodImplemented(methodName) {
    const method = this[methodName];
    if (typeof method !== "function") {
      return false;
    }
    const baseMethod = _MonkEntity.prototype[methodName];
    return method !== baseMethod;
  }
  /**
   * Handle unknown actions - can be overridden by subclasses
   */
  handleUnknownAction(action2, _args) {
    throw new Error(`Action ${action2} not found`);
  }
  /**
   * Called before action execution - can be overridden by subclasses
   * Useful for common setup like reading secrets, initializing connections, etc.
   */
  before() {
  }
  /**
   * Called after action execution - can be overridden by subclasses
   * Useful for common teardown like closing connections, cleanup, etc.
   */
  after() {
  }
  /**
   * Creates the entity
   * Override in subclasses if needed
   */
  create() {
  }
  /**
   * Starts the entity
   * Override in subclasses if needed
   */
  start() {
  }
  /**
   * Stops the entity
   * Override in subclasses if needed
   */
  stop() {
  }
  /**
   * Updates the entity
   * Override in subclasses if needed
   */
  update() {
  }
  /**
   * Deletes the entity
   * Override in subclasses if needed
   */
  delete() {
  }
  /**
   * Checks if the entity is ready
   * Override in subclasses if needed
   * @returns True if the entity is ready
   */
  checkReadiness() {
    return true;
  }
};
__name(_MonkEntity, "MonkEntity");
var MonkEntity = _MonkEntity;

// lib/src/http-client.ts
const http = require("http");

// examples/mongodb-atlas/user.ts
const http3 = require("http");
const secret2 = require("secret");

// examples/mongodb-atlas/common.ts
const secret = require("secret");
const http2 = require("http");
var BASE_URL = "https://cloud.mongodb.com/api/atlas/v2";
var API_VERSION_2025 = "application/vnd.atlas.2025-03-12+json";
function getToken(secret_ref) {
  const now = /* @__PURE__ */ new Date();
  let cached_token;
  let cached_token_expires;
  try {
    cached_token = secret.get(secret_ref + "_cached_token");
    cached_token_expires = secret.get(secret_ref + "_cached_token_expires");
  } catch (e) {
    cached_token = void 0;
    cached_token_expires = void 0;
  }
  if (cached_token && cached_token_expires) {
    const expires = new Date(cached_token_expires);
    if (now < expires) {
      return cached_token;
    }
  }
  const token = secret.get(secret_ref);
  if (!token) {
    throw new Error("Token not found");
  }
  if (!token.startsWith("mdb_sa")) {
    throw new Error("Token is not a service account token");
  }
  const res = http2.post(
    "https://cloud.mongodb.com/api/oauth/token",
    {
      headers: {
        "accept": "application/json",
        "content-type": "application/x-www-form-urlencoded",
        "cache-control": "no-cache",
        "authorization": "Basic " + btoa(token)
      },
      body: "grant_type=client_credentials"
    }
  );
  if (res.error) {
    throw new Error(res.error + ", body " + res.body);
  }
  if (res.statusCode >= 400) {
    throw new Error("Error getting token: " + res.status + ", body " + res.body);
  }
  const resObj = JSON.parse(res.body);
  if (!resObj.access_token) {
    throw new Error("Error getting token: " + res.status + ", body " + res.body);
  }
  if (resObj.expires_in) {
    const expires_in = new Date(now.getTime() + resObj.expires_in * 1e3);
    secret.set(secret_ref + "_cached_token", resObj.access_token);
    secret.set(secret_ref + "_cached_token_expires", expires_in.toISOString());
  }
  return resObj.access_token;
}
__name(getToken, "getToken");

// examples/mongodb-atlas/user.ts
const cli = require("cli");
var _User = class _User extends MonkEntity {
  constructor() {
    super(...arguments);
    // OAuth token for API access
    __publicField(this, "apiToken");
  }
  before() {
    this.apiToken = getToken(this.definition.secret_ref);
  }
  /** Create a new MongoDB Atlas database user */
  create() {
    const existingUser = this.getExistingUser();
    if (existingUser) {
      this.state = existingUser;
      return;
    }
    let password = "";
    if (!this.definition.password_secret_ref) {
      throw new Error("Password secret reference not defined");
    }
    try {
      const storedPassword = secret2.get(this.definition.password_secret_ref);
      if (!storedPassword) {
        throw new Error("Password not found");
      }
      password = storedPassword;
    } catch (e) {
      password = secret2.randString(16);
      secret2.set(this.definition.password_secret_ref, password);
    }
    const role = this.definition.role || "readWriteAnyDatabase";
    const body = {
      "username": this.definition.name,
      "databaseName": "admin",
      "password": password,
      "roles": [
        {
          "databaseName": "admin",
          "roleName": role
        }
      ]
    };
    const res = http3.post(
      BASE_URL + "/groups/" + this.definition.project_id + "/databaseUsers",
      {
        headers: {
          "content-type": API_VERSION_2025,
          "accept": API_VERSION_2025,
          "authorization": "Bearer " + this.apiToken
        },
        body: JSON.stringify(body)
      }
    );
    if (res.error) {
      throw new Error(res.error + ", body " + res.body);
    }
    if (res.statusCode >= 400) {
      throw new Error("Error creating user: " + res.statusCode + ", body " + res.body);
    }
    const resObj = JSON.parse(res.body);
    this.state = {
      name: resObj.username,
      project_id: this.definition.project_id,
      database_name: resObj.databaseName,
      roles: resObj.roles
    };
  }
  /** Get existing user if it exists */
  getExistingUser() {
    const res = http3.get(
      BASE_URL + "/groups/" + this.definition.project_id + "/databaseUsers/admin/" + this.definition.name,
      {
        headers: {
          "accept": API_VERSION_2025,
          "authorization": "Bearer " + this.apiToken
        }
      }
    );
    if (res.error) {
      return null;
    }
    if (res.statusCode >= 400) {
      return null;
    }
    const resObj = JSON.parse(res.body);
    if (!resObj.username) {
      return null;
    }
    return {
      name: resObj.username,
      project_id: this.definition.project_id,
      database_name: resObj.databaseName,
      roles: resObj.roles,
      existing: true
    };
  }
  start() {
    cli.output(`Starting operations for: ${this.definition.name}`);
  }
  update() {
    if (!this.state.name) {
      this.create();
      return;
    }
    const existingUser = this.getExistingUser();
    if (existingUser) {
      this.state = existingUser;
    } else {
      this.create();
    }
  }
  delete() {
    if (!this.state.name) {
      cli.output("User does not exist, nothing to delete");
      return;
    }
    if (this.state.existing) {
      cli.output("User wasn't created by this Entity, skipping delete");
      return;
    }
    const res = http3.delete(
      BASE_URL + "/groups/" + this.definition.project_id + "/databaseUsers/admin/" + this.state.name,
      {
        headers: {
          "authorization": "Bearer " + this.apiToken,
          "accept": API_VERSION_2025
        }
      }
    );
    if (res.error) {
      throw new Error(res.error + ", body " + res.body);
    }
    if (res.statusCode >= 400) {
      throw new Error("Error deleting user: " + res.statusCode + ", body " + res.body);
    }
    cli.output("Database user deleted successfully");
  }
  /** Check if the user is ready */
  isReady() {
    if (!this.state.name) {
      return false;
    }
    const existingUser = this.getExistingUser();
    return existingUser !== null;
  }
  /** Update user password */
  updatePassword(newPassword) {
    if (!this.state.name) {
      throw new Error("User does not exist");
    }
    const password = newPassword || secret2.randString(16);
    secret2.set(this.definition.password_secret_ref, password);
    const role = this.definition.role || "readWriteAnyDatabase";
    const body = {
      "password": password,
      "roles": [
        {
          "databaseName": "admin",
          "roleName": role
        }
      ]
    };
    const res = http3.do(
      BASE_URL + "/groups/" + this.definition.project_id + "/databaseUsers/admin/" + this.state.name,
      {
        method: "PATCH",
        headers: {
          "content-type": API_VERSION_2025,
          "accept": API_VERSION_2025,
          "authorization": "Bearer " + this.apiToken
        },
        body: JSON.stringify(body)
      }
    );
    if (res.error) {
      throw new Error(res.error + ", body " + res.body);
    }
    if (res.statusCode >= 400) {
      throw new Error("Error updating user password: " + res.statusCode + ", body " + res.body);
    }
    cli.output("User password updated successfully");
  }
  /** Get the user's password from secret store */
  getPassword() {
    if (!this.definition.password_secret_ref) {
      throw new Error("Password secret reference not defined");
    }
    try {
      const storedPassword = secret2.get(this.definition.password_secret_ref);
      if (!storedPassword) {
        throw new Error("Password not found in secret store");
      }
      return storedPassword;
    } catch (e) {
      throw new Error("Password not found in secret store");
    }
  }
};
__name(_User, "User");
var User = _User;



function main(def, state, ctx) {
  const entity = new User(def, state, ctx);
  return entity.main(ctx);
}
