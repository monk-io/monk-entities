
// Generated by MonkEC - targeting Goja runtime
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);

// lib/src/base.ts
var ACTION_METADATA_KEY = Symbol("monk:actions");
var _MonkEntity = class _MonkEntity {
  /**
   * Creates a new MonkEntity instance
   * @param definition - The entity definition
   * @param state - The entity state
   * @param ctx - The context object
   */
  constructor(definition, state, ctx) {
    this.definition = definition;
    this.state = state;
    this.path = ctx?.path || "";
  }
  /**
   * Main entry point called by the Monk runtime
   * @param ctx - The context object
   * @returns The updated state
   */
  main(ctx) {
    const action2 = ctx.action;
    if (!action2) {
      console.log("No action provided");
      return this.state;
    }
    if (this.isMethodImplemented("before")) {
      this.before();
    }
    try {
      if (this.tryBuiltinAction(action2, ctx.args)) {
        return this.state;
      }
      if (this.tryRegisteredAction(action2, ctx.args)) {
        return this.state;
      }
      this.handleUnknownAction(action2, ctx.args);
      return this.state;
    } finally {
      if (this.isMethodImplemented("after")) {
        try {
          this.after();
        } catch (afterError) {
          console.error("Error in after() hook:", afterError);
        }
      }
    }
  }
  /**
   * Try to execute a built-in action if it's implemented
   */
  tryBuiltinAction(action2, _args) {
    switch (action2) {
      case "create":
        if (this.isMethodImplemented("create")) {
          this.create();
          return true;
        }
        break;
      case "start":
        if (this.isMethodImplemented("start")) {
          this.start();
          return true;
        }
        break;
      case "stop":
        if (this.isMethodImplemented("stop")) {
          this.stop();
          return true;
        }
        break;
      case "purge":
        if (this.isMethodImplemented("delete")) {
          this.delete();
          return true;
        }
        break;
      case "update":
        if (this.isMethodImplemented("update")) {
          this.update();
          return true;
        }
        break;
      case "check-readiness":
        if (this.isMethodImplemented("checkReadiness")) {
          const isReady = this.checkReadiness();
          if (!isReady) {
            throw new Error("not ready");
          }
          return true;
        }
        break;
    }
    return false;
  }
  /**
   * Try to execute a registered @action method
   */
  tryRegisteredAction(action2, args) {
    const actions = this.getRegisteredActions();
    console.log(
      "monkec debug tryRegisteredAction",
      action2,
      Array.from(actions.keys())
    );
    const methodName = actions.get(action2);
    if (methodName && typeof this[methodName] === "function") {
      this[methodName].call(this, args);
      return true;
    }
    return false;
  }
  /**
   * Get all registered actions from the instance
   */
  getRegisteredActions() {
    const actions = this[ACTION_METADATA_KEY];
    if (actions instanceof Map) {
      return new Map(actions);
    }
    return /* @__PURE__ */ new Map();
  }
  /**
   * Check if a method has been overridden from the base implementation
   */
  isMethodImplemented(methodName) {
    const method = this[methodName];
    if (typeof method !== "function") {
      return false;
    }
    const baseMethod = _MonkEntity.prototype[methodName];
    return method !== baseMethod;
  }
  /**
   * Handle unknown actions - can be overridden by subclasses
   */
  handleUnknownAction(action2, _args) {
    throw new Error(`Action ${action2} not found`);
  }
  /**
   * Called before action execution - can be overridden by subclasses
   * Useful for common setup like reading secrets, initializing connections, etc.
   */
  before() {
  }
  /**
   * Called after action execution - can be overridden by subclasses
   * Useful for common teardown like closing connections, cleanup, etc.
   */
  after() {
  }
  /**
   * Creates the entity
   * Override in subclasses if needed
   */
  create() {
  }
  /**
   * Starts the entity
   * Override in subclasses if needed
   */
  start() {
  }
  /**
   * Stops the entity
   * Override in subclasses if needed
   */
  stop() {
  }
  /**
   * Updates the entity
   * Override in subclasses if needed
   */
  update() {
  }
  /**
   * Deletes the entity
   * Override in subclasses if needed
   */
  delete() {
  }
  /**
   * Checks if the entity is ready
   * Override in subclasses if needed
   * @returns True if the entity is ready
   */
  checkReadiness() {
    return true;
  }
};
__name(_MonkEntity, "MonkEntity");
var MonkEntity = _MonkEntity;

// lib/src/http-client.ts
const http = require("http");

// examples/mongodb-atlas/project.ts
const http3 = require("http");

// examples/mongodb-atlas/common.ts
const secret = require("secret");
const http2 = require("http");
var BASE_URL = "https://cloud.mongodb.com/api/atlas/v2";
var API_VERSION = "application/vnd.atlas.2023-01-01+json";
function getToken(secret_ref) {
  const now = /* @__PURE__ */ new Date();
  let cached_token;
  let cached_token_expires;
  try {
    cached_token = secret.get(secret_ref + "_cached_token");
    cached_token_expires = secret.get(secret_ref + "_cached_token_expires");
  } catch (e) {
    cached_token = void 0;
    cached_token_expires = void 0;
  }
  if (cached_token && cached_token_expires) {
    const expires = new Date(cached_token_expires);
    if (now < expires) {
      return cached_token;
    }
  }
  const token = secret.get(secret_ref);
  if (!token) {
    throw new Error("Token not found");
  }
  if (!token.startsWith("mdb_sa")) {
    throw new Error("Token is not a service account token");
  }
  const res = http2.post(
    "https://cloud.mongodb.com/api/oauth/token",
    {
      headers: {
        "accept": "application/json",
        "content-type": "application/x-www-form-urlencoded",
        "cache-control": "no-cache",
        "authorization": "Basic " + btoa(token)
      },
      body: "grant_type=client_credentials"
    }
  );
  if (res.error) {
    throw new Error(res.error + ", body " + res.body);
  }
  if (res.statusCode >= 400) {
    throw new Error("Error getting token: " + res.status + ", body " + res.body);
  }
  const resObj = JSON.parse(res.body);
  if (!resObj.access_token) {
    throw new Error("Error getting token: " + res.status + ", body " + res.body);
  }
  if (resObj.expires_in) {
    const expires_in = new Date(now.getTime() + resObj.expires_in * 1e3);
    secret.set(secret_ref + "_cached_token", resObj.access_token);
    secret.set(secret_ref + "_cached_token_expires", expires_in.toISOString());
  }
  return resObj.access_token;
}
__name(getToken, "getToken");
function getOrganization(name, token) {
  const res = http2.get(
    BASE_URL + "/orgs?envelope=false&name=" + name,
    {
      headers: {
        "accept": API_VERSION,
        "authorization": "Bearer " + token
      }
    }
  );
  if (res.error) {
    throw new Error(res.error + ", body " + res.body);
  }
  if (res.statusCode >= 400) {
    throw new Error("Error getting organization: " + res.status + ", body " + res.body);
  }
  const resArr = JSON.parse(res.body);
  if (resArr.length === 0) {
    throw new Error("Organization not found: " + name + ", body " + res.body);
  }
  for (let i = 0; i < resArr.results.length; i++) {
    if (resArr.results[i].name === name) {
      return { id: resArr.results[i].id, name: resArr.results[i].name };
    }
  }
  throw new Error("Organization not found: " + name + ", body " + res.body);
}
__name(getOrganization, "getOrganization");

// examples/mongodb-atlas/project.ts
const cli = require("cli");
var _Project = class _Project extends MonkEntity {
  constructor() {
    super(...arguments);
    // OAuth token for API access
    __publicField(this, "apiToken");
  }
  before() {
    this.apiToken = getToken(this.definition.secret_ref);
  }
  /** Create a new MongoDB Atlas project */
  create() {
    const res = http3.get(
      BASE_URL + "/groups/byName/" + this.definition.name,
      {
        headers: {
          "accept": API_VERSION,
          "authorization": "Bearer " + this.apiToken
        }
      }
    );
    if (res.statusCode === 200) {
      const resObj = JSON.parse(res.body);
      this.state = {
        id: resObj.id,
        name: resObj.name,
        organization_id: resObj.orgId,
        existing: true
      };
      return;
    }
    const body = {
      "name": this.definition.name,
      "withDefaultAlertsSettings": true,
      "orgId": ""
    };
    if (this.definition.organization) {
      const org = getOrganization(this.definition.organization, this.apiToken);
      body.orgId = org.id;
    }
    const createRes = http3.post(
      BASE_URL + "/groups",
      {
        headers: {
          "content-type": API_VERSION,
          "accept": API_VERSION,
          "authorization": "Bearer " + this.apiToken
        },
        body: JSON.stringify(body)
      }
    );
    if (createRes.error) {
      throw new Error(createRes.error + ", body " + createRes.body);
    }
    const createObj = JSON.parse(createRes.body);
    this.state = {
      id: createObj.id,
      name: createObj.name,
      organization_id: createObj.orgId,
      existing: false
    };
  }
  start() {
    cli.output(`Starting operations for: ${this.definition.name}`);
  }
  update() {
    if (!this.state.id) {
      this.create();
      return;
    }
  }
  delete() {
    if (!this.state.id) {
      cli.output("Project does not exist, nothing to delete");
      return;
    }
    if (this.state.existing) {
      cli.output("Project wasn't created by this Entity, skipping delete");
      return;
    }
    const res = http3.delete(
      BASE_URL + "/groups/" + this.state.id,
      {
        headers: {
          "authorization": "Bearer " + this.apiToken,
          "accept": API_VERSION
        }
      }
    );
    if (res.error) {
      throw new Error(res.error + ", body " + res.body);
    }
  }
};
__name(_Project, "Project");
var Project = _Project;



function main(def, state, ctx) {
  const entity = new Project(def, state, ctx);
  return entity.main(ctx);
}
