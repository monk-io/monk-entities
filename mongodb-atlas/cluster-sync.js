
// Generated by MonkEC - targeting Goja runtime
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);

// lib/src/base.ts
var ACTION_METADATA_KEY = Symbol("monk:actions");
var _MonkEntity = class _MonkEntity {
  /**
   * Creates a new MonkEntity instance
   * @param definition - The entity definition
   * @param state - The entity state
   * @param ctx - The context object
   */
  constructor(definition, state, ctx) {
    this.definition = definition;
    this.state = state;
    this.path = ctx?.path || "";
  }
  /**
   * Main entry point called by the Monk runtime
   * @param ctx - The context object
   * @returns The updated state
   */
  main(ctx) {
    const action2 = ctx.action;
    if (!action2) {
      console.log("No action provided");
      return this.state;
    }
    if (this.isMethodImplemented("before")) {
      this.before();
    }
    try {
      if (this.tryBuiltinAction(action2, ctx.args)) {
        return this.state;
      }
      if (this.tryRegisteredAction(action2, ctx.args)) {
        return this.state;
      }
      this.handleUnknownAction(action2, ctx.args);
      return this.state;
    } finally {
      if (this.isMethodImplemented("after")) {
        try {
          this.after();
        } catch (afterError) {
          console.error("Error in after() hook:", afterError);
        }
      }
    }
  }
  /**
   * Try to execute a built-in action if it's implemented
   */
  tryBuiltinAction(action2, _args) {
    switch (action2) {
      case "create":
        if (this.isMethodImplemented("create")) {
          this.create();
          return true;
        }
        break;
      case "start":
        if (this.isMethodImplemented("start")) {
          this.start();
          return true;
        }
        break;
      case "stop":
        if (this.isMethodImplemented("stop")) {
          this.stop();
          return true;
        }
        break;
      case "purge":
        if (this.isMethodImplemented("delete")) {
          this.delete();
          return true;
        }
        break;
      case "update":
        if (this.isMethodImplemented("update")) {
          this.update();
          return true;
        }
        break;
      case "check-readiness":
        if (this.isMethodImplemented("checkReadiness")) {
          const isReady = this.checkReadiness();
          if (!isReady) {
            throw new Error("not ready");
          }
          return true;
        }
        break;
    }
    return false;
  }
  /**
   * Try to execute a registered @action method
   */
  tryRegisteredAction(action2, args) {
    const actions = this.getRegisteredActions();
    console.log(
      "monkec debug tryRegisteredAction",
      action2,
      Array.from(actions.keys())
    );
    const methodName = actions.get(action2);
    if (methodName && typeof this[methodName] === "function") {
      this[methodName].call(this, args);
      return true;
    }
    return false;
  }
  /**
   * Get all registered actions from the instance
   */
  getRegisteredActions() {
    const actions = this[ACTION_METADATA_KEY];
    if (actions instanceof Map) {
      return new Map(actions);
    }
    return /* @__PURE__ */ new Map();
  }
  /**
   * Check if a method has been overridden from the base implementation
   */
  isMethodImplemented(methodName) {
    const method = this[methodName];
    if (typeof method !== "function") {
      return false;
    }
    const baseMethod = _MonkEntity.prototype[methodName];
    return method !== baseMethod;
  }
  /**
   * Handle unknown actions - can be overridden by subclasses
   */
  handleUnknownAction(action2, _args) {
    throw new Error(`Action ${action2} not found`);
  }
  /**
   * Called before action execution - can be overridden by subclasses
   * Useful for common setup like reading secrets, initializing connections, etc.
   */
  before() {
  }
  /**
   * Called after action execution - can be overridden by subclasses
   * Useful for common teardown like closing connections, cleanup, etc.
   */
  after() {
  }
  /**
   * Creates the entity
   * Override in subclasses if needed
   */
  create() {
  }
  /**
   * Starts the entity
   * Override in subclasses if needed
   */
  start() {
  }
  /**
   * Stops the entity
   * Override in subclasses if needed
   */
  stop() {
  }
  /**
   * Updates the entity
   * Override in subclasses if needed
   */
  update() {
  }
  /**
   * Deletes the entity
   * Override in subclasses if needed
   */
  delete() {
  }
  /**
   * Checks if the entity is ready
   * Override in subclasses if needed
   * @returns True if the entity is ready
   */
  checkReadiness() {
    return true;
  }
};
__name(_MonkEntity, "MonkEntity");
var MonkEntity = _MonkEntity;

// lib/src/http-client.ts
const http = require("http");

// examples/mongodb-atlas/cluster.ts
const http3 = require("http");

// examples/mongodb-atlas/common.ts
const secret = require("secret");
const http2 = require("http");
var BASE_URL = "https://cloud.mongodb.com/api/atlas/v2";
var API_VERSION_2025 = "application/vnd.atlas.2025-03-12+json";
function getToken(secret_ref) {
  const now = /* @__PURE__ */ new Date();
  let cached_token;
  let cached_token_expires;
  try {
    cached_token = secret.get(secret_ref + "_cached_token");
    cached_token_expires = secret.get(secret_ref + "_cached_token_expires");
  } catch (e) {
    cached_token = void 0;
    cached_token_expires = void 0;
  }
  if (cached_token && cached_token_expires) {
    const expires = new Date(cached_token_expires);
    if (now < expires) {
      return cached_token;
    }
  }
  const token = secret.get(secret_ref);
  if (!token) {
    throw new Error("Token not found");
  }
  if (!token.startsWith("mdb_sa")) {
    throw new Error("Token is not a service account token");
  }
  const res = http2.post(
    "https://cloud.mongodb.com/api/oauth/token",
    {
      headers: {
        "accept": "application/json",
        "content-type": "application/x-www-form-urlencoded",
        "cache-control": "no-cache",
        "authorization": "Basic " + btoa(token)
      },
      body: "grant_type=client_credentials"
    }
  );
  if (res.error) {
    throw new Error(res.error + ", body " + res.body);
  }
  if (res.statusCode >= 400) {
    throw new Error("Error getting token: " + res.status + ", body " + res.body);
  }
  const resObj = JSON.parse(res.body);
  if (!resObj.access_token) {
    throw new Error("Error getting token: " + res.status + ", body " + res.body);
  }
  if (resObj.expires_in) {
    const expires_in = new Date(now.getTime() + resObj.expires_in * 1e3);
    secret.set(secret_ref + "_cached_token", resObj.access_token);
    secret.set(secret_ref + "_cached_token_expires", expires_in.toISOString());
  }
  return resObj.access_token;
}
__name(getToken, "getToken");

// examples/mongodb-atlas/cluster.ts
const cli = require("cli");
var _Cluster = class _Cluster extends MonkEntity {
  constructor() {
    super(...arguments);
    // OAuth token for API access
    __publicField(this, "apiToken");
  }
  before() {
    this.apiToken = getToken(this.definition.secret_ref);
  }
  /** Create a new MongoDB Atlas cluster */
  create() {
    const body = {
      "name": this.definition.name,
      "clusterType": "REPLICASET",
      "replicationSpecs": [
        {
          "regionConfigs": [
            {
              "electableSpecs": {
                "instanceSize": this.definition.instance_size,
                "nodeCount": 3
              },
              "providerName": "TENANT",
              "backingProviderName": this.definition.provider,
              "regionName": this.definition.region
            }
          ]
        }
      ]
    };
    const res = http3.post(
      BASE_URL + "/groups/" + this.definition.project_id + "/clusters",
      {
        headers: {
          "content-type": API_VERSION_2025,
          "accept": API_VERSION_2025,
          "authorization": "Bearer " + this.apiToken
        },
        body: JSON.stringify(body)
      }
    );
    if (res.error) {
      throw new Error(res.error + ", body " + res.body);
    }
    if (res.statusCode >= 400) {
      throw new Error("Error creating cluster: " + res.statusCode + ", body " + res.body);
    }
    const resObj = JSON.parse(res.body);
    this.state = {
      id: resObj.id,
      name: resObj.name
    };
    if (this.definition.allow_ips && this.definition.allow_ips.length > 0) {
      this.configureIPAccessList();
    }
  }
  /** Configure IP access list for the cluster */
  configureIPAccessList() {
    if (!this.definition.allow_ips || this.definition.allow_ips.length === 0) {
      return;
    }
    const accessList = this.definition.allow_ips.map((ip) => ({
      "ipAddress": ip,
      "comment": "Added by MonkeC entity"
    }));
    const res = http3.post(
      BASE_URL + "/groups/" + this.definition.project_id + "/accessList",
      {
        headers: {
          "content-type": API_VERSION_2025,
          "accept": API_VERSION_2025,
          "authorization": "Bearer " + this.apiToken
        },
        body: JSON.stringify(accessList)
      }
    );
    if (res.error) {
      cli.output("Warning: Failed to configure IP access list: " + res.error);
    }
    if (res.statusCode >= 400) {
      cli.output("Warning: Failed to configure IP access list: " + res.statusCode + ", body " + res.body);
    }
  }
  start() {
    cli.output(`Starting operations for: ${this.definition.name}`);
  }
  update() {
    if (!this.state.id) {
      this.create();
      return;
    }
    const res = http3.get(
      BASE_URL + "/groups/" + this.definition.project_id + "/clusters/" + this.definition.name,
      {
        headers: {
          "accept": API_VERSION_2025,
          "authorization": "Bearer " + this.apiToken
        }
      }
    );
    if (res.error) {
      throw new Error(res.error + ", body " + res.body);
    }
    if (res.statusCode >= 400) {
      throw new Error("Error getting cluster: " + res.statusCode + ", body " + res.body);
    }
    const resObj = JSON.parse(res.body);
    this.state = {
      id: resObj.id,
      name: resObj.name
    };
    if (this.definition.allow_ips && this.definition.allow_ips.length > 0) {
      this.configureIPAccessList();
    }
  }
  delete() {
    if (!this.state.id) {
      cli.output("Cluster does not exist, nothing to delete");
      return;
    }
    const res = http3.delete(
      BASE_URL + "/groups/" + this.definition.project_id + "/clusters/" + this.definition.name,
      {
        headers: {
          "authorization": "Bearer " + this.apiToken,
          "accept": API_VERSION_2025
        }
      }
    );
    if (res.error) {
      throw new Error(res.error + ", body " + res.body);
    }
    if (res.statusCode >= 400) {
      throw new Error("Error deleting cluster: " + res.statusCode + ", body " + res.body);
    }
    cli.output("Cluster deletion initiated. It may take several minutes to complete.");
  }
  /** Check if the cluster is ready */
  checkReadiness() {
    if (!this.state.id) {
      return false;
    }
    const res = http3.get(
      BASE_URL + "/groups/" + this.definition.project_id + "/clusters/" + this.definition.name,
      {
        headers: {
          "accept": API_VERSION_2025,
          "authorization": "Bearer " + this.apiToken
        }
      }
    );
    if (res.error || res.statusCode >= 400) {
      return false;
    }
    const resObj = JSON.parse(res.body);
    if (resObj.stateName === "IDLE") {
      this.state = {
        id: resObj.id,
        name: resObj.name,
        connection_standard: resObj.connectionStrings?.standard,
        connection_srv: resObj.connectionStrings?.standardSrv
      };
      return true;
    }
    return false;
  }
};
__name(_Cluster, "Cluster");
var Cluster = _Cluster;



function main(def, state, ctx) {
  const entity = new Cluster(def, state, ctx);
  return entity.main(ctx);
}
