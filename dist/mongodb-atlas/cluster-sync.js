
// Generated by MonkEC - targeting Goja runtime
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __knownSymbol = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __decoratorStart = (base) => [, , , __create(base?.[__knownSymbol("metadata")] ?? null)];
var __decoratorStrings = ["class", "method", "getter", "setter", "accessor", "field", "value", "get", "set"];
var __expectFn = (fn) => fn !== void 0 && typeof fn !== "function" ? __typeError("Function expected") : fn;
var __decoratorContext = (kind, name, done, metadata, fns) => ({ kind: __decoratorStrings[kind], name, metadata, addInitializer: (fn) => done._ ? __typeError("Already initialized") : fns.push(__expectFn(fn || null)) });
var __decoratorMetadata = (array, target) => __defNormalProp(target, __knownSymbol("metadata"), array[3]);
var __runInitializers = (array, flags, self, value) => {
  for (var i = 0, fns = array[flags >> 1], n = fns && fns.length; i < n; i++) flags & 1 ? fns[i].call(self) : value = fns[i].call(self, value);
  return value;
};
var __decorateElement = (array, flags, name, decorators, target, extra) => {
  var fn, it, done, ctx, access, k = flags & 7, s = !!(flags & 8), p = !!(flags & 16);
  var j = k > 3 ? array.length + 1 : k ? s ? 1 : 2 : 0, key = __decoratorStrings[k + 5];
  var initializers = k > 3 && (array[j - 1] = []), extraInitializers = array[j] || (array[j] = []);
  var desc = k && (!p && !s && (target = target.prototype), k < 5 && (k > 3 || !p) && __getOwnPropDesc(k < 4 ? target : { get [name]() {
    return __privateGet(this, extra);
  }, set [name](x) {
    return __privateSet(this, extra, x);
  } }, name));
  k ? p && k < 4 && __name(extra, (k > 2 ? "set " : k > 1 ? "get " : "") + name) : __name(target, name);
  for (var i = decorators.length - 1; i >= 0; i--) {
    ctx = __decoratorContext(k, name, done = {}, array[3], extraInitializers);
    if (k) {
      ctx.static = s, ctx.private = p, access = ctx.access = { has: p ? (x) => __privateIn(target, x) : (x) => name in x };
      if (k ^ 3) access.get = p ? (x) => (k ^ 1 ? __privateGet : __privateMethod)(x, target, k ^ 4 ? extra : desc.get) : (x) => x[name];
      if (k > 2) access.set = p ? (x, y) => __privateSet(x, target, y, k ^ 4 ? extra : desc.set) : (x, y) => x[name] = y;
    }
    it = (0, decorators[i])(k ? k < 4 ? p ? extra : desc[key] : k > 4 ? void 0 : { get: desc.get, set: desc.set } : target, ctx), done._ = 1;
    if (k ^ 4 || it === void 0) __expectFn(it) && (k > 4 ? initializers.unshift(it) : k ? p ? extra = it : desc[key] = it : target = it);
    else if (typeof it !== "object" || it === null) __typeError("Object expected");
    else __expectFn(fn = it.get) && (desc.get = fn), __expectFn(fn = it.set) && (desc.set = fn), __expectFn(fn = it.init) && initializers.unshift(fn);
  }
  return k || __decoratorMetadata(array, target), desc && __defProp(target, name, desc), p ? k ^ 4 ? extra : desc : target;
};
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateIn = (member, obj) => Object(obj) !== obj ? __typeError('Cannot use the "in" operator on this value') : member.has(obj);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);

// input/mongodb-atlas/cluster.ts
const base = require("mongodb-atlas/base");
const MongoDBAtlasEntity = base.MongoDBAtlasEntity;
const cli = require("cli");
const base = require("monkec/base");
const action = base.action;
var _deleteSnapshot_dec, _describeSnapshot_dec, _listRestoreJobs_dec, _getRestoreStatus_dec, _restoreCluster_dec, _listSnapshots_dec, _createSnapshot_dec, _getBackupInfo_dec, _a, _init;
var _Cluster = class _Cluster extends (_a = MongoDBAtlasEntity, _getBackupInfo_dec = [action("get-backup-info")], _createSnapshot_dec = [action("create-snapshot")], _listSnapshots_dec = [action("list-snapshots")], _restoreCluster_dec = [action("restore")], _getRestoreStatus_dec = [action("get-restore-status")], _listRestoreJobs_dec = [action("list-restore-jobs")], _describeSnapshot_dec = [action("describe-snapshot")], _deleteSnapshot_dec = [action("delete-snapshot")], _a) {
  constructor() {
    super(...arguments);
    __runInitializers(_init, 5, this);
  }
  getEntityName() {
    return this.definition.name;
  }
  /**
   * Check if the cluster tier is a shared tier (M0, M2, M5)
   * Shared tiers use "TENANT" provider, dedicated tiers use direct provider name
   */
  isSharedTier() {
    const sharedTiers = ["M0", "M2", "M5"];
    return sharedTiers.includes(this.definition.instance_size);
  }
  /** Create a new MongoDB Atlas cluster */
  create() {
    const regionConfig = {
      "electableSpecs": {
        "instanceSize": this.definition.instance_size,
        "nodeCount": 3
      },
      "regionName": this.definition.region
    };
    if (this.isSharedTier()) {
      regionConfig.providerName = "TENANT";
      regionConfig.backingProviderName = this.definition.provider;
    } else {
      regionConfig.providerName = this.definition.provider;
      regionConfig.priority = 7;
    }
    const body = {
      "name": this.definition.name,
      "clusterType": "REPLICASET",
      "replicationSpecs": [
        {
          "regionConfigs": [regionConfig]
        }
      ]
    };
    if (!this.isSharedTier()) {
      body.backupEnabled = true;
    }
    const resObj = this.makeRequest("POST", `/groups/${this.definition.project_id}/clusters`, body);
    this.state = {
      id: resObj.id,
      name: resObj.name
    };
    if (this.definition.allow_ips && this.definition.allow_ips.length > 0) {
      this.configureIPAccessList();
    }
  }
  /** Configure IP access list for the cluster */
  configureIPAccessList() {
    if (!this.definition.allow_ips || this.definition.allow_ips.length === 0) {
      return;
    }
    const accessList = this.definition.allow_ips.map((ip) => ({
      "ipAddress": ip,
      "comment": "Added by MonkeC entity"
    }));
    try {
      this.makeRequest("POST", `/groups/${this.definition.project_id}/accessList`, accessList);
    } catch (error) {
      cli.output(`Warning: Failed to configure IP access list: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  update() {
    if (!this.state.id) {
      this.create();
      return;
    }
    const clusterData = this.checkResourceExists(`/groups/${this.definition.project_id}/clusters/${this.definition.name}`);
    if (clusterData) {
      this.state = {
        ...this.state,
        id: clusterData.id,
        name: clusterData.name,
        connection_standard: clusterData.connectionStrings?.standard,
        connection_srv: clusterData.connectionStrings?.standardSrv
      };
    }
  }
  delete() {
    if (!this.state.id) {
      cli.output("Cluster does not exist, nothing to delete");
      return;
    }
    this.deleteResource(`/groups/${this.definition.project_id}/clusters/${this.definition.name}`, "Cluster");
  }
  checkReadiness() {
    if (!this.state.id) {
      return false;
    }
    const clusterData = this.checkResourceExists(`/groups/${this.definition.project_id}/clusters/${this.definition.name}`);
    if (!clusterData) {
      return false;
    }
    if (clusterData.stateName === "IDLE" && clusterData.connectionStrings) {
      this.state.connection_standard = clusterData.connectionStrings.standard;
      this.state.connection_srv = clusterData.connectionStrings.standardSrv;
      return true;
    }
    return false;
  }
  checkLiveness() {
    const clusterData = this.checkResourceExists(`/groups/${this.definition.project_id}/clusters/${this.definition.name}`);
    if (!clusterData) {
      throw new Error(`Cluster ${this.definition.name} not found`);
    }
    const hasConn = Boolean(clusterData.connectionStrings?.standard || clusterData.connectionStrings?.standardSrv);
    const state = String(clusterData.stateName || "");
    if (!hasConn) {
      throw new Error("Connection strings are not available yet");
    }
    const live = state === "IDLE" || state === "UPDATING" || state === "MAINTENANCE" || state === "RESUMING";
    if (!live) {
      throw new Error(`Cluster is not available (state: ${state})`);
    }
    return true;
  }
  /**
   * Validate if the cluster tier supports backup operations
   * Backups are only available for M10+ (dedicated) clusters
   */
  validateBackupSupport() {
    if (this.isSharedTier()) {
      throw new Error(
        `Backup operations are not supported for shared cluster tier ${this.definition.instance_size}. Backups require a dedicated cluster (M10 or higher).`
      );
    }
  }
  getBackupInfo(_args) {
    cli.output(`==================================================`);
    cli.output(`\u{1F4E6} Backup Information for cluster: ${this.definition.name}`);
    cli.output(`Project ID: ${this.definition.project_id}`);
    cli.output(`==================================================`);
    if (!this.state.id) {
      throw new Error("Cluster ID is not available. Ensure the cluster is created and ready.");
    }
    try {
      const clusterData = this.checkResourceExists(`/groups/${this.definition.project_id}/clusters/${this.definition.name}`);
      if (!clusterData) {
        throw new Error(`Cluster ${this.definition.name} not found`);
      }
      cli.output(`
\u{1F527} Cluster Configuration:`);
      cli.output(`   Cluster Tier: ${this.definition.instance_size}`);
      cli.output(`   Provider: ${this.definition.provider}`);
      cli.output(`   Region: ${this.definition.region}`);
      const backupSupported = !this.isSharedTier();
      cli.output(`   Backup Supported: ${backupSupported ? "\u2705 Yes (M10+)" : "\u274C No (shared tier)"}`);
      if (clusterData.backupEnabled !== void 0) {
        cli.output(`   Backup Enabled: ${clusterData.backupEnabled ? "\u2705 Yes" : "\u274C No"}`);
      }
      if (!backupSupported) {
        cli.output(`
\u26A0\uFE0F  Note: Backups require a dedicated cluster (M10 or higher).`);
        cli.output(`   Current tier ${this.definition.instance_size} is a shared tier.`);
      } else {
        cli.output(`
\u{1F4CB} To create a manual snapshot:`);
        cli.output(`   monk do namespace/cluster create-snapshot`);
        cli.output(`
\u{1F4CB} To list all snapshots:`);
        cli.output(`   monk do namespace/cluster list-snapshots`);
      }
      cli.output(`
==================================================`);
    } catch (error) {
      cli.output(`
\u274C Failed to get backup info`);
      throw new Error(`Get backup info failed: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  createSnapshot(args) {
    cli.output(`==================================================`);
    cli.output(`Creating backup snapshot for cluster: ${this.definition.name}`);
    cli.output(`Project ID: ${this.definition.project_id}`);
    cli.output(`==================================================`);
    this.validateBackupSupport();
    if (!this.state.id) {
      throw new Error("Cluster ID is not available. Ensure the cluster is created and ready.");
    }
    const description = args?.description || `Manual backup at ${(/* @__PURE__ */ new Date()).toISOString()}`;
    const retentionInDays = Number(args?.retention_days || args?.retentionInDays) || 7;
    cli.output(`Description: ${description}`);
    cli.output(`Retention: ${retentionInDays} days`);
    const body = {
      description,
      retentionInDays
    };
    try {
      const response = this.makeRequest(
        "POST",
        `/groups/${this.definition.project_id}/clusters/${this.definition.name}/backup/snapshots`,
        body
      );
      cli.output(`
\u2705 Snapshot creation initiated successfully!`);
      cli.output(`Snapshot ID: ${response.id}`);
      cli.output(`Status: ${response.status}`);
      cli.output(`Type: ${response.type || "onDemand"}`);
      cli.output(`Created at: ${response.createdAt}`);
      cli.output(`Expires at: ${response.expiresAt}`);
      cli.output(`
Note: Snapshot creation may take several minutes depending on cluster size.`);
      cli.output(`Use 'monk do namespace/cluster list-snapshots' to check status.`);
      cli.output(`==================================================`);
    } catch (error) {
      cli.output(`
\u274C Failed to create backup snapshot`);
      throw new Error(`Backup operation failed: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  listSnapshots(args) {
    cli.output(`==================================================`);
    cli.output(`Listing backup snapshots for cluster: ${this.definition.name}`);
    cli.output(`Project ID: ${this.definition.project_id}`);
    cli.output(`==================================================`);
    this.validateBackupSupport();
    if (!this.state.id) {
      throw new Error("Cluster ID is not available. Ensure the cluster is created and ready.");
    }
    const limit = Number(args?.limit) || 10;
    try {
      const response = this.makeRequest(
        "GET",
        `/groups/${this.definition.project_id}/clusters/${this.definition.name}/backup/snapshots`
      );
      const snapshots = response.results || [];
      const totalCount = response.totalCount || snapshots.length;
      cli.output(`
Total snapshots available: ${totalCount}`);
      cli.output(`Showing: ${Math.min(snapshots.length, limit)} snapshot(s)
`);
      if (snapshots.length === 0) {
        cli.output(`No snapshots found for this cluster.`);
        cli.output(`Create a snapshot using: monk do namespace/cluster create-snapshot`);
      } else {
        const displaySnapshots = snapshots.slice(0, limit);
        for (let i = 0; i < displaySnapshots.length; i++) {
          const snapshot = displaySnapshots[i];
          cli.output(`
\u{1F4F8} Snapshot #${i + 1}`);
          cli.output(`   ID: ${snapshot.id}`);
          cli.output(`   Status: ${snapshot.status}`);
          cli.output(`   Type: ${snapshot.type || "scheduled"}`);
          cli.output(`   Created: ${snapshot.createdAt}`);
          cli.output(`   Expires: ${snapshot.expiresAt || "N/A"}`);
          if (snapshot.description) {
            cli.output(`   Description: ${snapshot.description}`);
          }
          if (snapshot.storageSizeBytes) {
            const sizeGB = (snapshot.storageSizeBytes / (1024 * 1024 * 1024)).toFixed(2);
            cli.output(`   Size: ${sizeGB} GB`);
          }
        }
        if (snapshots.length > limit) {
          cli.output(`
... and ${snapshots.length - limit} more snapshot(s)`);
          cli.output(`Increase limit with: monk do namespace/cluster list-snapshots limit=${snapshots.length}`);
        }
      }
      cli.output(`
==================================================`);
    } catch (error) {
      cli.output(`
\u274C Failed to list backup snapshots`);
      throw new Error(`List snapshots operation failed: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  restoreCluster(args) {
    cli.output(`==================================================`);
    cli.output(`\u26A0\uFE0F  RESTORE OPERATION - READ CAREFULLY!`);
    cli.output(`==================================================`);
    cli.output(`Cluster: ${this.definition.name}`);
    cli.output(`Project ID: ${this.definition.project_id}`);
    this.validateBackupSupport();
    if (!this.state.id) {
      throw new Error("Cluster ID is not available. Ensure the cluster is created and ready.");
    }
    const snapshotId = args?.snapshot_id || args?.snapshotId;
    let pointInTimeUTCSeconds;
    const restoreTimestamp = args?.restore_timestamp || args?.pointInTimeUTCSeconds;
    if (restoreTimestamp) {
      if (typeof restoreTimestamp === "string" && restoreTimestamp.includes("T")) {
        pointInTimeUTCSeconds = Math.floor(new Date(restoreTimestamp).getTime() / 1e3);
      } else {
        pointInTimeUTCSeconds = Number(restoreTimestamp);
      }
    }
    if (!snapshotId && !pointInTimeUTCSeconds) {
      throw new Error(
        `Either 'snapshot_id' or 'restore_timestamp' is required.
Usage:
  monk do namespace/cluster restore snapshot_id="your-snapshot-id"
  monk do namespace/cluster restore restore_timestamp="2024-12-01T10:00:00Z"

To find snapshot IDs, run: monk do namespace/cluster list-snapshots`
      );
    }
    const targetClusterName = args?.target_id || args?.targetClusterName || this.definition.name;
    const targetProjectId = args?.target_project_id || args?.targetProjectId || this.definition.project_id;
    cli.output(`
\u26A0\uFE0F  WARNING: This operation will:`);
    if (targetClusterName === this.definition.name) {
      cli.output(`   - OVERWRITE ALL DATA in cluster '${targetClusterName}'`);
    } else {
      cli.output(`   - Restore data to cluster '${targetClusterName}'`);
    }
    cli.output(`   - Make the target cluster READ-ONLY during restore`);
    cli.output(`   - May take several hours depending on data size`);
    const body = {
      deliveryType: "automated",
      targetClusterName,
      targetGroupId: targetProjectId
    };
    if (snapshotId) {
      body.snapshotId = snapshotId;
      cli.output(`
Restoring from Snapshot ID: ${snapshotId}`);
    } else if (pointInTimeUTCSeconds) {
      body.deliveryType = "pointInTime";
      body.pointInTimeUTCSeconds = pointInTimeUTCSeconds;
      const restoreDate = new Date(pointInTimeUTCSeconds * 1e3).toISOString();
      cli.output(`
Restoring to Point-in-Time: ${restoreDate}`);
    }
    cli.output(`Target Cluster: ${targetClusterName}`);
    cli.output(`Target Project: ${targetProjectId}`);
    cli.output(`==================================================`);
    try {
      const response = this.makeRequest(
        "POST",
        `/groups/${this.definition.project_id}/clusters/${this.definition.name}/backup/restoreJobs`,
        body
      );
      cli.output(`
\u2705 Restore job created successfully!`);
      cli.output(`Restore Job ID: ${response.id}`);
      cli.output(`Status: ${response.status || "IN_PROGRESS"}`);
      cli.output(`Delivery Type: ${response.deliveryType}`);
      cli.output(`Created at: ${response.createdAt}`);
      if (response.snapshotId) {
        cli.output(`Snapshot ID: ${response.snapshotId}`);
      }
      if (response.pointInTimeUTCSeconds) {
        cli.output(`Point-in-Time: ${new Date(response.pointInTimeUTCSeconds * 1e3).toISOString()}`);
      }
      cli.output(`
\u{1F4CB} To check restore progress:`);
      cli.output(`   monk do namespace/cluster get-restore-status job_id="${response.id}"`);
      cli.output(`
\u23F3 Restore may take several hours. The cluster will be read-only until complete.`);
      cli.output(`==================================================`);
    } catch (error) {
      cli.output(`
\u274C Failed to create restore job`);
      throw new Error(`Restore operation failed: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  getRestoreStatus(args) {
    cli.output(`==================================================`);
    cli.output(`Checking restore job status`);
    cli.output(`Cluster: ${this.definition.name}`);
    cli.output(`==================================================`);
    this.validateBackupSupport();
    const jobId = args?.job_id || args?.jobId;
    if (!jobId) {
      throw new Error(
        `'job_id' is required.
Usage: monk do namespace/cluster get-restore-status job_id="your-job-id"

To find job IDs, run: monk do namespace/cluster list-restore-jobs`
      );
    }
    try {
      const response = this.makeRequest(
        "GET",
        `/groups/${this.definition.project_id}/clusters/${this.definition.name}/backup/restoreJobs/${jobId}`
      );
      cli.output(`
\u{1F504} Restore Job Details`);
      cli.output(`   Job ID: ${response.id}`);
      cli.output(`   Status: ${response.status || "UNKNOWN"}`);
      cli.output(`   Delivery Type: ${response.deliveryType}`);
      cli.output(`   Target Cluster: ${response.targetClusterName}`);
      cli.output(`   Created: ${response.createdAt}`);
      if (response.finishedAt) {
        cli.output(`   Finished: ${response.finishedAt}`);
      } else {
        cli.output(`   Finished: In progress...`);
      }
      if (response.snapshotId) {
        cli.output(`   Snapshot ID: ${response.snapshotId}`);
      }
      if (response.pointInTimeUTCSeconds) {
        cli.output(`   Point-in-Time: ${new Date(response.pointInTimeUTCSeconds * 1e3).toISOString()}`);
      }
      const status = String(response.status || "").toUpperCase();
      if (status === "COMPLETED" || status === "FINISHED") {
        cli.output(`
\u2705 Restore completed successfully!`);
        cli.output(`   The cluster is now available for read/write operations.`);
      } else if (status === "IN_PROGRESS" || status === "PENDING") {
        cli.output(`
\u23F3 Restore is still in progress...`);
        cli.output(`   The cluster is READ-ONLY until restore completes.`);
        cli.output(`   Check again later with: monk do namespace/cluster get-restore-status job_id="${jobId}"`);
      } else if (status === "FAILED" || status === "CANCELLED") {
        cli.output(`
\u274C Restore ${status.toLowerCase()}!`);
        if (response.statusMessage) {
          cli.output(`   Message: ${response.statusMessage}`);
        }
      }
      cli.output(`
==================================================`);
    } catch (error) {
      cli.output(`
\u274C Failed to get restore job status`);
      throw new Error(`Get restore status failed: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  listRestoreJobs(args) {
    cli.output(`==================================================`);
    cli.output(`Listing restore jobs for cluster: ${this.definition.name}`);
    cli.output(`Project ID: ${this.definition.project_id}`);
    cli.output(`==================================================`);
    this.validateBackupSupport();
    const limit = Number(args?.limit) || 10;
    try {
      const response = this.makeRequest(
        "GET",
        `/groups/${this.definition.project_id}/clusters/${this.definition.name}/backup/restoreJobs`
      );
      const jobs = response.results || [];
      const totalCount = response.totalCount || jobs.length;
      cli.output(`
Total restore jobs: ${totalCount}`);
      cli.output(`Showing: ${Math.min(jobs.length, limit)} job(s)
`);
      if (jobs.length === 0) {
        cli.output(`No restore jobs found for this cluster.`);
        cli.output(`Create a restore job using: monk do namespace/cluster restore snapshot_id="xxx"`);
      } else {
        const displayJobs = jobs.slice(0, limit);
        for (let i = 0; i < displayJobs.length; i++) {
          const job = displayJobs[i];
          const statusIcon = this.getStatusIcon(job.status);
          cli.output(`
${statusIcon} Restore Job #${i + 1}`);
          cli.output(`   Job ID: ${job.id}`);
          cli.output(`   Status: ${job.status}`);
          cli.output(`   Target Cluster: ${job.targetClusterName}`);
          cli.output(`   Delivery Type: ${job.deliveryType}`);
          cli.output(`   Created: ${job.createdAt}`);
          if (job.finishedAt) {
            cli.output(`   Finished: ${job.finishedAt}`);
          }
          if (job.snapshotId) {
            cli.output(`   Snapshot ID: ${job.snapshotId}`);
          }
        }
        if (jobs.length > limit) {
          cli.output(`
... and ${jobs.length - limit} more job(s)`);
          cli.output(`Increase limit with: monk do namespace/cluster list-restore-jobs limit=${jobs.length}`);
        }
      }
      cli.output(`
==================================================`);
    } catch (error) {
      cli.output(`
\u274C Failed to list restore jobs`);
      throw new Error(`List restore jobs failed: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  describeSnapshot(args) {
    cli.output(`==================================================`);
    cli.output(`\u{1F4F8} Snapshot Details`);
    cli.output(`==================================================`);
    cli.output(`Cluster: ${this.definition.name}`);
    cli.output(`Project ID: ${this.definition.project_id}`);
    this.validateBackupSupport();
    const snapshotId = args?.snapshot_id || args?.snapshotId;
    if (!snapshotId) {
      throw new Error(
        `Required argument 'snapshot_id' not provided.
Usage: monk do namespace/cluster/describe-snapshot snapshot_id="xxx"

To find snapshot IDs, run: monk do namespace/cluster/list-snapshots`
      );
    }
    try {
      const snapshot = this.makeRequest(
        "GET",
        `/groups/${this.definition.project_id}/clusters/${this.definition.name}/backup/snapshots/${snapshotId}`
      );
      cli.output(`
\u{1F4F8} Snapshot Information`);
      cli.output(`--------------------------------------------------`);
      cli.output(`ID: ${snapshot.id}`);
      cli.output(`Status: ${snapshot.status}`);
      cli.output(`Type: ${snapshot.type || "scheduled"}`);
      cli.output(`Created: ${snapshot.createdAt}`);
      cli.output(`Expires: ${snapshot.expiresAt || "N/A"}`);
      if (snapshot.description) {
        cli.output(`Description: ${snapshot.description}`);
      }
      if (snapshot.storageSizeBytes) {
        const sizeGB = (snapshot.storageSizeBytes / (1024 * 1024 * 1024)).toFixed(2);
        cli.output(`Size: ${sizeGB} GB`);
      }
      if (snapshot.mongodVersion) {
        cli.output(`MongoDB Version: ${snapshot.mongodVersion}`);
      }
      if (snapshot.replicaSetName) {
        cli.output(`Replica Set: ${snapshot.replicaSetName}`);
      }
      if (snapshot.snapshotType) {
        cli.output(`Snapshot Type: ${snapshot.snapshotType}`);
      }
      cli.output(`
\u{1F4CB} To restore from this snapshot:`);
      cli.output(`   monk do namespace/cluster/restore snapshot_id="${snapshotId}"`);
      cli.output(`
\u{1F4CB} To delete this snapshot:`);
      cli.output(`   monk do namespace/cluster/delete-snapshot snapshot_id="${snapshotId}"`);
      cli.output(`==================================================`);
    } catch (error) {
      cli.output(`
\u274C Failed to get snapshot details`);
      throw new Error(`Describe snapshot failed: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  deleteSnapshot(args) {
    cli.output(`==================================================`);
    cli.output(`\u{1F5D1}\uFE0F DELETE SNAPSHOT`);
    cli.output(`==================================================`);
    cli.output(`Cluster: ${this.definition.name}`);
    cli.output(`Project ID: ${this.definition.project_id}`);
    this.validateBackupSupport();
    const snapshotId = args?.snapshot_id || args?.snapshotId;
    if (!snapshotId) {
      throw new Error(
        `Required argument 'snapshot_id' not provided.
Usage: monk do namespace/cluster/delete-snapshot snapshot_id="xxx"

To find snapshot IDs, run: monk do namespace/cluster/list-snapshots`
      );
    }
    cli.output(`
\u26A0\uFE0F  WARNING: This will permanently delete the snapshot.`);
    cli.output(`   Snapshot ID: ${snapshotId}`);
    cli.output(`--------------------------------------------------`);
    try {
      const snapshot = this.makeRequest(
        "GET",
        `/groups/${this.definition.project_id}/clusters/${this.definition.name}/backup/snapshots/${snapshotId}`
      );
      cli.output(`Found snapshot: ${snapshot.id}`);
      cli.output(`Type: ${snapshot.type || "scheduled"}`);
      cli.output(`Created: ${snapshot.createdAt}`);
      this.makeRequest(
        "DELETE",
        `/groups/${this.definition.project_id}/clusters/${this.definition.name}/backup/snapshots/${snapshotId}`
      );
      cli.output(`
\u2705 Snapshot deleted successfully!`);
      cli.output(`   Snapshot ID: ${snapshotId}`);
      cli.output(`==================================================`);
    } catch (error) {
      cli.output(`
\u274C Failed to delete snapshot`);
      throw new Error(`Delete snapshot failed: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  /**
   * Get status icon for restore job status
   */
  getStatusIcon(status) {
    const statusUpper = String(status || "").toUpperCase();
    switch (statusUpper) {
      case "COMPLETED":
      case "FINISHED":
        return "\u2705";
      case "IN_PROGRESS":
      case "PENDING":
      case "QUEUED":
        return "\u23F3";
      case "FAILED":
      case "CANCELLED":
        return "\u274C";
      default:
        return "\u{1F504}";
    }
  }
};
_init = __decoratorStart(_a);
__decorateElement(_init, 1, "getBackupInfo", _getBackupInfo_dec, _Cluster);
__decorateElement(_init, 1, "createSnapshot", _createSnapshot_dec, _Cluster);
__decorateElement(_init, 1, "listSnapshots", _listSnapshots_dec, _Cluster);
__decorateElement(_init, 1, "restoreCluster", _restoreCluster_dec, _Cluster);
__decorateElement(_init, 1, "getRestoreStatus", _getRestoreStatus_dec, _Cluster);
__decorateElement(_init, 1, "listRestoreJobs", _listRestoreJobs_dec, _Cluster);
__decorateElement(_init, 1, "describeSnapshot", _describeSnapshot_dec, _Cluster);
__decorateElement(_init, 1, "deleteSnapshot", _deleteSnapshot_dec, _Cluster);
__decoratorMetadata(_init, _Cluster);
__name(_Cluster, "Cluster");
/**
 * Readiness check configuration
 * M10+ clusters can take 5-10 minutes to provision
 * - period: Check every 30 seconds
 * - initialDelay: Wait 60 seconds before first check
 * - attempts: Try for up to 15 minutes (30 attempts × 30 seconds)
 */
__publicField(_Cluster, "readiness", {
  period: 30,
  // seconds between checks
  initialDelay: 60,
  // seconds before first check
  attempts: 30
  // max attempts (30 × 30s = 15 min)
});
var Cluster = _Cluster;



function main(def, state, ctx) {
  const entity = new Cluster(def, state, ctx);
  return entity.main(ctx);
}
