
// Generated by MonkEC - targeting Goja runtime
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);

// input/mongodb-atlas/project.ts
const atlasBase = require("mongodb-atlas/atlas-base");
const MongoDBAtlasEntity = atlasBase.MongoDBAtlasEntity;
const common = require("mongodb-atlas/common");
const getOrganization = common.getOrganization;
const cli = require("cli");
var _Project = class _Project extends MongoDBAtlasEntity {
  getEntityName() {
    return this.definition.name;
  }
  /** Create a new MongoDB Atlas project */
  create() {
    const existingProject = this.checkResourceExists(`/groups/byName/${this.definition.name}`);
    if (existingProject) {
      this.state = {
        id: existingProject.id,
        name: existingProject.name,
        organization_id: existingProject.orgId,
        existing: true
      };
      return;
    }
    const org = getOrganization(this.definition.organization, this.apiToken);
    const body = {
      name: this.definition.name,
      withDefaultAlertsSettings: true,
      orgId: org.id
    };
    const createObj = this.makeRequest("POST", "/groups", body);
    this.state = {
      id: createObj.id,
      name: createObj.name,
      organization_id: createObj.orgId,
      existing: false
    };
  }
  update() {
    if (!this.state.id) {
      this.create();
      return;
    }
  }
  delete() {
    if (!this.state.id) {
      cli.output("Project does not exist, nothing to delete");
      return;
    }
    this.deleteAllClustersInProject();
    this.deleteResource(`/groups/${this.state.id}`, "Project");
  }
  checkReadiness() {
    if (!this.state.id) {
      return false;
    }
    const projectData = this.checkResourceExists(`/groups/${this.state.id}`);
    if (!projectData) {
      return false;
    }
    return true;
  }
  checkLiveness() {
    if (!this.state.id) {
      throw new Error("Project ID is not available");
    }
    const projectData = this.checkResourceExists(`/groups/${this.state.id}`);
    if (!projectData) {
      throw new Error(`Project ${this.state.name} not found`);
    }
    return true;
  }
  /**
   * Wait for all cluster deletions to complete by polling the API
   */
  waitForClusterDeletions() {
    const maxAttempts = 30;
    let attempts = 0;
    while (attempts < maxAttempts) {
      try {
        const clustersResponse = this.makeRequest("GET", `/groups/${this.state.id}/clusters`);
        if (!clustersResponse || !clustersResponse.results || clustersResponse.results.length === 0) {
          cli.output("All clusters have been deleted successfully");
          return;
        }
        const remainingClusters = clustersResponse.results.length;
        cli.output(`Still waiting for ${remainingClusters} cluster(s) to be deleted... (attempt ${attempts + 1}/${maxAttempts})`);
        attempts++;
        if (attempts >= maxAttempts) {
          cli.output("Warning: Timeout waiting for cluster deletions. Proceeding with project deletion anyway.");
          break;
        }
        const start = Date.now();
        while (Date.now() - start < 1e4) {
        }
      } catch (error) {
        cli.output(`Warning: Error checking cluster deletion status: ${error instanceof Error ? error.message : "Unknown error"}`);
        break;
      }
    }
  }
  /**
   * Delete all clusters in the project before deleting the project itself
   * This prevents the 409 error when trying to delete a project with active clusters
   */
  deleteAllClustersInProject() {
    if (this.state.existing) {
      cli.output("Project wasn't created by this entity, skipping cluster cleanup");
      return;
    }
    try {
      cli.output("Checking for active clusters in project before deletion...");
      const clustersResponse = this.makeRequest("GET", `/groups/${this.state.id}/clusters`);
      if (clustersResponse && clustersResponse.results && clustersResponse.results.length > 0) {
        cli.output(`Found ${clustersResponse.results.length} active cluster(s) in project. Deleting them first...`);
        for (const cluster of clustersResponse.results) {
          try {
            cli.output(`Deleting cluster: ${cluster.name}`);
            this.makeRequest("DELETE", `/groups/${this.state.id}/clusters/${cluster.name}`);
            cli.output(`Successfully deleted cluster: ${cluster.name}`);
          } catch (error) {
            cli.output(`Warning: Failed to delete cluster ${cluster.name}: ${error instanceof Error ? error.message : "Unknown error"}`);
          }
        }
        cli.output("Waiting for cluster deletions to complete...");
        this.waitForClusterDeletions();
      } else {
        cli.output("No active clusters found in project");
      }
    } catch (error) {
      cli.output(`Warning: Failed to check/delete clusters in project: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
};
__name(_Project, "Project");
/**
 * Readiness check configuration
 * Projects are usually ready immediately after creation
 * - period: Check every 10 seconds
 * - initialDelay: Wait 5 seconds before first check
 * - attempts: Try for up to 2 minutes (12 attempts × 10 seconds)
 */
__publicField(_Project, "readiness", {
  period: 10,
  // seconds between checks
  initialDelay: 5,
  // seconds before first check
  attempts: 12
  // max attempts (12 × 10s = 2 min)
});
var Project = _Project;



function main(def, state, ctx) {
  const entity = new Project(def, state, ctx);
  return entity.main(ctx);
}
