
// Generated by MonkEC - targeting Goja runtime
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __knownSymbol = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __decoratorStart = (base) => [, , , __create(base?.[__knownSymbol("metadata")] ?? null)];
var __decoratorStrings = ["class", "method", "getter", "setter", "accessor", "field", "value", "get", "set"];
var __expectFn = (fn) => fn !== void 0 && typeof fn !== "function" ? __typeError("Function expected") : fn;
var __decoratorContext = (kind, name, done, metadata, fns) => ({ kind: __decoratorStrings[kind], name, metadata, addInitializer: (fn) => done._ ? __typeError("Already initialized") : fns.push(__expectFn(fn || null)) });
var __decoratorMetadata = (array, target) => __defNormalProp(target, __knownSymbol("metadata"), array[3]);
var __runInitializers = (array, flags, self, value) => {
  for (var i = 0, fns = array[flags >> 1], n = fns && fns.length; i < n; i++) flags & 1 ? fns[i].call(self) : value = fns[i].call(self, value);
  return value;
};
var __decorateElement = (array, flags, name, decorators, target, extra) => {
  var fn, it, done, ctx, access, k = flags & 7, s = !!(flags & 8), p = !!(flags & 16);
  var j = k > 3 ? array.length + 1 : k ? s ? 1 : 2 : 0, key = __decoratorStrings[k + 5];
  var initializers = k > 3 && (array[j - 1] = []), extraInitializers = array[j] || (array[j] = []);
  var desc = k && (!p && !s && (target = target.prototype), k < 5 && (k > 3 || !p) && __getOwnPropDesc(k < 4 ? target : { get [name]() {
    return __privateGet(this, extra);
  }, set [name](x) {
    return __privateSet(this, extra, x);
  } }, name));
  k ? p && k < 4 && __name(extra, (k > 2 ? "set " : k > 1 ? "get " : "") + name) : __name(target, name);
  for (var i = decorators.length - 1; i >= 0; i--) {
    ctx = __decoratorContext(k, name, done = {}, array[3], extraInitializers);
    if (k) {
      ctx.static = s, ctx.private = p, access = ctx.access = { has: p ? (x) => __privateIn(target, x) : (x) => name in x };
      if (k ^ 3) access.get = p ? (x) => (k ^ 1 ? __privateGet : __privateMethod)(x, target, k ^ 4 ? extra : desc.get) : (x) => x[name];
      if (k > 2) access.set = p ? (x, y) => __privateSet(x, target, y, k ^ 4 ? extra : desc.set) : (x, y) => x[name] = y;
    }
    it = (0, decorators[i])(k ? k < 4 ? p ? extra : desc[key] : k > 4 ? void 0 : { get: desc.get, set: desc.set } : target, ctx), done._ = 1;
    if (k ^ 4 || it === void 0) __expectFn(it) && (k > 4 ? initializers.unshift(it) : k ? p ? extra = it : desc[key] = it : target = it);
    else if (typeof it !== "object" || it === null) __typeError("Object expected");
    else __expectFn(fn = it.get) && (desc.get = fn), __expectFn(fn = it.set) && (desc.set = fn), __expectFn(fn = it.init) && initializers.unshift(fn);
  }
  return k || __decoratorMetadata(array, target), desc && __defProp(target, name, desc), p ? k ^ 4 ? extra : desc : target;
};
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateIn = (member, obj) => Object(obj) !== obj ? __typeError('Cannot use the "in" operator on this value') : member.has(obj);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);

// input/netlify/site.ts
const netlifyBase = require("netlify/netlify-base");
const NetlifyEntity = netlifyBase.NetlifyEntity;
const base = require("monkec/base");
const action = base.action;
const cli = require("cli");
var _restoreDeploy_dec, _getDeploy_dec, _createDeploy_dec, _listDeploys_dec, _getSite_dec, _a, _init;
var _Site = class _Site extends (_a = NetlifyEntity, _getSite_dec = [action("get-site")], _listDeploys_dec = [action("list-deploys")], _createDeploy_dec = [action("create-deploy")], _getDeploy_dec = [action("get-deploy")], _restoreDeploy_dec = [action("restore-deploy")], _a) {
  constructor() {
    super(...arguments);
    __runInitializers(_init, 5, this);
  }
  getEntityName() {
    return this.definition.name;
  }
  /** Create a new Netlify site */
  create() {
    let urlPrefix = "";
    if (this.definition.team_slug) {
      urlPrefix = `/${this.definition.team_slug}`;
    }
    let existingSite = null;
    try {
      const allSites = this.makeRequest("GET", `${urlPrefix}/sites`);
      if (allSites && Array.isArray(allSites)) {
        existingSite = allSites.find((s) => s.name === this.definition.name);
      }
    } catch (error) {
      cli.output(`\u26A0\uFE0F  Could not check for existing sites: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
    if (existingSite) {
      this.state = {
        id: existingSite.id,
        name: existingSite.name,
        url: existingSite.ssl_url || existingSite.url,
        admin_url: existingSite.admin_url,
        custom_domain: existingSite.custom_domain,
        state: existingSite.state,
        created_at: existingSite.created_at,
        updated_at: existingSite.updated_at,
        existing: true
      };
      cli.output(`\u2705 Site ${this.definition.name} already exists, updating configuration`);
      this.update();
      return;
    }
    const body = {
      name: this.definition.name,
      created_via: "monk.io"
    };
    let createObj;
    try {
      createObj = this.makeRequest("POST", `${urlPrefix}/sites`, body);
    } catch (error) {
      let errorMessage = "Unknown error";
      if (error instanceof Error) {
        errorMessage = error.message;
      } else if (typeof error === "string") {
        errorMessage = error;
      } else {
        errorMessage = "Site creation failed";
      }
      cli.output(`\u274C Site creation failed: ${errorMessage}`);
      if (errorMessage.includes("422") && errorMessage.includes("subdomain")) {
        cli.output(`\u{1F504} Site creation failed with 422 (subdomain must be unique), trying to accept existing site...`);
        try {
          const retryAllSites = this.makeRequest("GET", `${urlPrefix}/sites`);
          if (retryAllSites && Array.isArray(retryAllSites)) {
            const site = retryAllSites.find((s) => s.name === this.definition.name);
            if (site) {
              this.state = {
                id: site.id,
                name: site.name,
                url: site.ssl_url || site.url,
                admin_url: site.admin_url,
                custom_domain: site.custom_domain,
                state: site.state,
                created_at: site.created_at,
                updated_at: site.updated_at,
                existing: true
              };
              cli.output(`\u2705 Site ${this.definition.name} already exists (after 422), updating configuration`);
              this.update();
              return;
            }
          }
        } catch (retryError) {
          cli.output(`\u26A0\uFE0F  Could not retry finding existing site: ${retryError instanceof Error ? retryError.message : "Unknown error"}`);
        }
      }
      throw new Error(`Failed to create site: ${errorMessage}`);
    }
    this.state = {
      id: createObj.id,
      name: createObj.name,
      url: createObj.ssl_url || createObj.url,
      admin_url: createObj.admin_url,
      custom_domain: createObj.custom_domain,
      state: createObj.state,
      created_at: createObj.created_at,
      updated_at: createObj.updated_at,
      existing: false
    };
    cli.output(`\u2705 Created Netlify site: ${createObj.name} (${createObj.ssl_url})`);
  }
  update() {
    if (!this.state.id) {
      this.create();
      return;
    }
    let urlPrefix = "";
    if (this.definition.team_slug) {
      urlPrefix = `/${this.definition.team_slug}`;
    }
    const body = {
      name: this.definition.name
    };
    if (this.definition.custom_domain) {
      body.custom_domain = this.definition.custom_domain;
    }
    if (this.definition.password) {
      body.password = this.definition.password;
    }
    if (this.definition.force_ssl !== void 0) {
      body.force_ssl = this.definition.force_ssl;
    }
    const updatedSite = this.makeRequest("PUT", `${urlPrefix}/sites/${this.state.id}`, body);
    this.state = {
      ...this.state,
      name: updatedSite.name,
      url: updatedSite.ssl_url || updatedSite.url,
      custom_domain: updatedSite.custom_domain,
      updated_at: updatedSite.updated_at
    };
    cli.output(`\u2705 Updated Netlify site: ${updatedSite.name}`);
  }
  delete() {
    if (!this.state.id) {
      cli.output("Site does not exist, nothing to delete");
      return;
    }
    let urlPrefix = "";
    if (this.definition.team_slug) {
      urlPrefix = `/${this.definition.team_slug}`;
    }
    this.deleteResource(`${urlPrefix}/sites/${this.state.id}`, "Site");
  }
  checkReadiness() {
    if (!this.state.id) {
      cli.output("\u{1F50D} Readiness check: No site ID available");
      return false;
    }
    let urlPrefix = "";
    if (this.definition.team_slug) {
      urlPrefix = `/${this.definition.team_slug}`;
    }
    try {
      const site = this.makeRequest("GET", `${urlPrefix}/sites/${this.state.id}`);
      cli.output(`\u{1F50D} Readiness check: Site state is "${site.state}"`);
      const isReady = site.state === "current" || site.state === "ready";
      cli.output(`\u{1F50D} Readiness check: Site ready = ${isReady}`);
      return isReady;
    } catch (error) {
      cli.output(`\u{1F50D} Readiness check failed: ${error instanceof Error ? error.message : "Unknown error"}`);
      return false;
    }
  }
  getSite() {
    if (!this.state.id) {
      throw new Error("Site does not exist");
    }
    let urlPrefix = "";
    if (this.definition.team_slug) {
      urlPrefix = `/${this.definition.team_slug}`;
    }
    const site = this.makeRequest("GET", `${urlPrefix}/sites/${this.state.id}`);
    cli.output(`Site: ${site.name}`);
    cli.output(`URL: ${site.ssl_url || site.url}`);
    cli.output(`State: ${site.state}`);
    cli.output(`Created: ${site.created_at}`);
  }
  listDeploys(args) {
    if (!this.state.id) {
      throw new Error("Site does not exist");
    }
    const page = args?.page || "1";
    const perPage = args?.per_page || "10";
    const deploys = this.makeRequest("GET", `/sites/${this.state.id}/deploys?page=${page}&per_page=${perPage}`);
    cli.output(`Deploys for site ${this.state.name}:`);
    deploys.forEach((deploy, index) => {
      cli.output(`${index + 1}. ${deploy.id} - ${deploy.state} - ${deploy.created_at}`);
    });
  }
  createDeploy(args) {
    if (!this.state.id) {
      throw new Error("Site does not exist");
    }
    const body = {};
    if (args?.dir) {
      body.dir = args.dir;
    }
    if (args?.functions_dir) {
      body.functions_dir = args.functions_dir;
    }
    if (args?.prod) {
      body.prod = args.prod === "true";
    }
    const deploy = this.makeRequest("POST", `/sites/${this.state.id}/deploys`, body);
    cli.output(`\u2705 Created deploy: ${deploy.id}`);
    cli.output(`Deploy URL: ${deploy.deploy_url}`);
    cli.output(`State: ${deploy.state}`);
  }
  getDeploy(args) {
    if (!this.state.id) {
      throw new Error("Site does not exist");
    }
    const deployId = args?.deploy_id;
    if (!deployId) {
      throw new Error("deploy_id argument is required");
    }
    const deploy = this.makeRequest("GET", `/sites/${this.state.id}/deploys/${deployId}`);
    cli.output(`Deploy: ${deploy.id}`);
    cli.output(`State: ${deploy.state}`);
    cli.output(`URL: ${deploy.deploy_url}`);
    cli.output(`Created: ${deploy.created_at}`);
    if (deploy.error_message) {
      cli.output(`Error: ${deploy.error_message}`);
    }
  }
  restoreDeploy(args) {
    if (!this.state.id) {
      throw new Error("Site does not exist");
    }
    const deployId = args?.deploy_id;
    if (!deployId) {
      throw new Error("deploy_id argument is required");
    }
    const restoredDeploy = this.makeRequest("POST", `/sites/${this.state.id}/deploys/${deployId}/restore`);
    cli.output(`\u2705 Restored deploy: ${restoredDeploy.id}`);
    cli.output(`Site is now live at: ${restoredDeploy.ssl_url || restoredDeploy.url}`);
  }
};
_init = __decoratorStart(_a);
__decorateElement(_init, 1, "getSite", _getSite_dec, _Site);
__decorateElement(_init, 1, "listDeploys", _listDeploys_dec, _Site);
__decorateElement(_init, 1, "createDeploy", _createDeploy_dec, _Site);
__decorateElement(_init, 1, "getDeploy", _getDeploy_dec, _Site);
__decorateElement(_init, 1, "restoreDeploy", _restoreDeploy_dec, _Site);
__decoratorMetadata(_init, _Site);
__name(_Site, "Site");
var Site = _Site;



function main(def, state, ctx) {
  const entity = new Site(def, state, ctx);
  return entity.main(ctx);
}
