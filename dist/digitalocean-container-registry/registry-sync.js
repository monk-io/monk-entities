
// Generated by MonkEC - targeting Goja runtime
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __knownSymbol = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __decoratorStart = (base) => [, , , __create(base?.[__knownSymbol("metadata")] ?? null)];
var __decoratorStrings = ["class", "method", "getter", "setter", "accessor", "field", "value", "get", "set"];
var __expectFn = (fn) => fn !== void 0 && typeof fn !== "function" ? __typeError("Function expected") : fn;
var __decoratorContext = (kind, name, done, metadata, fns) => ({ kind: __decoratorStrings[kind], name, metadata, addInitializer: (fn) => done._ ? __typeError("Already initialized") : fns.push(__expectFn(fn || null)) });
var __decoratorMetadata = (array, target) => __defNormalProp(target, __knownSymbol("metadata"), array[3]);
var __runInitializers = (array, flags, self, value) => {
  for (var i = 0, fns = array[flags >> 1], n = fns && fns.length; i < n; i++) flags & 1 ? fns[i].call(self) : value = fns[i].call(self, value);
  return value;
};
var __decorateElement = (array, flags, name, decorators, target, extra) => {
  var fn, it, done, ctx, access, k = flags & 7, s = !!(flags & 8), p = !!(flags & 16);
  var j = k > 3 ? array.length + 1 : k ? s ? 1 : 2 : 0, key = __decoratorStrings[k + 5];
  var initializers = k > 3 && (array[j - 1] = []), extraInitializers = array[j] || (array[j] = []);
  var desc = k && (!p && !s && (target = target.prototype), k < 5 && (k > 3 || !p) && __getOwnPropDesc(k < 4 ? target : { get [name]() {
    return __privateGet(this, extra);
  }, set [name](x) {
    return __privateSet(this, extra, x);
  } }, name));
  k ? p && k < 4 && __name(extra, (k > 2 ? "set " : k > 1 ? "get " : "") + name) : __name(target, name);
  for (var i = decorators.length - 1; i >= 0; i--) {
    ctx = __decoratorContext(k, name, done = {}, array[3], extraInitializers);
    if (k) {
      ctx.static = s, ctx.private = p, access = ctx.access = { has: p ? (x) => __privateIn(target, x) : (x) => name in x };
      if (k ^ 3) access.get = p ? (x) => (k ^ 1 ? __privateGet : __privateMethod)(x, target, k ^ 4 ? extra : desc.get) : (x) => x[name];
      if (k > 2) access.set = p ? (x, y) => __privateSet(x, target, y, k ^ 4 ? extra : desc.set) : (x, y) => x[name] = y;
    }
    it = (0, decorators[i])(k ? k < 4 ? p ? extra : desc[key] : k > 4 ? void 0 : { get: desc.get, set: desc.set } : target, ctx), done._ = 1;
    if (k ^ 4 || it === void 0) __expectFn(it) && (k > 4 ? initializers.unshift(it) : k ? p ? extra = it : desc[key] = it : target = it);
    else if (typeof it !== "object" || it === null) __typeError("Object expected");
    else __expectFn(fn = it.get) && (desc.get = fn), __expectFn(fn = it.set) && (desc.set = fn), __expectFn(fn = it.init) && initializers.unshift(fn);
  }
  return k || __decoratorMetadata(array, target), desc && __defProp(target, name, desc), p ? k ^ 4 ? extra : desc : target;
};
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateIn = (member, obj) => Object(obj) !== obj ? __typeError('Cannot use the "in" operator on this value') : member.has(obj);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);

// input/digitalocean-container-registry/registry.ts
const base = require("monkec/base");
const action = base.action;
const doProviderBase = require("digitalocean-container-registry/do-provider-base");
const DOProviderEntity = doProviderBase.DOProviderEntity;
const common = require("digitalocean-container-registry/common");
const validateRegistryRegion = common.validateRegistryRegion;
const validateSubscriptionTier = common.validateSubscriptionTier;
const validateGarbageCollectionType = common.validateGarbageCollectionType;
const cli = require("cli");
var _listRegistries_dec, _deleteRegistry_dec, _createRegistry_dec, _getStorageUsage_dec, _runGarbageCollection_dec, _listRepositories_dec, _getRegistry_dec, _a, _init;
var _Registry = class _Registry extends (_a = DOProviderEntity, _getRegistry_dec = [action()], _listRepositories_dec = [action()], _runGarbageCollection_dec = [action()], _getStorageUsage_dec = [action()], _createRegistry_dec = [action()], _deleteRegistry_dec = [action()], _listRegistries_dec = [action()], _a) {
  constructor() {
    super(...arguments);
    __runInitializers(_init, 5, this);
  }
  getEntityName() {
    return `DigitalOcean Container Registry: ${this.definition.name}`;
  }
  create() {
    const validatedRegion = validateRegistryRegion(this.definition.region);
    const validatedTier = validateSubscriptionTier(this.definition.subscription_tier);
    const existingRegistry = this.findExistingRegistry();
    if (existingRegistry) {
      if (existingRegistry.name === this.definition.name) {
        cli.output(`\u2705 Container Registry ${this.definition.name} already exists in ${existingRegistry.region}`);
        this.state.existing = true;
        this.updateStateFromRegistry(existingRegistry);
        const username = this.fetchUsername();
        if (username) {
          this.state.username = username;
        }
        return;
      } else {
        cli.output(`\u26A0\uFE0F  Registry "${existingRegistry.name}" already exists. DigitalOcean allows only one registry per account. Using existing registry.`);
        this.state.existing = true;
        this.updateStateFromRegistry(existingRegistry);
        const username = this.fetchUsername();
        if (username) {
          this.state.username = username;
        }
        return;
      }
    }
    const createRequest = {
      name: this.definition.name,
      region: validatedRegion,
      subscription_tier_slug: validatedTier
    };
    if (validatedTier === "professional" && this.definition.storage_quota_bytes) {
      createRequest.storage_quota_bytes = this.definition.storage_quota_bytes;
    }
    try {
      const response = this.makeRequest("POST", "/registry", createRequest);
      if (response.registry) {
        this.updateStateFromRegistry(response.registry);
        const username = this.fetchUsername();
        if (username) {
          this.state.username = username;
        }
        const serverUrl = this.state.server_url || `registry.digitalocean.com/${this.state.name}`;
        let subscriptionInfo = "";
        if (response.subscription) {
          subscriptionInfo = ` | Tier: ${response.subscription.tier.name} | Price: $${response.subscription.tier.monthly_price_in_cents / 100}/month`;
        }
        cli.output(`\u2705 Registry created: ${this.state.name} | Region: ${this.state.region} | Server: ${serverUrl}${subscriptionInfo}`);
      } else {
        throw new Error("Invalid response from DigitalOcean API - no registry object returned");
      }
    } catch (error) {
      if (error instanceof Error && error.message.includes("409") && error.message.includes("Conflict")) {
        const conflictRegistry = this.findExistingRegistry();
        if (conflictRegistry) {
          cli.output(`\u2705 Using existing registry: ${conflictRegistry.name} in ${conflictRegistry.region}`);
          this.state.existing = true;
          this.updateStateFromRegistry(conflictRegistry);
          const username = this.fetchUsername();
          if (username) {
            this.state.username = username;
          }
          return;
        } else {
          throw new Error(`Registry name "${this.definition.name}" is already taken but registry is not accessible`);
        }
      }
      throw new Error(`Failed to create container registry: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  update() {
    const existingRegistry = this.findExistingRegistry();
    if (existingRegistry) {
      this.updateStateFromRegistry(existingRegistry);
      this.state.existing = true;
      const username = this.fetchUsername();
      if (username) {
        this.state.username = username;
      }
      let warnings = [];
      if (this.definition.subscription_tier !== this.state.subscription_tier) {
        warnings.push("subscription tier change");
      }
      if (this.definition.storage_quota_bytes && this.definition.storage_quota_bytes !== this.state.storage_quota_bytes) {
        warnings.push("storage quota change");
      }
      if (warnings.length > 0) {
        cli.output(`\u26A0\uFE0F  ${warnings.join(" and ")} requires registry recreation`);
      }
      cli.output(`\u2705 Registry updated: ${existingRegistry.name} in ${existingRegistry.region}`);
    } else {
      this.create();
    }
  }
  delete() {
    if (!this.state.name) {
      cli.output("\u26AA No registry name in state, nothing to delete");
      return;
    }
    this.deleteResource(`/registry`, `container registry ${this.state.name}`);
    this.state.name = void 0;
    this.state.server_url = void 0;
    this.state.storage_usage_bytes = void 0;
    this.state.region = void 0;
    this.state.subscription_tier = void 0;
    this.state.storage_quota_bytes = void 0;
    this.state.created_at = void 0;
    this.state.username = void 0;
  }
  checkReadiness() {
    if (!this.state.name) {
      return false;
    }
    try {
      const response = this.makeRequest("GET", "/registry");
      if (response.registry) {
        this.updateStateFromRegistry(response.registry);
        return !!this.state.server_url;
      }
      return false;
    } catch (error) {
      return false;
    }
  }
  getRegistry(_args) {
    try {
      const response = this.makeRequest("GET", "/registry");
      if (response.registry) {
        this.updateStateFromRegistry(response.registry);
        const registry = response.registry;
        const serverUrl = `registry.digitalocean.com/${registry.name}`;
        const subscriptionTier = registry.subscription_tier || "basic";
        const storageQuota = registry.storage_quota_bytes ? ` | Storage Quota: ${registry.storage_quota_bytes} bytes` : "";
        const storageUsage = registry.storage_usage_bytes !== void 0 ? ` | Storage Usage: ${registry.storage_usage_bytes} bytes` : "";
        cli.output(`\u{1F4CA} Registry: ${registry.name} | Region: ${registry.region} | Tier: ${subscriptionTier} | Server: ${serverUrl} | Created: ${registry.created_at}${storageQuota}${storageUsage}`);
        return `Registry: ${registry.name} in ${registry.region}`;
      } else {
        throw new Error("Registry not found");
      }
    } catch (error) {
      throw new Error(`Failed to get registry info: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  listRepositories(_args) {
    try {
      if (!this.state.name) {
        throw new Error("Registry name not available. Ensure registry exists first.");
      }
      const response = this.makeRequest("GET", `/registry/${this.state.name}/repositoriesV2`);
      const repositories = response.repositories || [];
      if (repositories.length === 0) {
        cli.output(`Repositories in registry "${this.state.name}": No repositories found
Registry: ${this.state.name}
Server: ${this.state.server_url}`);
      } else {
        const repoList = repositories.map(
          (repo, index) => `${index + 1}. ${repo.name} (${repo.tag_count} tags)`
        );
        const info = [
          `Repositories in registry "${this.state.name}" (${repositories.length} total):`,
          ...repoList,
          `Registry: ${this.state.name}`,
          `Server: ${this.state.server_url}`
        ];
        cli.output(info.join("\n"));
      }
      return response;
    } catch (error) {
      throw new Error(`Failed to list repositories: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  /**
   * Private method to fetch and extract username from Docker credentials
   */
  fetchUsername() {
    try {
      const response = this.makeRequest("GET", "/registry/docker-credentials");
      if (response.auths && Object.keys(response.auths).length > 0) {
        const serverUrl = Object.keys(response.auths)[0];
        const auth = response.auths[serverUrl];
        try {
          const decoded = atob(auth.auth);
          const [username] = decoded.split(":");
          return username;
        } catch (decodeError) {
          return void 0;
        }
      }
      return void 0;
    } catch (error) {
      return void 0;
    }
  }
  runGarbageCollection(args) {
    const gcType = args.type || "untagged_manifests_only";
    try {
      if (!this.state.name) {
        throw new Error("Registry name not available. Ensure registry exists first.");
      }
      const validatedType = validateGarbageCollectionType(gcType);
      const response = this.makeRequest("POST", `/registry/${this.state.name}/garbage-collection`, {
        type: validatedType
      });
      if (response.garbage_collection) {
        cli.output(`Garbage collection started: ${response.garbage_collection.uuid}`);
      }
    } catch (error) {
      throw new Error(`Failed to run garbage collection: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  getStorageUsage(_args) {
    try {
      const response = this.makeRequest("GET", "/registry");
      if (response.registry) {
        this.updateStateFromRegistry(response.registry);
        const usageMB = response.registry.storage_usage_bytes !== void 0 ? Math.round(response.registry.storage_usage_bytes / (1024 * 1024)) : null;
        const quotaMB = response.registry.storage_quota_bytes ? Math.round(response.registry.storage_quota_bytes / (1024 * 1024)) : null;
        const usagePercent = response.registry.storage_usage_bytes !== void 0 && response.registry.storage_quota_bytes ? Math.round(response.registry.storage_usage_bytes / response.registry.storage_quota_bytes * 100) : null;
        let storageInfo = `\u{1F4BE} Storage for "${response.registry.name}":`;
        if (response.registry.storage_usage_bytes !== void 0) {
          storageInfo += ` Usage: ${usageMB} MB`;
        } else {
          storageInfo += ` Usage: Not available`;
        }
        if (response.registry.storage_quota_bytes) {
          storageInfo += ` | Quota: ${quotaMB} MB`;
          if (usagePercent !== null) {
            storageInfo += ` | Used: ${usagePercent}%`;
          }
        } else {
          storageInfo += ` | Quota: Unlimited (Basic tier)`;
        }
        cli.output(storageInfo);
        return response;
      }
    } catch (error) {
      throw new Error(`Failed to get storage usage: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  createRegistry(args) {
    const registryName = args.name || this.definition.name;
    const region = args.region || this.definition.region;
    const subscriptionTier = args.subscription_tier || this.definition.subscription_tier;
    const storageQuota = args.storage_quota_bytes || this.definition.storage_quota_bytes;
    try {
      const existingRegistry = this.findExistingRegistry();
      if (existingRegistry) {
        cli.output(`\u2705 Container Registry already exists: ${existingRegistry.name} in ${existingRegistry.region}`);
        this.updateStateFromRegistry(existingRegistry);
        const username = this.fetchUsername();
        if (username) {
          this.state.username = username;
        }
        return {
          status: "exists",
          registry: existingRegistry
        };
      }
      if (!registryName || !region || !subscriptionTier) {
        throw new Error("Missing required parameters: name, region, and subscription_tier are required");
      }
      const validatedRegion = validateRegistryRegion(region);
      const validatedTier = validateSubscriptionTier(subscriptionTier);
      const createRequest = {
        name: registryName,
        region: validatedRegion,
        subscription_tier_slug: validatedTier
      };
      if (validatedTier === "professional" && storageQuota) {
        createRequest.storage_quota_bytes = storageQuota;
      }
      const response = this.makeRequest("POST", "/registry", createRequest);
      if (response.registry) {
        this.updateStateFromRegistry(response.registry);
        const username = this.fetchUsername();
        if (username) {
          this.state.username = username;
        }
        const serverUrl = `registry.digitalocean.com/${response.registry.name}`;
        let subscriptionInfo = "";
        if (response.subscription) {
          subscriptionInfo = ` | Tier: ${response.subscription.tier.name} | Price: $${response.subscription.tier.monthly_price_in_cents / 100}/month`;
        }
        cli.output(`\u2705 Registry created: ${response.registry.name} | Region: ${response.registry.region} | Server: ${serverUrl}${subscriptionInfo}`);
        return {
          status: "created",
          registry: response.registry,
          subscription: response.subscription
        };
      } else {
        throw new Error("Invalid response from DigitalOcean API - no registry object returned");
      }
    } catch (error) {
      if (error instanceof Error) {
        if (error.message.includes("409") && error.message.includes("Conflict")) {
          try {
            const existingRegistry = this.findExistingRegistry();
            if (existingRegistry) {
              cli.output(`\u2705 Found existing registry: ${existingRegistry.name} in ${existingRegistry.region}`);
              this.updateStateFromRegistry(existingRegistry);
              const username = this.fetchUsername();
              if (username) {
                this.state.username = username;
              }
              return {
                status: "exists",
                registry: existingRegistry,
                message: "Registry with this name already exists"
              };
            } else {
              cli.output(`\u274C Registry name "${registryName}" is not available - try a different name`);
              return {
                status: "name_unavailable",
                message: `Registry name "${registryName}" is not available. Try a different name or check if it was recently deleted.`,
                suggested_action: "Try a different registry name"
              };
            }
          } catch (checkError) {
            cli.output(`\u274C Registry name "${registryName}" is not available - unable to check existing registries`);
            return {
              status: "name_unavailable",
              message: `Registry name "${registryName}" is not available. Try a different name.`,
              suggested_action: "Try a different registry name"
            };
          }
        }
        throw new Error(`Failed to create container registry: ${error.message}`);
      }
      throw error;
    }
  }
  deleteRegistry(_args) {
    try {
      const existingRegistry = this.findExistingRegistry();
      if (!existingRegistry) {
        cli.output("\u26AA No registry found to delete");
        return {
          status: "not_found",
          message: "No registry found to delete"
        };
      }
      this.makeRequest("DELETE", "/registry");
      this.state.name = void 0;
      this.state.server_url = void 0;
      this.state.storage_usage_bytes = void 0;
      this.state.region = void 0;
      this.state.subscription_tier = void 0;
      this.state.storage_quota_bytes = void 0;
      this.state.created_at = void 0;
      this.state.username = void 0;
      cli.output(`\u2705 Registry deleted: ${existingRegistry.name}`);
      return {
        status: "deleted",
        registry_name: existingRegistry.name
      };
    } catch (error) {
      cli.output(`\u274C Failed to delete registry: ${error instanceof Error ? error.message : "Unknown error"}`);
      throw new Error(`Failed to delete container registry: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  listRegistries(_args) {
    try {
      const existingRegistry = this.findExistingRegistry();
      if (!existingRegistry) {
        cli.output("\u26AA No container registries found");
        return {
          registries: [],
          count: 0
        };
      }
      const serverUrl = `registry.digitalocean.com/${existingRegistry.name}`;
      const subscriptionTier = existingRegistry.subscription_tier || "basic";
      let storageInfo = "";
      if (existingRegistry.storage_quota_bytes) {
        const quotaMB = Math.round(existingRegistry.storage_quota_bytes / (1024 * 1024));
        storageInfo += ` | Quota: ${quotaMB} MB`;
      }
      if (existingRegistry.storage_usage_bytes !== void 0) {
        const usageMB = Math.round(existingRegistry.storage_usage_bytes / (1024 * 1024));
        storageInfo += ` | Usage: ${usageMB} MB`;
      }
      cli.output(`\u{1F4CA} Registry: ${existingRegistry.name} | Region: ${existingRegistry.region} | Tier: ${subscriptionTier} | Server: ${serverUrl} | Created: ${existingRegistry.created_at}${storageInfo}`);
      return {
        registries: [existingRegistry],
        count: 1
      };
    } catch (error) {
      throw new Error(`Failed to list container registries: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  /**
   * Find existing registry (DigitalOcean allows only one registry per account)
   */
  findExistingRegistry() {
    try {
      const response = this.makeRequest("GET", "/registry");
      if (response.registry) {
        return response.registry;
      }
      return null;
    } catch (error) {
      if (error instanceof Error) {
        if (error.message.includes("404")) {
          return null;
        }
      }
      return null;
    }
  }
  /**
   * Update internal state from registry object
   */
  updateStateFromRegistry(registry) {
    this.state.name = registry.name;
    this.state.region = registry.region;
    this.state.subscription_tier = registry.subscription_tier;
    this.state.storage_quota_bytes = registry.storage_quota_bytes;
    this.state.storage_usage_bytes = registry.storage_usage_bytes;
    this.state.server_url = `registry.digitalocean.com/${registry.name}`;
    this.state.created_at = registry.created_at;
  }
};
_init = __decoratorStart(_a);
__decorateElement(_init, 1, "getRegistry", _getRegistry_dec, _Registry);
__decorateElement(_init, 1, "listRepositories", _listRepositories_dec, _Registry);
__decorateElement(_init, 1, "runGarbageCollection", _runGarbageCollection_dec, _Registry);
__decorateElement(_init, 1, "getStorageUsage", _getStorageUsage_dec, _Registry);
__decorateElement(_init, 1, "createRegistry", _createRegistry_dec, _Registry);
__decorateElement(_init, 1, "deleteRegistry", _deleteRegistry_dec, _Registry);
__decorateElement(_init, 1, "listRegistries", _listRegistries_dec, _Registry);
__decoratorMetadata(_init, _Registry);
__name(_Registry, "Registry");
var Registry = _Registry;



function main(def, state, ctx) {
  const entity = new Registry(def, state, ctx);
  return entity.main(ctx);
}
