
// Generated by MonkEC - targeting Goja runtime
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __knownSymbol = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __decoratorStart = (base) => [, , , __create(base?.[__knownSymbol("metadata")] ?? null)];
var __decoratorStrings = ["class", "method", "getter", "setter", "accessor", "field", "value", "get", "set"];
var __expectFn = (fn) => fn !== void 0 && typeof fn !== "function" ? __typeError("Function expected") : fn;
var __decoratorContext = (kind, name, done, metadata, fns) => ({ kind: __decoratorStrings[kind], name, metadata, addInitializer: (fn) => done._ ? __typeError("Already initialized") : fns.push(__expectFn(fn || null)) });
var __decoratorMetadata = (array, target) => __defNormalProp(target, __knownSymbol("metadata"), array[3]);
var __runInitializers = (array, flags, self, value) => {
  for (var i = 0, fns = array[flags >> 1], n = fns && fns.length; i < n; i++) flags & 1 ? fns[i].call(self) : value = fns[i].call(self, value);
  return value;
};
var __decorateElement = (array, flags, name, decorators, target, extra) => {
  var fn, it, done, ctx, access, k = flags & 7, s = !!(flags & 8), p = !!(flags & 16);
  var j = k > 3 ? array.length + 1 : k ? s ? 1 : 2 : 0, key = __decoratorStrings[k + 5];
  var initializers = k > 3 && (array[j - 1] = []), extraInitializers = array[j] || (array[j] = []);
  var desc = k && (!p && !s && (target = target.prototype), k < 5 && (k > 3 || !p) && __getOwnPropDesc(k < 4 ? target : { get [name]() {
    return __privateGet(this, extra);
  }, set [name](x) {
    return __privateSet(this, extra, x);
  } }, name));
  k ? p && k < 4 && __name(extra, (k > 2 ? "set " : k > 1 ? "get " : "") + name) : __name(target, name);
  for (var i = decorators.length - 1; i >= 0; i--) {
    ctx = __decoratorContext(k, name, done = {}, array[3], extraInitializers);
    if (k) {
      ctx.static = s, ctx.private = p, access = ctx.access = { has: p ? (x) => __privateIn(target, x) : (x) => name in x };
      if (k ^ 3) access.get = p ? (x) => (k ^ 1 ? __privateGet : __privateMethod)(x, target, k ^ 4 ? extra : desc.get) : (x) => x[name];
      if (k > 2) access.set = p ? (x, y) => __privateSet(x, target, y, k ^ 4 ? extra : desc.set) : (x, y) => x[name] = y;
    }
    it = (0, decorators[i])(k ? k < 4 ? p ? extra : desc[key] : k > 4 ? void 0 : { get: desc.get, set: desc.set } : target, ctx), done._ = 1;
    if (k ^ 4 || it === void 0) __expectFn(it) && (k > 4 ? initializers.unshift(it) : k ? p ? extra = it : desc[key] = it : target = it);
    else if (typeof it !== "object" || it === null) __typeError("Object expected");
    else __expectFn(fn = it.get) && (desc.get = fn), __expectFn(fn = it.set) && (desc.set = fn), __expectFn(fn = it.init) && initializers.unshift(fn);
  }
  return k || __decoratorMetadata(array, target), desc && __defProp(target, name, desc), p ? k ^ 4 ? extra : desc : target;
};
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateIn = (member, obj) => Object(obj) !== obj ? __typeError('Cannot use the "in" operator on this value') : member.has(obj);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);

// input/digitalocean-container-registry/registry.ts
const base = require("monkec/base");
const action = base.action;
const doProviderBase = require("digitalocean-container-registry/do-provider-base");
const DOProviderEntity = doProviderBase.DOProviderEntity;
const common = require("digitalocean-container-registry/common");
const validateRegistryRegion = common.validateRegistryRegion;
const validateSubscriptionTier = common.validateSubscriptionTier;
const validateGarbageCollectionType = common.validateGarbageCollectionType;
const cli = require("cli");
var _listRegistries_dec, _deleteRegistry_dec, _createRegistry_dec, _getStorageUsage_dec, _runGarbageCollection_dec, _getDockerCredentials_dec, _listRepositories_dec, _getRegistry_dec, _a, _init;
var _DigitalOceanContainerRegistry = class _DigitalOceanContainerRegistry extends (_a = DOProviderEntity, _getRegistry_dec = [action()], _listRepositories_dec = [action()], _getDockerCredentials_dec = [action()], _runGarbageCollection_dec = [action()], _getStorageUsage_dec = [action()], _createRegistry_dec = [action()], _deleteRegistry_dec = [action()], _listRegistries_dec = [action()], _a) {
  constructor() {
    super(...arguments);
    __runInitializers(_init, 5, this);
  }
  getEntityName() {
    return `DigitalOcean Container Registry: ${this.definition.name}`;
  }
  create() {
    cli.output(`\u{1F680} Creating DigitalOcean Container Registry: ${this.definition.name}`);
    const validatedRegion = validateRegistryRegion(this.definition.region);
    const validatedTier = validateSubscriptionTier(this.definition.subscription_tier);
    const existingRegistry = this.findExistingRegistry();
    if (existingRegistry) {
      cli.output(`\u2705 Container Registry ${this.definition.name} already exists`);
      this.state.existing = true;
      this.updateStateFromRegistry(existingRegistry);
      return;
    }
    const createRequest = {
      name: this.definition.name,
      region: validatedRegion,
      subscription_tier_slug: validatedTier
    };
    if (validatedTier === "professional" && this.definition.storage_quota_bytes) {
      createRequest.storage_quota_bytes = this.definition.storage_quota_bytes;
    }
    try {
      const response = this.makeRequest("POST", "/registry", createRequest);
      if (response.registry) {
        this.updateStateFromRegistry(response.registry);
        cli.output(`\u2705 Container Registry created successfully: ${this.state.name}`);
        cli.output(`   Region: ${this.state.region}`);
        if (this.state.server_url) {
          cli.output(`   Server URL: ${this.state.server_url}`);
        } else {
          cli.output(`   Server URL: (will be available shortly)`);
        }
        if (response.subscription) {
          cli.output(`   Subscription Tier: ${response.subscription.tier.name} (${response.subscription.tier.slug})`);
          cli.output(`   Monthly Price: $${response.subscription.tier.monthly_price_in_cents / 100}`);
        }
      } else {
        throw new Error("Invalid response from DigitalOcean API - no registry object returned");
      }
    } catch (error) {
      throw new Error(`Failed to create container registry: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  update() {
    if (!this.state.name) {
      cli.output(`\u{1F50D} Registry state not initialized, fetching current registry info...`);
      const existingRegistry = this.findExistingRegistry();
      if (existingRegistry) {
        this.updateStateFromRegistry(existingRegistry);
        this.state.existing = true;
      } else {
        cli.output("\u26AA No existing registry found, nothing to update");
        return;
      }
    }
    cli.output(`\u{1F504} Checking for DigitalOcean Container Registry updates: ${this.state.name}`);
    let hasUpdates = false;
    if (this.definition.subscription_tier !== this.state.subscription_tier) {
      cli.output(`\u{1F4CA} Updating subscription tier to: ${this.definition.subscription_tier}`);
      try {
        const updateRequest = {
          subscription_tier_slug: validateSubscriptionTier(this.definition.subscription_tier)
        };
        if (this.definition.subscription_tier === "professional" && this.definition.storage_quota_bytes) {
          updateRequest.storage_quota_bytes = this.definition.storage_quota_bytes;
        }
        this.makeRequest("PATCH", "/registry", updateRequest);
        cli.output(`\u2705 Registry subscription tier updated`);
        hasUpdates = true;
      } catch (error) {
        throw new Error(`Failed to update subscription tier: ${error instanceof Error ? error.message : "Unknown error"}`);
      }
    } else if (this.definition.subscription_tier === "professional" && this.definition.storage_quota_bytes && this.definition.storage_quota_bytes !== this.state.storage_quota_bytes) {
      cli.output(`\u{1F4BE} Updating storage quota to: ${this.definition.storage_quota_bytes} bytes`);
      try {
        this.makeRequest("PATCH", "/registry", {
          storage_quota_bytes: this.definition.storage_quota_bytes
        });
        cli.output(`\u2705 Registry storage quota updated`);
        hasUpdates = true;
      } catch (error) {
        throw new Error(`Failed to update storage quota: ${error instanceof Error ? error.message : "Unknown error"}`);
      }
    }
    if (!hasUpdates) {
      cli.output("\u26AA No supported changes detected, skipping update");
      return;
    }
    try {
      const response = this.makeRequest("GET", "/registry");
      if (response.registry) {
        this.updateStateFromRegistry(response.registry);
        cli.output(`\u2705 Container Registry updated successfully`);
      }
    } catch (error) {
      cli.output(`\u26A0\uFE0F  Update completed but failed to refresh state: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  delete() {
    if (!this.state.name) {
      cli.output("\u26AA No registry name in state, nothing to delete");
      return;
    }
    this.deleteResource(`/registry`, `container registry ${this.state.name}`);
    this.state.name = void 0;
    this.state.server_url = void 0;
    this.state.storage_usage_bytes = void 0;
  }
  checkReadiness() {
    if (!this.state.name) {
      return false;
    }
    try {
      const response = this.makeRequest("GET", "/registry");
      if (response.registry) {
        this.updateStateFromRegistry(response.registry);
        const isReady = !!this.state.server_url;
        if (isReady) {
          cli.output(`\u2705 Container Registry ${this.state.name} is ready`);
        } else {
          cli.output(`\u23F3 Container Registry ${this.state.name} is still being set up`);
        }
        return isReady;
      }
      return false;
    } catch (error) {
      cli.output(`\u274C Failed to check registry readiness: ${error instanceof Error ? error.message : "Unknown error"}`);
      return false;
    }
  }
  getRegistry(_args) {
    cli.output("\u{1F50D} Starting getRegistry action...");
    try {
      cli.output("\u{1F4E1} Making API request to /registry...");
      const response = this.makeRequest("GET", "/registry");
      cli.output(`\u{1F4E6} Got response: ${JSON.stringify(response, null, 2)}`);
      if (response.registry) {
        this.updateStateFromRegistry(response.registry);
        cli.output(`\u{1F4CA} Container Registry Information:`);
        cli.output(`   Name: ${response.registry.name}`);
        cli.output(`   Region: ${response.registry.region}`);
        cli.output(`   Subscription Tier: ${response.registry.subscription_tier}`);
        cli.output(`   Server URL: ${response.registry.server_url}`);
        cli.output(`   Created: ${response.registry.created_at}`);
        if (response.registry.storage_quota_bytes) {
          cli.output(`   Storage Quota: ${response.registry.storage_quota_bytes} bytes`);
        }
        if (response.registry.storage_usage_bytes !== void 0) {
          cli.output(`   Storage Usage: ${response.registry.storage_usage_bytes} bytes`);
        }
        const result = `Registry: ${response.registry.name} in ${response.registry.region}`;
        cli.output(`\u{1F3AF} Returning result: ${result}`);
        return result;
      } else {
        cli.output("\u274C No registry found in response");
        throw new Error("Registry not found");
      }
    } catch (error) {
      cli.output(`\u{1F4A5} Error in getRegistry: ${error instanceof Error ? error.message : "Unknown error"}`);
      throw new Error(`Failed to get registry info: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  listRepositories(_args) {
    try {
      const response = this.makeRequest("GET", "/registry/repositories");
      const repositories = response.repositories || [];
      cli.output(`\u{1F4CB} Repositories in registry "${this.state.name}" (${repositories.length} total):`);
      if (repositories.length === 0) {
        cli.output("   No repositories found");
      } else {
        repositories.forEach((repo, index) => {
          cli.output(`   ${index + 1}. ${repo.name} (${repo.tag_count} tags)`);
        });
      }
      cli.output(`
Registry: ${this.state.name}`);
      cli.output(`Server URL: ${this.state.server_url}`);
      return response;
    } catch (error) {
      throw new Error(`Failed to list repositories: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  getDockerCredentials(_args) {
    try {
      const response = this.makeRequest("GET", "/registry/docker-credentials");
      cli.output(`\u{1F511} Docker Credentials for registry "${this.state.name}":`);
      if (response.auths) {
        Object.keys(response.auths).forEach((server) => {
          const auth = response.auths[server];
          cli.output(`
   Server: ${server}`);
          cli.output(`   Username: ${auth.username || "N/A"}`);
          cli.output(`   Password: ${auth.password ? "[HIDDEN]" : "N/A"}`);
          cli.output(`   Auth: ${auth.auth ? "[HIDDEN]" : "N/A"}`);
        });
      }
      cli.output(`
\u{1F4A1} Use these credentials to authenticate with your registry:`);
      cli.output(`   docker login ${this.state.server_url}`);
      return response;
    } catch (error) {
      throw new Error(`Failed to get Docker credentials: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  runGarbageCollection(args) {
    const gcType = args.type || "untagged_manifests_only";
    try {
      const validatedType = validateGarbageCollectionType(gcType);
      cli.output(`\u{1F5D1}\uFE0F  Starting garbage collection...`);
      cli.output(`   Type: ${validatedType}`);
      const response = this.makeRequest("POST", "/registry/garbage-collection", {
        type: validatedType
      });
      if (response.garbage_collection) {
        cli.output(`\u2705 Garbage collection started successfully`);
        cli.output(`   UUID: ${response.garbage_collection.uuid}`);
        cli.output(`   Status: ${response.garbage_collection.status}`);
        cli.output(`   Created: ${response.garbage_collection.created_at}`);
      }
    } catch (error) {
      throw new Error(`Failed to run garbage collection: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  getStorageUsage(_args) {
    try {
      const response = this.makeRequest("GET", "/registry");
      if (response.registry) {
        this.updateStateFromRegistry(response.registry);
        const usageMB = response.registry.storage_usage_bytes !== void 0 ? Math.round(response.registry.storage_usage_bytes / (1024 * 1024)) : null;
        const quotaMB = response.registry.storage_quota_bytes ? Math.round(response.registry.storage_quota_bytes / (1024 * 1024)) : null;
        const usagePercent = response.registry.storage_usage_bytes !== void 0 && response.registry.storage_quota_bytes ? Math.round(response.registry.storage_usage_bytes / response.registry.storage_quota_bytes * 100) : null;
        cli.output(`\u{1F4BE} Storage Usage for registry "${response.registry.name}":`);
        if (response.registry.storage_usage_bytes !== void 0) {
          cli.output(`   Current Usage: ${response.registry.storage_usage_bytes} bytes (${usageMB} MB)`);
        } else {
          cli.output(`   Current Usage: Not available`);
        }
        if (response.registry.storage_quota_bytes) {
          cli.output(`   Storage Quota: ${response.registry.storage_quota_bytes} bytes (${quotaMB} MB)`);
          if (usagePercent !== null) {
            cli.output(`   Usage Percentage: ${usagePercent}%`);
          }
        } else {
          cli.output(`   Storage Quota: Unlimited (Basic tier)`);
        }
        return response;
      }
    } catch (error) {
      throw new Error(`Failed to get storage usage: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  createRegistry(args) {
    cli.output("\u{1F680} Creating Container Registry via action...");
    const registryName = args.name || this.definition.name;
    const region = args.region || this.definition.region;
    const subscriptionTier = args.subscription_tier || this.definition.subscription_tier;
    const storageQuota = args.storage_quota_bytes || this.definition.storage_quota_bytes;
    try {
      const existingRegistry = this.findExistingRegistry();
      if (existingRegistry) {
        cli.output(`\u2705 Container Registry already exists: ${existingRegistry.name}`);
        this.updateStateFromRegistry(existingRegistry);
        return {
          status: "exists",
          registry: existingRegistry
        };
      }
      if (!registryName || !region || !subscriptionTier) {
        throw new Error("Missing required parameters: name, region, and subscription_tier are required");
      }
      const validatedRegion = validateRegistryRegion(region);
      const validatedTier = validateSubscriptionTier(subscriptionTier);
      const createRequest = {
        name: registryName,
        region: validatedRegion,
        subscription_tier_slug: validatedTier
      };
      if (validatedTier === "professional" && storageQuota) {
        createRequest.storage_quota_bytes = storageQuota;
      }
      cli.output(`\u{1F4CB} Creating registry with configuration:`);
      cli.output(`   Name: ${registryName}`);
      cli.output(`   Region: ${validatedRegion}`);
      cli.output(`   Subscription Tier: ${validatedTier}`);
      if (createRequest.storage_quota_bytes) {
        cli.output(`   Storage Quota: ${createRequest.storage_quota_bytes} bytes`);
      }
      const response = this.makeRequest("POST", "/registry", createRequest);
      if (response.registry) {
        this.updateStateFromRegistry(response.registry);
        cli.output(`\u2705 Container Registry created successfully: ${response.registry.name}`);
        cli.output(`   Region: ${response.registry.region}`);
        if (response.registry.server_url) {
          cli.output(`   Server URL: ${response.registry.server_url}`);
        } else {
          cli.output(`   Server URL: (will be available shortly)`);
        }
        if (response.subscription) {
          cli.output(`   Subscription Tier: ${response.subscription.tier.name} (${response.subscription.tier.slug})`);
          cli.output(`   Monthly Price: $${response.subscription.tier.monthly_price_in_cents / 100}`);
        }
        return {
          status: "created",
          registry: response.registry,
          subscription: response.subscription
        };
      } else {
        throw new Error("Invalid response from DigitalOcean API - no registry object returned");
      }
    } catch (error) {
      if (error instanceof Error) {
        if (error.message.includes("409") && error.message.includes("Conflict")) {
          cli.output(`\u26A0\uFE0F  Registry name already exists. This might be due to:`);
          cli.output(`   1. Registry exists in another region`);
          cli.output(`   2. Registry name is reserved`);
          cli.output(`   3. Registry was recently deleted (names have cooldown period)`);
          try {
            const existingRegistry = this.findExistingRegistry();
            if (existingRegistry) {
              cli.output(`\u2705 Found existing registry: ${existingRegistry.name}`);
              this.updateStateFromRegistry(existingRegistry);
              return {
                status: "exists",
                registry: existingRegistry,
                message: "Registry with this name already exists"
              };
            } else {
              cli.output(`\u274C No registry found in account, but name "${registryName}" is not available`);
              return {
                status: "name_unavailable",
                message: `Registry name "${registryName}" is not available. Try a different name or check if it was recently deleted.`,
                suggested_action: "Try a different registry name"
              };
            }
          } catch (checkError) {
            cli.output(`\u26A0\uFE0F  Unable to check existing registries: ${checkError instanceof Error ? checkError.message : "Unknown error"}`);
            return {
              status: "name_unavailable",
              message: `Registry name "${registryName}" is not available. Try a different name.`,
              suggested_action: "Try a different registry name"
            };
          }
        }
        cli.output(`\u274C Failed to create registry: ${error.message}`);
        throw new Error(`Failed to create container registry: ${error.message}`);
      }
      throw error;
    }
  }
  deleteRegistry(_args) {
    cli.output("\u{1F5D1}\uFE0F  Deleting Container Registry via action...");
    try {
      const existingRegistry = this.findExistingRegistry();
      if (!existingRegistry) {
        cli.output("\u26AA No registry found to delete");
        return {
          status: "not_found",
          message: "No registry found to delete"
        };
      }
      cli.output(`\u{1F50D} Found registry to delete: ${existingRegistry.name}`);
      this.makeRequest("DELETE", "/registry");
      this.state.name = void 0;
      this.state.server_url = void 0;
      this.state.storage_usage_bytes = void 0;
      this.state.region = void 0;
      this.state.subscription_tier = void 0;
      this.state.storage_quota_bytes = void 0;
      this.state.created_at = void 0;
      cli.output(`\u2705 Container Registry deleted successfully: ${existingRegistry.name}`);
      return {
        status: "deleted",
        registry_name: existingRegistry.name
      };
    } catch (error) {
      cli.output(`\u274C Failed to delete registry: ${error instanceof Error ? error.message : "Unknown error"}`);
      throw new Error(`Failed to delete container registry: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  listRegistries(_args) {
    cli.output("\u{1F4CB} Listing Container Registries...");
    try {
      const existingRegistry = this.findExistingRegistry();
      if (!existingRegistry) {
        cli.output("\u26AA No container registries found");
        return {
          registries: [],
          count: 0
        };
      }
      cli.output(`\u{1F4CA} Container Registry Information:`);
      cli.output(`   Name: ${existingRegistry.name}`);
      cli.output(`   Region: ${existingRegistry.region}`);
      cli.output(`   Subscription Tier: ${existingRegistry.subscription_tier}`);
      cli.output(`   Server URL: ${existingRegistry.server_url}`);
      cli.output(`   Created: ${existingRegistry.created_at}`);
      if (existingRegistry.storage_quota_bytes) {
        const quotaMB = Math.round(existingRegistry.storage_quota_bytes / (1024 * 1024));
        cli.output(`   Storage Quota: ${existingRegistry.storage_quota_bytes} bytes (${quotaMB} MB)`);
      }
      if (existingRegistry.storage_usage_bytes !== void 0) {
        const usageMB = Math.round(existingRegistry.storage_usage_bytes / (1024 * 1024));
        cli.output(`   Storage Usage: ${existingRegistry.storage_usage_bytes} bytes (${usageMB} MB)`);
      }
      return {
        registries: [existingRegistry],
        count: 1
      };
    } catch (error) {
      cli.output(`\u274C Failed to list registries: ${error instanceof Error ? error.message : "Unknown error"}`);
      throw new Error(`Failed to list container registries: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  /**
   * Find existing registry (DigitalOcean allows only one registry per account)
   */
  findExistingRegistry() {
    try {
      cli.output("\u{1F50D} Checking for existing registry...");
      const response = this.makeRequest("GET", "/registry");
      if (response.registry) {
        cli.output(`\u2705 Found existing registry: ${response.registry.name} in ${response.registry.region}`);
        return response.registry;
      }
      cli.output("\u26AA No existing registry found");
      return null;
    } catch (error) {
      if (error instanceof Error) {
        cli.output(`\u26A0\uFE0F  Error checking for existing registry: ${error.message}`);
        if (error.message.includes("404")) {
          cli.output("\u26AA No registry configured for this account (404 response)");
          return null;
        }
      }
      cli.output("\u26A0\uFE0F  Unable to check for existing registry, assuming none exists");
      return null;
    }
  }
  /**
   * Update internal state from registry object
   */
  updateStateFromRegistry(registry) {
    this.state.name = registry.name;
    this.state.region = registry.region;
    this.state.subscription_tier = registry.subscription_tier;
    this.state.storage_quota_bytes = registry.storage_quota_bytes;
    this.state.storage_usage_bytes = registry.storage_usage_bytes;
    this.state.server_url = registry.server_url;
    this.state.created_at = registry.created_at;
  }
};
_init = __decoratorStart(_a);
__decorateElement(_init, 1, "getRegistry", _getRegistry_dec, _DigitalOceanContainerRegistry);
__decorateElement(_init, 1, "listRepositories", _listRepositories_dec, _DigitalOceanContainerRegistry);
__decorateElement(_init, 1, "getDockerCredentials", _getDockerCredentials_dec, _DigitalOceanContainerRegistry);
__decorateElement(_init, 1, "runGarbageCollection", _runGarbageCollection_dec, _DigitalOceanContainerRegistry);
__decorateElement(_init, 1, "getStorageUsage", _getStorageUsage_dec, _DigitalOceanContainerRegistry);
__decorateElement(_init, 1, "createRegistry", _createRegistry_dec, _DigitalOceanContainerRegistry);
__decorateElement(_init, 1, "deleteRegistry", _deleteRegistry_dec, _DigitalOceanContainerRegistry);
__decorateElement(_init, 1, "listRegistries", _listRegistries_dec, _DigitalOceanContainerRegistry);
__decoratorMetadata(_init, _DigitalOceanContainerRegistry);
__name(_DigitalOceanContainerRegistry, "DigitalOceanContainerRegistry");
var DigitalOceanContainerRegistry = _DigitalOceanContainerRegistry;



function main(def, state, ctx) {
  const entity = new DigitalOceanContainerRegistry(def, state, ctx);
  return entity.main(ctx);
}
