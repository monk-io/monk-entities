
// Generated by MonkEC - targeting Goja runtime
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);

// input/gcp/cloudStorageHmacKeys.ts
const gcpBase = require("gcp/gcp-base");
const GcpEntity = gcpBase.GcpEntity;
const common = require("gcp/common");
const CLOUD_STORAGE_API_URL = common.CLOUD_STORAGE_API_URL;
const secret = require("secret");
const cli = require("cli");
var DEFAULT_HMAC_ACCESS_SECRET = "gcs-hmac-access-key";
var DEFAULT_HMAC_SECRET_SECRET = "gcs-hmac-secret-key";
var _CloudStorageHmacKeys = class _CloudStorageHmacKeys extends GcpEntity {
  getEntityName() {
    const label = this.definition.name || this.definition.service_account_email;
    return `Cloud Storage HMAC Keys ${label}`;
  }
  getHmacKeysUrl() {
    return `${CLOUD_STORAGE_API_URL}/projects/${this.projectId}/hmacKeys`;
  }
  getHmacKeyUrl(accessKey) {
    return `${this.getHmacKeysUrl()}/${accessKey}`;
  }
  get accessKeySecretName() {
    return this.definition.access_key_secret_ref || DEFAULT_HMAC_ACCESS_SECRET;
  }
  get secretKeySecretName() {
    return this.definition.secret_key_secret_ref || DEFAULT_HMAC_SECRET_SECRET;
  }
  readSecret(name) {
    try {
      return secret.get(name);
    } catch {
      return void 0;
    }
  }
  getExistingKey(accessKey) {
    return this.checkResourceExists(this.getHmacKeyUrl(accessKey));
  }
  create() {
    if (!this.definition.service_account_email) {
      throw new Error("service_account_email is required to create HMAC keys");
    }
    const storedAccessKey = this.readSecret(this.accessKeySecretName);
    const storedSecretKey = this.readSecret(this.secretKeySecretName);
    if (this.state.access_key && storedAccessKey && storedSecretKey) {
      const existing = this.getExistingKey(this.state.access_key);
      if (existing) {
        cli.output(`HMAC key already exists, adopting: ${this.state.access_key}`);
        this.state.service_account_email = existing.serviceAccountEmail;
        this.state.id = existing.id || this.state.access_key;
        this.state.existing = true;
        return;
      }
    }
    const url = `${this.getHmacKeysUrl()}?serviceAccountEmail=${encodeURIComponent(this.definition.service_account_email)}`;
    cli.output(`Creating Cloud Storage HMAC keys for ${this.definition.service_account_email}`);
    const result = this.post(url);
    const accessKey = result.accessId || result.access_key || result.accessKey;
    const secretKey = result.secret || result.secretKey;
    if (!accessKey || !secretKey) {
      throw new Error(`Unexpected response from HMAC key creation: ${JSON.stringify(result)}`);
    }
    secret.set(this.accessKeySecretName, accessKey);
    secret.set(this.secretKeySecretName, secretKey);
    cli.output(`Stored HMAC keys in secrets (${this.accessKeySecretName} / ${this.secretKeySecretName})`);
    this.state.access_key = accessKey;
    this.state.id = result.id || accessKey;
    this.state.service_account_email = result.serviceAccountEmail || this.definition.service_account_email;
    this.state.existing = false;
  }
  update() {
    if (!this.state.access_key) {
      this.create();
      return;
    }
    cli.output("HMAC keys cannot be updated. Delete and recreate if needed.");
  }
  delete() {
    if (this.state.existing) {
      cli.output("HMAC keys were not created by this entity, skipping delete");
      return;
    }
    if (!this.state.access_key) {
      cli.output("No HMAC access key to delete");
      return;
    }
    const keyUrl = this.getHmacKeyUrl(this.state.access_key);
    cli.output(`Disabling HMAC key: ${this.state.access_key}`);
    try {
      this.put(keyUrl, { state: "INACTIVE" });
    } catch (error) {
      cli.output(`Warning: failed to disable key before delete: ${error.message}`);
    }
    cli.output(`Deleting HMAC key: ${this.state.access_key}`);
    this.httpDelete(keyUrl);
    try {
      secret.remove(this.accessKeySecretName);
    } catch {
      cli.output(`Could not remove secret: ${this.accessKeySecretName}`);
    }
    try {
      secret.remove(this.secretKeySecretName);
    } catch {
      cli.output(`Could not remove secret: ${this.secretKeySecretName}`);
    }
    this.state.access_key = void 0;
    this.state.id = void 0;
    this.state.service_account_email = void 0;
    this.state.existing = false;
  }
  checkReadiness() {
    if (!this.state.access_key) {
      cli.output("HMAC access key not created yet");
      return false;
    }
    const key = this.getExistingKey(this.state.access_key);
    if (!key) {
      cli.output("HMAC key not found");
      return false;
    }
    const storedAccessKey = this.readSecret(this.accessKeySecretName);
    const storedSecretKey = this.readSecret(this.secretKeySecretName);
    if (!storedAccessKey || !storedSecretKey) {
      cli.output("HMAC secrets not found");
      return false;
    }
    return true;
  }
  checkLiveness() {
    return !!this.state.access_key;
  }
};
__name(_CloudStorageHmacKeys, "CloudStorageHmacKeys");
__publicField(_CloudStorageHmacKeys, "readiness", { period: 5, initialDelay: 2, attempts: 10 });
var CloudStorageHmacKeys = _CloudStorageHmacKeys;



function main(def, state, ctx) {
  const entity = new CloudStorageHmacKeys(def, state, ctx);
  return entity.main(ctx);
}
