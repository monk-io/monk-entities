
// Generated by MonkEC - targeting Goja runtime
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);

// input/gcp/serviceAccountKey.ts
const gcpBase = require("gcp/gcp-base");
const GcpEntity = gcpBase.GcpEntity;
const secret = require("secret");
const cli = require("cli");
const common = require("gcp/common");
const IAM_API_URL = common.IAM_API_URL;
var _ServiceAccountKey = class _ServiceAccountKey extends GcpEntity {
  getEntityName() {
    return `Service Account Key for ${this.definition.service_account_id}`;
  }
  /**
   * Get the IAM API URL for keys
   */
  get keysApiUrl() {
    return `${IAM_API_URL}/projects/${this.projectId}/serviceAccounts/${this.definition.service_account_id}/keys`;
  }
  /**
   * Check if the key already exists (by checking if secret has content)
   */
  keyExists() {
    try {
      const existing = secret.get(this.definition.secret);
      return !!existing;
    } catch {
      return false;
    }
  }
  create() {
    if (this.keyExists() && this.state.name) {
      cli.output(`Key already exists in secret ${this.definition.secret}, adopting...`);
      this.state.existing = true;
      return;
    }
    const body = {
      privateKeyType: this.definition.key_type || "TYPE_GOOGLE_CREDENTIALS_FILE",
      keyAlgorithm: this.definition.key_algorithm || "KEY_ALG_RSA_2048"
    };
    cli.output(`Creating service account key for: ${this.definition.service_account_id}`);
    const result = this.post(this.keysApiUrl, body);
    if (result.privateKeyData) {
      try {
        const decoded = atob(result.privateKeyData);
        secret.set(this.definition.secret, decoded);
        cli.output(`Service account key stored in secret: ${this.definition.secret}`);
      } catch {
        secret.set(this.definition.secret, result.privateKeyData);
        cli.output(`Service account key stored in secret (base64): ${this.definition.secret}`);
      }
    }
    this.state.name = result.name;
    this.state.key_id = result.name?.split("/").pop();
    this.state.key_algorithm = result.keyAlgorithm;
    this.state.key_type = result.privateKeyType;
    this.state.valid_after_time = result.validAfterTime;
    this.state.existing = false;
    cli.output(`Service account key created: ${this.state.key_id}`);
  }
  update() {
    if (!this.state.name) {
      this.create();
      return;
    }
    cli.output("Service account keys cannot be updated. Delete and recreate if needed.");
  }
  delete() {
    if (this.state.existing) {
      cli.output(`Key was not created by this entity, skipping delete`);
      return;
    }
    if (!this.state.name) {
      cli.output("No key to delete");
      return;
    }
    cli.output(`Deleting service account key: ${this.state.key_id}`);
    this.httpDelete(`${IAM_API_URL}/${this.state.name}`);
    try {
      secret.remove(this.definition.secret);
      cli.output(`Removed secret: ${this.definition.secret}`);
    } catch {
      cli.output(`Could not remove secret: ${this.definition.secret}`);
    }
    cli.output(`Service account key deleted`);
  }
  checkReadiness() {
    if (!this.state.name) {
      cli.output("Key not created yet");
      return false;
    }
    try {
      const keyData = secret.get(this.definition.secret);
      if (!keyData) {
        cli.output("Key not found in secret");
        return false;
      }
    } catch {
      cli.output("Could not retrieve key from secret");
      return false;
    }
    cli.output(`Service account key is ready`);
    return true;
  }
  checkLiveness() {
    try {
      const keyData = secret.get(this.definition.secret);
      return !!keyData;
    } catch {
      return false;
    }
  }
};
__name(_ServiceAccountKey, "ServiceAccountKey");
__publicField(_ServiceAccountKey, "readiness", { period: 5, initialDelay: 2, attempts: 10 });
var ServiceAccountKey = _ServiceAccountKey;



function main(def, state, ctx) {
  const entity = new ServiceAccountKey(def, state, ctx);
  return entity.main(ctx);
}
