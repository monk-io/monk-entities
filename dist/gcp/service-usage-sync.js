
// Generated by MonkEC - targeting Goja runtime
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);

// input/gcp/serviceUsage.ts
const base = require("monkec/base");
const MonkEntity = base.MonkEntity;
const gcp = require("cloud/gcp");
const cli = require("cli");
const common = require("gcp/common");
const SERVICE_USAGE_API_URL = common.SERVICE_USAGE_API_URL;
const parseGcpError = common.parseGcpError;
const isOperationDone = common.isOperationDone;
var _ServiceUsage = class _ServiceUsage extends MonkEntity {
  constructor() {
    super(...arguments);
    __publicField(this, "projectId");
  }
  before() {
    this.projectId = this.definition.project || gcp.getProject();
    if (!this.projectId) {
      throw new Error("GCP project ID not available");
    }
  }
  /**
   * Check if a single API is enabled
   */
  checkApi(apiName) {
    const url = `${SERVICE_USAGE_API_URL}/projects/${this.projectId}/services/${apiName}`;
    const response = gcp.get(url);
    if (response.error) {
      throw new Error(`Failed to check API ${apiName}: ${parseGcpError(response)}`);
    }
    const data = JSON.parse(response.body);
    return data.state === "ENABLED";
  }
  /**
   * Enable a single API
   */
  enableApi(apiName) {
    cli.output(`Enabling API: ${apiName}`);
    const url = `${SERVICE_USAGE_API_URL}/projects/${this.projectId}/services/${apiName}:enable`;
    const response = gcp.post(url);
    if (response.error) {
      throw new Error(`Failed to enable API ${apiName}: ${parseGcpError(response)}`);
    }
    return JSON.parse(response.body);
  }
  /**
   * Check which APIs from a list are not yet enabled
   */
  checkApis(apiNames) {
    const names = apiNames.map(
      (api) => `names=projects/${this.projectId}/services/${api}`
    ).join("&");
    const url = `${SERVICE_USAGE_API_URL}/projects/${this.projectId}/services/:batchGet?${names}`;
    const response = gcp.get(url);
    if (response.error) {
      throw new Error(`Failed to batch check APIs: ${parseGcpError(response)}`);
    }
    const data = JSON.parse(response.body);
    const enabledApis = /* @__PURE__ */ new Set();
    if (data.services) {
      for (const service of data.services) {
        if (service.state === "ENABLED") {
          const parts = service.name.split("/");
          enabledApis.add(parts[parts.length - 1]);
        }
      }
    }
    return apiNames.filter((api) => !enabledApis.has(api));
  }
  /**
   * Batch enable multiple APIs
   */
  enableApis(apiNames) {
    cli.output(`Enabling ${apiNames.length} APIs: ${apiNames.join(", ")}`);
    const url = `${SERVICE_USAGE_API_URL}/projects/${this.projectId}/services/:batchEnable`;
    const body = { serviceIds: apiNames };
    const response = gcp.post(url, { body: JSON.stringify(body) });
    if (response.error) {
      throw new Error(`Failed to batch enable APIs: ${parseGcpError(response)}`);
    }
    return JSON.parse(response.body);
  }
  create() {
    if (this.definition.apis && this.definition.apis.length > 0) {
      const apis = [...this.definition.apis];
      const toEnable = this.checkApis(apis);
      if (toEnable.length === 0) {
        cli.output("All APIs are already enabled");
        this.state.ready = true;
        this.state.enabled_apis = apis;
        return;
      }
      const result = this.enableApis(toEnable);
      this.state.ready = false;
      this.state.operation = result.name;
      this.state.enabled_apis = apis;
    } else if (this.definition.name) {
      if (this.checkApi(this.definition.name)) {
        cli.output(`API ${this.definition.name} is already enabled`);
        this.state.ready = true;
        this.state.enabled_apis = [this.definition.name];
        return;
      }
      const result = this.enableApi(this.definition.name);
      this.state.ready = false;
      this.state.operation = result.name;
      this.state.enabled_apis = [this.definition.name];
    } else {
      throw new Error("Either 'name' or 'apis' must be specified");
    }
  }
  update() {
    this.create();
  }
  delete() {
    cli.output("Service Usage entity does not disable APIs on delete");
  }
  checkReadiness() {
    if (this.state.ready) {
      return true;
    }
    if (this.state.operation) {
      const url = `${SERVICE_USAGE_API_URL}/projects/${this.projectId}/${this.state.operation}`;
      const response = gcp.get(url);
      if (response.error) {
        cli.output(`Error checking operation: ${parseGcpError(response)}`);
        return false;
      }
      const operation = JSON.parse(response.body);
      if (isOperationDone(operation)) {
        cli.output("API enablement operation completed");
        this.state.ready = true;
        this.state.operation = void 0;
        return true;
      }
      const statusInfo = operation.status || (operation.done === false ? "in progress" : "unknown");
      cli.output(`Operation status: ${statusInfo}`);
      return false;
    }
    if (this.definition.apis && this.definition.apis.length > 0) {
      const notEnabled = this.checkApis([...this.definition.apis]);
      if (notEnabled.length === 0) {
        this.state.ready = true;
        return true;
      }
      cli.output(`APIs not yet enabled: ${notEnabled.join(", ")}`);
      return false;
    } else if (this.definition.name) {
      if (this.checkApi(this.definition.name)) {
        this.state.ready = true;
        return true;
      }
      cli.output(`API ${this.definition.name} not yet enabled`);
      return false;
    }
    return false;
  }
  checkLiveness() {
    return this.checkReadiness();
  }
};
__name(_ServiceUsage, "ServiceUsage");
__publicField(_ServiceUsage, "readiness", { period: 10, initialDelay: 2, attempts: 30 });
var ServiceUsage = _ServiceUsage;



function main(def, state, ctx) {
  const entity = new ServiceUsage(def, state, ctx);
  return entity.main(ctx);
}
