// Generated by MonkEC - targeting Goja runtime
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);

// input/gcp/gcpBase.ts
var gcp_base_exports = {};
__export(gcp_base_exports, {
  GcpEntity: () => GcpEntity
});
module.exports = __toCommonJS(gcp_base_exports);
var import_base = require("monkec/base");
var import_gcp = __toESM(require("cloud/gcp"));
var import_cli = __toESM(require("cli"));

// input/gcp/common.ts
function parseGcpError(response) {
  if (response.error) {
    try {
      const body = JSON.parse(response.body);
      if (body.error?.message) {
        return `${response.error}: ${body.error.message}`;
      }
    } catch {
    }
    return `${response.error}: ${response.body}`;
  }
  return response.body;
}
function isOperationDone(operation) {
  if (operation === void 0 || operation === null) {
    return false;
  }
  if (typeof operation === "object") {
    if (operation.done === true) {
      return true;
    }
    if (operation.status) {
      return operation.status === "DONE" || operation.status === "finished" || operation.status === "completed";
    }
    return false;
  }
  return operation === "DONE" || operation === "finished" || operation === "completed";
}
function isOperationFailed(operation) {
  if (operation === void 0 || operation === null) {
    return false;
  }
  if (typeof operation === "object") {
    if (operation.done === true && operation.error) {
      return true;
    }
    if (operation.status) {
      return operation.status === "FAILED" || operation.status === "failed" || operation.status === "error";
    }
    return false;
  }
  return operation === "FAILED" || operation === "failed" || operation === "error";
}

// input/gcp/gcpBase.ts
var GcpEntity = class extends import_base.MonkEntity {
  constructor() {
    super(...arguments);
    /**
     * GCP Project ID
     */
    __publicField(this, "projectId");
  }
  /**
   * Initialize project ID before any operations
   */
  before() {
    this.projectId = this.definition.project || import_gcp.default.getProject();
    if (!this.projectId) {
      throw new Error("GCP project ID not available. Set via definition.project or environment.");
    }
  }
  /**
   * Standard start implementation for GCP entities
   */
  start() {
    import_cli.default.output(`Starting GCP operations for: ${this.getEntityName()}`);
  }
  /**
   * Standard stop implementation for GCP entities
   */
  stop() {
    import_cli.default.output(`Stopping GCP operations for: ${this.getEntityName()}`);
  }
  /**
   * Make a GET request to a GCP API
   */
  get(url) {
    const response = import_gcp.default.get(url);
    return this.handleResponse(response, "GET", url);
  }
  /**
   * Make a POST request to a GCP API
   */
  post(url, body) {
    const options = body ? { body: JSON.stringify(body) } : void 0;
    const response = import_gcp.default.post(url, options);
    return this.handleResponse(response, "POST", url);
  }
  /**
   * Make a PUT request to a GCP API
   */
  put(url, body) {
    const options = body ? { body: JSON.stringify(body) } : void 0;
    const response = import_gcp.default.put(url, options);
    return this.handleResponse(response, "PUT", url);
  }
  /**
   * Make a DELETE request to a GCP API
   */
  httpDelete(url) {
    const response = import_gcp.default.delete(url);
    return this.handleResponse(response, "DELETE", url);
  }
  /**
   * Make a PATCH request to a GCP API
   */
  patch(url, body) {
    const options = { method: "PATCH" };
    if (body) {
      options.body = JSON.stringify(body);
    }
    const response = import_gcp.default.do(url, options);
    return this.handleResponse(response, "PATCH", url);
  }
  /**
   * Handle HTTP response, parsing JSON and throwing on errors
   */
  handleResponse(response, method, url) {
    if (response.error) {
      const errorMsg = parseGcpError(response);
      throw new Error(`GCP ${method} request to ${url} failed: ${errorMsg}`);
    }
    if (response.statusCode >= 400) {
      throw new Error(`GCP ${method} request to ${url} failed with status ${response.statusCode}: ${response.body}`);
    }
    if (!response.body || response.body === "") {
      return {};
    }
    try {
      return JSON.parse(response.body);
    } catch {
      return { raw: response.body };
    }
  }
  /**
   * Check if a resource exists by making a GET request (returns null if not found)
   */
  checkResourceExists(url) {
    try {
      const response = import_gcp.default.get(url);
      if (response.error || response.statusCode === 404) {
        return null;
      }
      if (response.statusCode >= 400) {
        return null;
      }
      return response.body ? JSON.parse(response.body) : null;
    } catch {
      return null;
    }
  }
  /**
   * Wait for a long-running operation to complete
   */
  waitForOperation(operationUrl, maxAttempts = 60, delayMs = 5e3) {
    let attempts = 0;
    while (attempts < maxAttempts) {
      try {
        const response = import_gcp.default.get(operationUrl);
        if (response.error) {
          throw new Error(parseGcpError(response));
        }
        const operation = JSON.parse(response.body);
        if (isOperationDone(operation)) {
          import_cli.default.output(`Operation completed successfully`);
          return operation;
        }
        if (isOperationFailed(operation)) {
          const errorMsg = operation.error?.message || "Unknown error";
          throw new Error(`Operation failed: ${errorMsg}`);
        }
        const statusInfo = operation.status || (operation.done === false ? "in progress" : "unknown");
        import_cli.default.output(`Waiting for operation to complete... (${statusInfo})`);
      } catch (error) {
        if (error instanceof Error && error.message.includes("Operation failed")) {
          throw error;
        }
      }
      attempts++;
      if (attempts < maxAttempts) {
        const start = Date.now();
        while (Date.now() - start < delayMs) {
        }
      }
    }
    throw new Error(`Operation did not complete within ${maxAttempts * delayMs / 1e3} seconds`);
  }
  /**
   * Delete a resource, respecting the existing flag
   */
  deleteResource(url, resourceName) {
    if (this.state.existing) {
      import_cli.default.output(`${resourceName} wasn't created by this entity, skipping delete`);
      return;
    }
    try {
      this.httpDelete(url);
      import_cli.default.output(`Successfully deleted ${resourceName}`);
    } catch (error) {
      throw new Error(`Failed to delete ${resourceName}: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
};
/**
 * Default readiness check configuration
 */
__publicField(GcpEntity, "readiness", { period: 10, initialDelay: 5, attempts: 60 });
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  GcpEntity
});
