
// Generated by MonkEC - targeting Goja runtime
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);

// input/gcp/cloudSqlUser.ts
const gcpBase = require("gcp/gcp-base");
const GcpEntity = gcpBase.GcpEntity;
const secret = require("secret");
const cli = require("cli");
const helpers = require("helpers");
const common = require("gcp/common");
const CLOUD_SQL_API_URL = common.CLOUD_SQL_API_URL;
var _CloudSqlUser = class _CloudSqlUser extends GcpEntity {
  getEntityName() {
    return `Cloud SQL User ${this.definition.name} on ${this.definition.instance}`;
  }
  /**
   * Get the API base URL for users
   */
  get apiUrl() {
    return `${CLOUD_SQL_API_URL}/projects/${this.projectId}/instances/${this.definition.instance}/users`;
  }
  /**
   * Get user details from API
   */
  getUser() {
    const host = this.definition.host || "%";
    const url = `${this.apiUrl}?name=${encodeURIComponent(this.definition.name)}&host=${encodeURIComponent(host)}`;
    try {
      const response = this.get(url);
      if (response.items) {
        for (const user of response.items) {
          if (user.name === this.definition.name) {
            return user;
          }
        }
      }
      return null;
    } catch {
      return null;
    }
  }
  /**
   * Get or generate password from secret
   */
  getOrGeneratePassword() {
    try {
      const password = secret.get(this.definition.password_secret);
      if (password) {
        return password;
      }
    } catch {
    }
    const newPassword = secret.randString(16);
    secret.set(this.definition.password_secret, newPassword);
    cli.output(`Generated new password and stored in secret: ${this.definition.password_secret}`);
    return newPassword;
  }
  create() {
    const existing = this.getUser();
    if (existing) {
      cli.output(`User ${this.definition.name} already exists on ${this.definition.instance}, adopting...`);
      this.state.existing = true;
      this.state.name = existing.name;
      this.state.host = existing.host;
      return;
    }
    const password = this.getOrGeneratePassword();
    const body = {
      name: this.definition.name,
      password
    };
    if (this.definition.host) {
      body.host = this.definition.host;
    }
    if (this.definition.user_type) {
      body.type = this.definition.user_type;
    }
    cli.output(`Creating user ${this.definition.name} on instance ${this.definition.instance}`);
    const maxRetries = 10;
    const retryDelayMs = 3e4;
    for (let attempt = 1; attempt <= maxRetries; attempt++) {
      try {
        const result = this.post(this.apiUrl, body);
        this.state.name = this.definition.name;
        this.state.host = this.definition.host;
        this.state.operation_name = result.name;
        this.state.existing = false;
        cli.output(`User creation started`);
        return;
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        if (errorMessage.includes("409")) {
          if (attempt < maxRetries) {
            cli.output(`\u23F3 Another operation is in progress on the instance. Retrying in ${retryDelayMs / 1e3}s... (attempt ${attempt}/${maxRetries})`);
            helpers.sleep(retryDelayMs);
            continue;
          }
        }
        throw error;
      }
    }
  }
  update() {
    const existing = this.getUser();
    if (!existing) {
      cli.output("User not found, creating...");
      this.create();
      return;
    }
    try {
      const password = secret.get(this.definition.password_secret);
      if (password) {
        const body = {
          password
        };
        const host = this.definition.host || "%";
        const url = `${this.apiUrl}?name=${encodeURIComponent(this.definition.name)}&host=${encodeURIComponent(host)}`;
        this.put(url, body);
        cli.output(`User ${this.definition.name} password updated`);
      }
    } catch {
      cli.output("No password update needed");
    }
    this.state.name = existing.name;
    this.state.host = existing.host;
  }
  delete() {
    if (this.state.existing) {
      cli.output(`User ${this.definition.name} was not created by this entity, skipping delete`);
      return;
    }
    const existing = this.getUser();
    if (!existing) {
      cli.output(`User ${this.definition.name} does not exist`);
      return;
    }
    const host = this.definition.host || "%";
    const url = `${this.apiUrl}?name=${encodeURIComponent(this.definition.name)}&host=${encodeURIComponent(host)}`;
    cli.output(`Deleting user ${this.definition.name} from instance ${this.definition.instance}`);
    this.httpDelete(url);
    try {
      secret.remove(this.definition.password_secret);
      cli.output(`Removed secret: ${this.definition.password_secret}`);
    } catch {
    }
    cli.output(`User ${this.definition.name} deleted`);
  }
  checkReadiness() {
    if (this.state.operation_name) {
      const operationUrl = `${CLOUD_SQL_API_URL}/projects/${this.projectId}/operations/${this.state.operation_name}`;
      try {
        const operation = this.get(operationUrl);
        if (operation.status === "DONE") {
          if (operation.error) {
            cli.output(`Operation failed: ${JSON.stringify(operation.error)}`);
            return false;
          }
          this.state.operation_name = void 0;
        } else {
          cli.output(`Operation status: ${operation.status}`);
          return false;
        }
      } catch (error) {
        cli.output(`Error checking operation: ${error}`);
        return false;
      }
    }
    const user = this.getUser();
    if (!user) {
      cli.output("User not found");
      return false;
    }
    this.state.name = user.name;
    this.state.host = user.host;
    cli.output(`User ${this.definition.name} is ready`);
    return true;
  }
  checkLiveness() {
    return this.getUser() !== null;
  }
};
__name(_CloudSqlUser, "CloudSqlUser");
__publicField(_CloudSqlUser, "readiness", { period: 5, initialDelay: 2, attempts: 20 });
var CloudSqlUser = _CloudSqlUser;



function main(def, state, ctx) {
  const entity = new CloudSqlUser(def, state, ctx);
  return entity.main(ctx);
}
