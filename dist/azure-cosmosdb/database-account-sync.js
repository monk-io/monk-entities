
// Generated by MonkEC - targeting Goja runtime
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __knownSymbol = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __decoratorStart = (base) => [, , , __create(base?.[__knownSymbol("metadata")] ?? null)];
var __decoratorStrings = ["class", "method", "getter", "setter", "accessor", "field", "value", "get", "set"];
var __expectFn = (fn) => fn !== void 0 && typeof fn !== "function" ? __typeError("Function expected") : fn;
var __decoratorContext = (kind, name, done, metadata, fns) => ({ kind: __decoratorStrings[kind], name, metadata, addInitializer: (fn) => done._ ? __typeError("Already initialized") : fns.push(__expectFn(fn || null)) });
var __decoratorMetadata = (array, target) => __defNormalProp(target, __knownSymbol("metadata"), array[3]);
var __runInitializers = (array, flags, self, value) => {
  for (var i = 0, fns = array[flags >> 1], n = fns && fns.length; i < n; i++) flags & 1 ? fns[i].call(self) : value = fns[i].call(self, value);
  return value;
};
var __decorateElement = (array, flags, name, decorators, target, extra) => {
  var fn, it, done, ctx, access, k = flags & 7, s = !!(flags & 8), p = !!(flags & 16);
  var j = k > 3 ? array.length + 1 : k ? s ? 1 : 2 : 0, key = __decoratorStrings[k + 5];
  var initializers = k > 3 && (array[j - 1] = []), extraInitializers = array[j] || (array[j] = []);
  var desc = k && (!p && !s && (target = target.prototype), k < 5 && (k > 3 || !p) && __getOwnPropDesc(k < 4 ? target : { get [name]() {
    return __privateGet(this, extra);
  }, set [name](x) {
    return __privateSet(this, extra, x);
  } }, name));
  k ? p && k < 4 && __name(extra, (k > 2 ? "set " : k > 1 ? "get " : "") + name) : __name(target, name);
  for (var i = decorators.length - 1; i >= 0; i--) {
    ctx = __decoratorContext(k, name, done = {}, array[3], extraInitializers);
    if (k) {
      ctx.static = s, ctx.private = p, access = ctx.access = { has: p ? (x) => __privateIn(target, x) : (x) => name in x };
      if (k ^ 3) access.get = p ? (x) => (k ^ 1 ? __privateGet : __privateMethod)(x, target, k ^ 4 ? extra : desc.get) : (x) => x[name];
      if (k > 2) access.set = p ? (x, y) => __privateSet(x, target, y, k ^ 4 ? extra : desc.set) : (x, y) => x[name] = y;
    }
    it = (0, decorators[i])(k ? k < 4 ? p ? extra : desc[key] : k > 4 ? void 0 : { get: desc.get, set: desc.set } : target, ctx), done._ = 1;
    if (k ^ 4 || it === void 0) __expectFn(it) && (k > 4 ? initializers.unshift(it) : k ? p ? extra = it : desc[key] = it : target = it);
    else if (typeof it !== "object" || it === null) __typeError("Object expected");
    else __expectFn(fn = it.get) && (desc.get = fn), __expectFn(fn = it.set) && (desc.set = fn), __expectFn(fn = it.init) && initializers.unshift(fn);
  }
  return k || __decoratorMetadata(array, target), desc && __defProp(target, name, desc), p ? k ^ 4 ? extra : desc : target;
};
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateIn = (member, obj) => Object(obj) !== obj ? __typeError('Cannot use the "in" operator on this value') : member.has(obj);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);

// input/azure-cosmosdb/databaseAccount.ts
const azureCosmosdbBase = require("azure-cosmosdb/azure-cosmosdb-base");
const AzureCosmosDBEntity = azureCosmosdbBase.AzureCosmosDBEntity;
const cli = require("cli");
const secret = require("secret");
const MonkecBase = require("monkec/base");
var action2 = MonkecBase.action;
var _restoreAccount_dec, _listRestorableContainers_dec, _listRestorableDatabases_dec, _listRestorableAccounts_dec, _getBackupInfo_dec, _a, _init;
var _DatabaseAccount = class _DatabaseAccount extends (_a = AzureCosmosDBEntity, _getBackupInfo_dec = [action2("get-backup-info")], _listRestorableAccounts_dec = [action2("list-restorable-accounts")], _listRestorableDatabases_dec = [action2("list-restorable-databases")], _listRestorableContainers_dec = [action2("list-restorable-containers")], _restoreAccount_dec = [action2("restore")], _a) {
  constructor() {
    super(...arguments);
    __runInitializers(_init, 5, this);
  }
  getEntityName() {
    return this.definition.account_name;
  }
  getResourceType() {
    return "databaseAccounts";
  }
  extractArrayFromIndexedFields(obj, fieldName) {
    if (obj && typeof obj === "object" && obj[fieldName] && Array.isArray(obj[fieldName])) {
      return obj[fieldName];
    }
    const result = [];
    let index = 0;
    while (obj && typeof obj === "object" && obj[`${fieldName}!${index}`] !== void 0) {
      let item = obj[`${fieldName}!${index}`];
      item = this.processNestedIndexedFields(item);
      result.push(item);
      index++;
    }
    return result.filter((item) => item != null);
  }
  processNestedIndexedFields(obj) {
    if (!obj || typeof obj !== "object") {
      return obj;
    }
    const processedObj = { ...obj };
    const indexedFields = /* @__PURE__ */ new Set();
    for (const key in processedObj) {
      const match = key.match(/^(.+)!(\d+)$/);
      if (match) {
        const [, fieldName] = match;
        indexedFields.add(fieldName);
      }
    }
    for (const fieldName of indexedFields) {
      const extractedArray = this.extractArrayFromIndexedFields(processedObj, fieldName);
      let index = 0;
      while (processedObj[`${fieldName}!${index}`] !== void 0) {
        delete processedObj[`${fieldName}!${index}`];
        index++;
      }
      if (extractedArray.length > 0) {
        processedObj[fieldName] = extractedArray;
      }
    }
    return processedObj;
  }
  /** Create a new Cosmos DB database account */
  create() {
    const locationsArray = this.extractArrayFromIndexedFields(this.definition, "locations");
    if (!locationsArray || locationsArray.length === 0) {
      throw new Error("At least one location must be specified for the Cosmos DB account");
    }
    const existingAccount = this.checkResourceExists(this.definition.account_name);
    if (existingAccount) {
      const properties2 = existingAccount.properties;
      const provisioningState = typeof properties2?.provisioningState === "string" ? properties2.provisioningState : void 0;
      this.state = {
        account_name: typeof existingAccount.name === "string" ? existingAccount.name : this.definition.account_name,
        provisioning_state: provisioningState,
        document_endpoint: typeof properties2?.documentEndpoint === "string" ? properties2.documentEndpoint : void 0,
        write_locations: Array.isArray(properties2?.writeLocations) ? properties2.writeLocations : void 0,
        read_locations: Array.isArray(properties2?.readLocations) ? properties2.readLocations : void 0,
        existing: true
      };
      cli.output(`\u2705 Database account ${this.definition.account_name} already exists`);
      if (provisioningState === "Succeeded") {
        cli.output(`\u{1F511} Existing account is ready, attempting to populate secrets...`);
        this.populateAccountSecrets();
        this.state.secrets_populated = true;
      }
      return;
    }
    if (this.definition.create_when_missing === false) {
      cli.output(`\u26A0\uFE0F  Database account ${this.definition.account_name} does not exist and create_when_missing is false`);
      this.state = { existing: false };
      return;
    }
    const body = {
      kind: this.definition.account_kind || "GlobalDocumentDB",
      location: this.definition.location || locationsArray[0]?.location_name || "East US",
      properties: {
        databaseAccountOfferType: this.definition.database_account_offer_type || "Standard",
        locations: locationsArray.map((loc) => ({
          locationName: loc.location_name,
          failoverPriority: loc.failover_priority,
          isZoneRedundant: loc.is_zone_redundant || false
        }))
      }
    };
    if (this.definition.consistency_policy) {
      const consistencyPolicy = {
        defaultConsistencyLevel: this.definition.consistency_policy.default_consistency_level
      };
      if (this.definition.consistency_policy.max_staleness_prefix !== void 0) {
        consistencyPolicy.maxStalenessPrefix = this.definition.consistency_policy.max_staleness_prefix;
      }
      if (this.definition.consistency_policy.max_interval_in_seconds !== void 0) {
        consistencyPolicy.maxIntervalInSeconds = this.definition.consistency_policy.max_interval_in_seconds;
      }
      body.properties.consistencyPolicy = consistencyPolicy;
    }
    if (this.definition.enable_automatic_failover !== void 0) {
      body.properties.enableAutomaticFailover = this.definition.enable_automatic_failover;
    }
    if (this.definition.enable_multiple_write_locations !== void 0) {
      body.properties.enableMultipleWriteLocations = this.definition.enable_multiple_write_locations;
    }
    if (this.definition.enable_analytical_storage !== void 0) {
      body.properties.enableAnalyticalStorage = this.definition.enable_analytical_storage;
    }
    if (this.definition.public_network_access !== void 0) {
      body.properties.publicNetworkAccess = this.definition.public_network_access;
    }
    if (this.definition.disable_local_auth !== void 0) {
      body.properties.disableLocalAuth = this.definition.disable_local_auth;
    }
    if (this.definition.tags) {
      body.tags = this.definition.tags;
    }
    if (this.definition.backup_policy) {
      if (this.definition.backup_policy.backup_type === "Continuous") {
        body.properties.backupPolicy = {
          type: "Continuous",
          continuousModeProperties: {
            tier: this.definition.backup_policy.continuous_tier || "Continuous7Days"
          }
        };
      } else {
        const periodicModeProperties = {
          backupIntervalInMinutes: this.definition.backup_policy.periodic_interval_minutes || 240,
          backupRetentionIntervalInHours: this.definition.backup_policy.periodic_retention_hours || 8
        };
        if (this.definition.backup_policy.backup_storage_redundancy) {
          periodicModeProperties.backupStorageRedundancy = this.definition.backup_policy.backup_storage_redundancy;
        }
        body.properties.backupPolicy = {
          type: "Periodic",
          periodicModeProperties
        };
      }
    }
    const path = this.buildResourcePath(this.definition.account_name);
    const response = this.makeAzureRequest("PUT", path, body);
    if (response.error) {
      throw new Error(`Failed to create database account: ${response.error}, body: ${response.body}`);
    }
    const responseData = this.parseResponseBody(response);
    const properties = responseData?.properties;
    this.state = {
      account_name: this.definition.account_name,
      provisioning_state: typeof properties?.provisioningState === "string" ? properties.provisioningState : void 0,
      document_endpoint: typeof properties?.documentEndpoint === "string" ? properties.documentEndpoint : void 0,
      write_locations: Array.isArray(properties?.writeLocations) ? properties.writeLocations : void 0,
      read_locations: Array.isArray(properties?.readLocations) ? properties.readLocations : void 0,
      existing: false
    };
    cli.output(`\u2705 Created Cosmos DB database account: ${this.definition.account_name}`);
  }
  update() {
    if (!this.state.account_name) {
      this.create();
      return;
    }
    const locationsArray = this.extractArrayFromIndexedFields(this.definition, "locations");
    const body = {
      location: this.definition.location || locationsArray[0]?.location_name || "East US",
      properties: {
        databaseAccountOfferType: this.definition.database_account_offer_type || "Standard"
      }
    };
    let hasChanges = false;
    if (this.definition.consistency_policy) {
      const consistencyPolicy = {
        defaultConsistencyLevel: this.definition.consistency_policy.default_consistency_level
      };
      if (this.definition.consistency_policy.max_staleness_prefix !== void 0) {
        consistencyPolicy.maxStalenessPrefix = this.definition.consistency_policy.max_staleness_prefix;
      }
      if (this.definition.consistency_policy.max_interval_in_seconds !== void 0) {
        consistencyPolicy.maxIntervalInSeconds = this.definition.consistency_policy.max_interval_in_seconds;
      }
      body.properties.consistencyPolicy = consistencyPolicy;
      hasChanges = true;
    }
    if (locationsArray && locationsArray.length > 0) {
      body.properties.locations = locationsArray.map((loc) => ({
        locationName: loc.location_name,
        failoverPriority: loc.failover_priority,
        isZoneRedundant: loc.is_zone_redundant || false
      }));
      hasChanges = true;
    }
    if (this.definition.enable_automatic_failover !== void 0) {
      body.properties.enableAutomaticFailover = this.definition.enable_automatic_failover;
      hasChanges = true;
    }
    if (this.definition.enable_multiple_write_locations !== void 0) {
      body.properties.enableMultipleWriteLocations = this.definition.enable_multiple_write_locations;
      hasChanges = true;
    }
    if (this.definition.public_network_access !== void 0) {
      body.properties.publicNetworkAccess = this.definition.public_network_access;
      hasChanges = true;
    }
    if (this.definition.disable_local_auth !== void 0) {
      body.properties.disableLocalAuth = this.definition.disable_local_auth;
      hasChanges = true;
    }
    if (this.definition.tags) {
      body.tags = this.definition.tags;
      hasChanges = true;
    }
    if (!hasChanges) {
      cli.output(`\u2139\uFE0F  No changes detected for database account: ${this.definition.account_name}`);
      return;
    }
    const path = this.buildResourcePath(this.definition.account_name);
    const response = this.makeAzureRequest("PATCH", path, body);
    if (response.error) {
      throw new Error(`Failed to update database account: ${response.error}, body: ${response.body}`);
    }
    const responseData = this.parseResponseBody(response);
    if (responseData) {
      const properties = responseData.properties;
      this.state.provisioning_state = typeof properties?.provisioningState === "string" ? properties.provisioningState : void 0;
      this.state.document_endpoint = typeof properties?.documentEndpoint === "string" ? properties.documentEndpoint : void 0;
      this.state.write_locations = Array.isArray(properties?.writeLocations) ? properties.writeLocations : void 0;
      this.state.read_locations = Array.isArray(properties?.readLocations) ? properties.readLocations : void 0;
    }
    cli.output(`\u2705 Updated Cosmos DB database account: ${this.definition.account_name}`);
  }
  delete() {
    if (!this.state.account_name) {
      cli.output("Database account does not exist, nothing to delete");
      return;
    }
    this.deleteResource(this.definition.account_name);
  }
  checkReadiness() {
    if (!this.state.account_name) {
      return false;
    }
    if (this.definition.create_when_missing === false && !this.state.existing) {
      return true;
    }
    try {
      const account = this.checkResourceExists(this.definition.account_name);
      if (!account) {
        cli.output(`\u23F3 Database account ${this.definition.account_name} not found`);
        return false;
      }
      const properties = account.properties;
      const provisioningState = typeof properties?.provisioningState === "string" ? properties.provisioningState : void 0;
      const isReady = provisioningState === "Succeeded";
      if (isReady) {
        cli.output(`\u2705 Database account ${this.definition.account_name} is ready (status: ${provisioningState})`);
        this.state.provisioning_state = provisioningState;
        this.state.document_endpoint = typeof properties?.documentEndpoint === "string" ? properties.documentEndpoint : void 0;
        this.state.write_locations = Array.isArray(properties?.writeLocations) ? properties.writeLocations : void 0;
        this.state.read_locations = Array.isArray(properties?.readLocations) ? properties.readLocations : void 0;
        if (!this.state.secrets_populated) {
          cli.output(`\u{1F511} Account is ready, attempting to populate secrets...`);
          this.populateAccountSecrets();
          this.state.secrets_populated = true;
        }
      } else {
        cli.output(`\u23F3 Database account ${this.definition.account_name} not ready yet (status: ${provisioningState || "unknown"})`);
      }
      return isReady;
    } catch (error) {
      cli.output(`\u26A0\uFE0F  Failed to check database account readiness: ${error instanceof Error ? error.message : "Unknown error"}`);
      return false;
    }
  }
  checkLiveness() {
    return this.checkReadiness();
  }
  /**
   * Populate secrets with account credentials if secret references are provided
   */
  populateAccountSecrets() {
    if (!this.definition.primary_key_secret_ref && !this.definition.secondary_key_secret_ref) {
      return;
    }
    if (this.definition.primary_key_secret_ref || this.definition.secondary_key_secret_ref) {
      try {
        const keysPath = `/subscriptions/${this.definition.subscription_id}/resourceGroups/${this.definition.resource_group_name}/providers/Microsoft.DocumentDB/databaseAccounts/${this.definition.account_name}/listKeys?api-version=${this.apiVersion}`;
        const keysResponse = this.makeAzureRequest("POST", keysPath);
        if (keysResponse.error) {
          cli.output(`\u26A0\uFE0F  Failed to retrieve access keys: ${keysResponse.error}`);
          return;
        }
        const keysData = this.parseResponseBody(keysResponse);
        if (keysData) {
          if (this.definition.primary_key_secret_ref && typeof keysData.primaryMasterKey === "string") {
            try {
              secret.set(this.definition.primary_key_secret_ref, keysData.primaryMasterKey);
              cli.output(`\u{1F511} Saved primary key to secret: ${this.definition.primary_key_secret_ref}`);
            } catch (error) {
              cli.output(`\u26A0\uFE0F  Failed to save primary key to secret: ${this.definition.primary_key_secret_ref}`);
            }
          }
          if (this.definition.secondary_key_secret_ref && typeof keysData.secondaryMasterKey === "string") {
            try {
              secret.set(this.definition.secondary_key_secret_ref, keysData.secondaryMasterKey);
              cli.output(`\u{1F511} Saved secondary key to secret: ${this.definition.secondary_key_secret_ref}`);
            } catch (error) {
              cli.output(`\u26A0\uFE0F  Failed to save secondary key to secret: ${this.definition.secondary_key_secret_ref}`);
            }
          }
        } else {
          cli.output(`\u26A0\uFE0F  No keys data received from Azure API`);
        }
      } catch (error) {
        cli.output(`\u26A0\uFE0F  Failed to fetch access keys from Azure: ${error instanceof Error ? error.message : "Unknown error"}`);
      }
    }
  }
  getBackupInfo(_args) {
    cli.output(`==================================================`);
    cli.output(`\u{1F4E6} Backup Information for: ${this.definition.account_name}`);
    cli.output(`==================================================`);
    if (!this.state.account_name) {
      throw new Error("Account does not exist. Create the account first.");
    }
    try {
      const account = this.checkResourceExists(this.definition.account_name);
      if (!account) {
        throw new Error(`Account ${this.definition.account_name} not found`);
      }
      const properties = account.properties;
      const backupPolicy = properties?.backupPolicy;
      if (!backupPolicy) {
        cli.output(`
\u26A0\uFE0F  No backup policy information available`);
        cli.output(`==================================================`);
        return;
      }
      const backupType = backupPolicy.type;
      cli.output(`
\u{1F527} Backup Policy Type: ${backupType}`);
      if (backupType === "Continuous") {
        const continuousProps = backupPolicy.continuousModeProperties;
        const tier = continuousProps?.tier || "Unknown";
        cli.output(`   Tier: ${tier}`);
        this.state.backup_policy_type = "Continuous";
        this.state.continuous_backup_tier = String(tier);
        this.fetchRestorableAccountInfo();
      } else if (backupType === "Periodic") {
        const periodicProps = backupPolicy.periodicModeProperties;
        cli.output(`   Backup Interval: ${periodicProps?.backupIntervalInMinutes || 240} minutes`);
        cli.output(`   Backup Retention: ${periodicProps?.backupRetentionIntervalInHours || 8} hours`);
        cli.output(`   Storage Redundancy: ${periodicProps?.backupStorageRedundancy || "Geo"}`);
        cli.output(`
\u26A0\uFE0F  Note: Periodic backup restore requires Azure Support ticket`);
        this.state.backup_policy_type = "Periodic";
      }
      cli.output(`
==================================================`);
    } catch (error) {
      cli.output(`
\u274C Failed to get backup info`);
      throw new Error(`Get backup info failed: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  /**
   * Fetch restorable account info and update state with instance ID and earliest restore time
   */
  fetchRestorableAccountInfo() {
    try {
      const path = `/subscriptions/${this.definition.subscription_id}/providers/Microsoft.DocumentDB/restorableDatabaseAccounts?api-version=${this.apiVersion}`;
      const response = this.makeAzureRequest("GET", path);
      if (response.error) {
        cli.output(`\u26A0\uFE0F  Could not fetch restorable account info: ${response.error}`);
        return;
      }
      const data = this.parseResponseBody(response);
      const accounts = data?.value;
      if (!accounts || accounts.length === 0) {
        cli.output(`   No restorable accounts found`);
        return;
      }
      for (const acc of accounts) {
        const account = acc;
        const accName = account.name;
        const props = account.properties;
        const accountName = props?.accountName;
        if (accountName === this.definition.account_name) {
          this.state.restorable_instance_id = accName;
          const oldestTime = props?.oldestRestorableTime;
          if (oldestTime) {
            this.state.earliest_restore_time = oldestTime;
            cli.output(`   Restorable Instance ID: ${accName}`);
            cli.output(`   Earliest Restore Time: ${oldestTime}`);
          }
          const location = account.location;
          if (location) {
            cli.output(`   Location: ${location}`);
          }
          return;
        }
      }
      cli.output(`   Account not found in restorable accounts list`);
    } catch (error) {
      cli.output(`\u26A0\uFE0F  Error fetching restorable account info: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  listRestorableAccounts(args) {
    cli.output(`==================================================`);
    cli.output(`\u{1F4CB} Restorable Database Accounts`);
    cli.output(`Subscription: ${this.definition.subscription_id}`);
    cli.output(`==================================================`);
    try {
      let path;
      const location = args?.location;
      if (location) {
        const encodedLocation = location.replace(/ /g, "%20");
        path = `/subscriptions/${this.definition.subscription_id}/providers/Microsoft.DocumentDB/locations/${encodedLocation}/restorableDatabaseAccounts?api-version=${this.apiVersion}`;
        cli.output(`Filter: Location = ${location}
`);
      } else {
        path = `/subscriptions/${this.definition.subscription_id}/providers/Microsoft.DocumentDB/restorableDatabaseAccounts?api-version=${this.apiVersion}`;
      }
      const response = this.makeAzureRequest("GET", path);
      if (response.error) {
        throw new Error(`API error: ${response.error}, body: ${response.body}`);
      }
      const data = this.parseResponseBody(response);
      const accounts = data?.value;
      if (!accounts || accounts.length === 0) {
        cli.output(`
No restorable accounts found.`);
        cli.output(`
Note: Only accounts with Continuous backup mode appear here.`);
        cli.output(`==================================================`);
        return;
      }
      cli.output(`
Found ${accounts.length} restorable account(s):
`);
      for (let i = 0; i < accounts.length; i++) {
        const account = accounts[i];
        const props = account.properties;
        cli.output(`\u{1F4C1} Account #${i + 1}`);
        cli.output(`   Instance ID: ${account.name}`);
        cli.output(`   Account Name: ${props?.accountName || "N/A"}`);
        cli.output(`   Location: ${account.location || "N/A"}`);
        cli.output(`   API Type: ${props?.apiType || "N/A"}`);
        cli.output(`   Oldest Restorable Time: ${props?.oldestRestorableTime || "N/A"}`);
        cli.output(`   Creation Time: ${props?.creationTime || "N/A"}`);
        if (props?.deletionTime) {
          cli.output(`   \u26A0\uFE0F  Deletion Time: ${props.deletionTime} (deleted account)`);
        }
        cli.output(``);
      }
      cli.output(`==================================================`);
      cli.output(`
\u{1F4A1} Use the Instance ID as 'source_id' with 'list-restorable-databases' action`);
      cli.output(`   to see which databases can be restored.`);
    } catch (error) {
      cli.output(`
\u274C Failed to list restorable accounts`);
      throw new Error(`List restorable accounts failed: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  listRestorableDatabases(args) {
    cli.output(`==================================================`);
    cli.output(`\u{1F4CB} Restorable Databases`);
    cli.output(`==================================================`);
    const instanceId = args?.source_id || args?.instance_id;
    const location = args?.location;
    if (!instanceId) {
      throw new Error(
        `Required argument 'source_id' not provided.
Usage: monk do namespace/account list-restorable-databases source_id="xxx" location="East US"

To find source IDs, run: monk do namespace/account list-restorable-accounts`
      );
    }
    if (!location) {
      throw new Error(
        `Required argument 'location' not provided.
Usage: monk do namespace/account list-restorable-databases source_id="xxx" location="East US"`
      );
    }
    try {
      const encodedLocation = location.replace(/ /g, "%20");
      const path = `/subscriptions/${this.definition.subscription_id}/providers/Microsoft.DocumentDB/locations/${encodedLocation}/restorableDatabaseAccounts/${instanceId}/restorableSqlDatabases?api-version=${this.apiVersion}`;
      cli.output(`Source ID: ${instanceId}`);
      cli.output(`Location: ${location}
`);
      const response = this.makeAzureRequest("GET", path);
      if (response.error) {
        throw new Error(`API error: ${response.error}, body: ${response.body}`);
      }
      const data = this.parseResponseBody(response);
      const databases = data?.value;
      if (!databases || databases.length === 0) {
        cli.output(`
No restorable databases found for this account.`);
        cli.output(`==================================================`);
        return;
      }
      cli.output(`Found ${databases.length} restorable database(s):
`);
      for (let i = 0; i < databases.length; i++) {
        const db = databases[i];
        const props = db.properties;
        const resource = props?.resource;
        cli.output(`\u{1F4C2} Database #${i + 1}`);
        cli.output(`   Database Name: ${resource?.ownerId || "N/A"}`);
        cli.output(`   Resource ID (rid): ${resource?._rid || "N/A"}`);
        cli.output(`   Operation Type: ${resource?.operationType || "N/A"}`);
        cli.output(`   Event Timestamp: ${resource?.eventTimestamp || "N/A"}`);
        cli.output(``);
      }
      cli.output(`==================================================`);
      cli.output(`
\u{1F4A1} Use 'list-restorable-containers' to see containers in each database`);
    } catch (error) {
      cli.output(`
\u274C Failed to list restorable databases`);
      throw new Error(`List restorable databases failed: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  listRestorableContainers(args) {
    cli.output(`==================================================`);
    cli.output(`\u{1F4CB} Restorable Containers`);
    cli.output(`==================================================`);
    const instanceId = args?.source_id || args?.instance_id;
    const location = args?.location;
    const databaseRid = args?.database_rid;
    if (!instanceId || !location) {
      throw new Error(
        `Required arguments 'source_id' and 'location' not provided.
Usage: monk do namespace/account list-restorable-containers source_id="xxx" location="East US" database_rid="xxx"`
      );
    }
    try {
      const encodedLocation = location.replace(/ /g, "%20");
      let path = `/subscriptions/${this.definition.subscription_id}/providers/Microsoft.DocumentDB/locations/${encodedLocation}/restorableDatabaseAccounts/${instanceId}/restorableSqlContainers?api-version=${this.apiVersion}`;
      if (databaseRid) {
        path += `&restorableSqlDatabaseRid=${databaseRid}`;
        cli.output(`Database RID filter: ${databaseRid}`);
      }
      cli.output(`Source ID: ${instanceId}`);
      cli.output(`Location: ${location}
`);
      const response = this.makeAzureRequest("GET", path);
      if (response.error) {
        throw new Error(`API error: ${response.error}, body: ${response.body}`);
      }
      const data = this.parseResponseBody(response);
      const containers = data?.value;
      if (!containers || containers.length === 0) {
        cli.output(`
No restorable containers found.`);
        cli.output(`==================================================`);
        return;
      }
      cli.output(`Found ${containers.length} restorable container(s):
`);
      for (let i = 0; i < containers.length; i++) {
        const container = containers[i];
        const props = container.properties;
        const resource = props?.resource;
        cli.output(`\u{1F4C4} Container #${i + 1}`);
        cli.output(`   Container Name: ${resource?.ownerId || "N/A"}`);
        cli.output(`   Resource ID (rid): ${resource?._rid || "N/A"}`);
        cli.output(`   Operation Type: ${resource?.operationType || "N/A"}`);
        cli.output(`   Event Timestamp: ${resource?.eventTimestamp || "N/A"}`);
        cli.output(``);
      }
      cli.output(`==================================================`);
    } catch (error) {
      cli.output(`
\u274C Failed to list restorable containers`);
      throw new Error(`List restorable containers failed: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  restoreAccount(args) {
    cli.output(`==================================================`);
    cli.output(`\u{1F504} RESTORE OPERATION`);
    cli.output(`==================================================`);
    const targetAccountName = args?.target_id || args?.target_account_name;
    const instanceId = args?.source_id || args?.instance_id;
    const location = args?.location;
    const restoreTimestamp = args?.restore_timestamp;
    if (!targetAccountName) {
      throw new Error(
        `Required argument 'target_id' not provided.
This is the name for the NEW account that will be created with restored data.

Usage: monk do namespace/account restore target_id="restored-cosmos" source_id="xxx" location="East US" restore_timestamp="2024-12-01T10:00:00Z"`
      );
    }
    if (!instanceId) {
      throw new Error(
        "Required argument 'source_id' not provided.\nGet the source ID by running: monk do namespace/account list-restorable-accounts"
      );
    }
    if (!location) {
      throw new Error(
        `Required argument 'location' not provided.
Specify the Azure region for the restored account (e.g., location="East US")`
      );
    }
    if (!restoreTimestamp) {
      throw new Error(
        `Required argument 'restore_timestamp' not provided.
Specify the point-in-time to restore to in ISO 8601 format (e.g., restore_timestamp="2024-12-01T10:00:00Z")`
      );
    }
    const targetResourceGroup = args?.target_resource_group || this.definition.resource_group_name;
    const databasesToRestore = args?.databases_to_restore;
    cli.output(`
\u26A0\uFE0F  This will create a NEW Cosmos DB account with restored data.`);
    cli.output(`   The original account will NOT be modified.
`);
    cli.output(`   Target Account Name: ${targetAccountName}`);
    cli.output(`   Target Resource Group: ${targetResourceGroup}`);
    cli.output(`   Source ID: ${instanceId}`);
    cli.output(`   Location: ${location}`);
    cli.output(`   Restore Timestamp: ${restoreTimestamp}`);
    try {
      const encodedLocation = location.replace(/ /g, "");
      const restoreSource = `/subscriptions/${this.definition.subscription_id}/providers/Microsoft.DocumentDB/locations/${encodedLocation}/restorableDatabaseAccounts/${instanceId}`;
      const restoreParameters = {
        restoreMode: "PointInTime",
        restoreSource,
        restoreTimestampInUtc: restoreTimestamp
      };
      if (databasesToRestore) {
        try {
          const dbList = JSON.parse(databasesToRestore);
          if (Array.isArray(dbList) && dbList.length > 0) {
            restoreParameters.databasesToRestore = dbList.map((db) => ({
              databaseName: db.database_name,
              collectionNames: db.container_names || []
            }));
            cli.output(`   Databases to restore: ${dbList.map((d) => d.database_name).join(", ")}`);
          }
        } catch (parseError) {
          cli.output(`\u26A0\uFE0F  Could not parse databases_to_restore, restoring all databases`);
        }
      } else {
        cli.output(`   Restoring: All databases and containers`);
      }
      const body = {
        location,
        properties: {
          createMode: "Restore",
          databaseAccountOfferType: "Standard",
          locations: [{
            locationName: location,
            failoverPriority: 0
          }],
          restoreParameters
        }
      };
      cli.output(`
\u{1F680} Initiating restore operation...`);
      cli.output(`==================================================`);
      const path = `/subscriptions/${this.definition.subscription_id}/resourceGroups/${targetResourceGroup}/providers/Microsoft.DocumentDB/databaseAccounts/${targetAccountName}?api-version=${this.apiVersion}`;
      const response = this.makeAzureRequest("PUT", path, body);
      if (response.error) {
        throw new Error(`Restore failed: ${response.error}, body: ${response.body}`);
      }
      const responseData = this.parseResponseBody(response);
      const properties = responseData?.properties;
      const provisioningState = properties?.provisioningState;
      cli.output(`
\u2705 Restore operation initiated successfully!`);
      cli.output(`   New Account Name: ${targetAccountName}`);
      cli.output(`   Provisioning State: ${provisioningState || "Creating"}`);
      cli.output(`
\u23F3 Restore may take several minutes to hours depending on data size.`);
      cli.output(`   Monitor progress in Azure Portal or use Azure CLI:`);
      cli.output(`   az cosmosdb show --name ${targetAccountName} --resource-group ${targetResourceGroup}`);
      cli.output(`
==================================================`);
    } catch (error) {
      cli.output(`
\u274C Restore operation failed`);
      throw new Error(`Restore failed: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
};
_init = __decoratorStart(_a);
__decorateElement(_init, 1, "getBackupInfo", _getBackupInfo_dec, _DatabaseAccount);
__decorateElement(_init, 1, "listRestorableAccounts", _listRestorableAccounts_dec, _DatabaseAccount);
__decorateElement(_init, 1, "listRestorableDatabases", _listRestorableDatabases_dec, _DatabaseAccount);
__decorateElement(_init, 1, "listRestorableContainers", _listRestorableContainers_dec, _DatabaseAccount);
__decorateElement(_init, 1, "restoreAccount", _restoreAccount_dec, _DatabaseAccount);
__decoratorMetadata(_init, _DatabaseAccount);
__name(_DatabaseAccount, "DatabaseAccount");
var DatabaseAccount = _DatabaseAccount;



function main(def, state, ctx) {
  const entity = new DatabaseAccount(def, state, ctx);
  return entity.main(ctx);
}
