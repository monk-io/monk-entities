
// Generated by MonkEC - targeting Goja runtime
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);

// input/azure-cosmosdb/accessList.ts
const azureCosmosdbBase = require("azure-cosmosdb/azure-cosmosdb-base");
const AzureCosmosDBEntity = azureCosmosdbBase.AzureCosmosDBEntity;
const cli = require("cli");
var _AccessList = class _AccessList extends AzureCosmosDBEntity {
  getEntityName() {
    return this.definition.account_name;
  }
  getResourceType() {
    return "databaseAccounts";
  }
  /**
   * Extract array from indexed fields (e.g., field!0, field!1, etc.)
   */
  extractArrayFromIndexedFields(fieldName) {
    const result = [];
    let index = 0;
    while (this.definition[`${fieldName}!${index}`] !== void 0) {
      result.push(this.definition[`${fieldName}!${index}`]);
      index++;
    }
    return result;
  }
  create() {
    cli.output(`\u{1F512} Configuring Virtual Network access for Cosmos DB account: ${this.definition.account_name}`);
    const accountPath = this.buildResourcePath(this.definition.account_name);
    const accountResponse = this.makeAzureRequest("GET", accountPath);
    if (accountResponse.error) {
      throw new Error(`Cosmos DB account ${this.definition.account_name} not found: ${accountResponse.error}`);
    }
    const accountData = this.parseResponseBody(accountResponse);
    if (!accountData) {
      throw new Error(`Failed to retrieve Cosmos DB account ${this.definition.account_name}`);
    }
    this.configureNetworkAccess();
    const vnetRules = this.extractArrayFromIndexedFields("virtual_network_rules");
    const ipRules = this.extractArrayFromIndexedFields("ip_rules");
    this.state = {
      account_name: this.definition.account_name,
      vnet_rules_count: vnetRules.length,
      configured_subnet_ids: vnetRules.map((rule) => rule.subnet_id),
      ip_rules_count: ipRules.length,
      configured_ip_ranges: ipRules.map((rule) => rule.ip_address_or_range)
    };
    cli.output(`\u2705 Network access configured for ${this.definition.account_name} (${vnetRules.length} VNet rules, ${ipRules.length} IP rules)`);
  }
  start() {
  }
  stop() {
  }
  update() {
    cli.output(`\u{1F504} Updating network access for Cosmos DB account: ${this.definition.account_name}`);
    this.configureNetworkAccess();
    const vnetRules = this.extractArrayFromIndexedFields("virtual_network_rules");
    const ipRules = this.extractArrayFromIndexedFields("ip_rules");
    this.state.vnet_rules_count = vnetRules.length;
    this.state.configured_subnet_ids = vnetRules.map((rule) => rule.subnet_id);
    this.state.ip_rules_count = ipRules.length;
    this.state.configured_ip_ranges = ipRules.map((rule) => rule.ip_address_or_range);
    cli.output(`\u2705 Network access updated for ${this.definition.account_name} (${vnetRules.length} VNet rules, ${ipRules.length} IP rules)`);
  }
  delete() {
    cli.output(`\u{1F5D1}\uFE0F  Removing network access configuration for: ${this.definition.account_name}`);
    try {
      const accountPath = this.buildResourcePath(this.definition.account_name);
      const getResponse = this.makeAzureRequest("GET", accountPath);
      const accountData = this.parseResponseBody(getResponse);
      const properties = accountData?.properties;
      const location = accountData?.location || "eastus";
      const databaseAccountOfferType = properties?.databaseAccountOfferType || "Standard";
      const locations = properties?.locations;
      const body = {
        location,
        properties: {
          databaseAccountOfferType,
          locations,
          isVirtualNetworkFilterEnabled: false,
          virtualNetworkRules: [],
          ipRules: []
        }
      };
      const response = this.makeAzureRequest("PATCH", accountPath, body);
      if (response.error) {
        cli.output(`\u26A0\uFE0F  Warning: Failed to remove network rules: ${response.error}`);
      } else {
        cli.output(`\u2705 Network access configuration removed`);
      }
    } catch (error) {
      cli.output(`\u26A0\uFE0F  Warning: Failed to clean up network rules: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  /**
   * Configure network access by enabling service endpoints and updating account rules (VNet + IP firewall)
   */
  configureNetworkAccess() {
    const vnetRules = this.extractArrayFromIndexedFields("virtual_network_rules");
    const ipRules = this.extractArrayFromIndexedFields("ip_rules");
    if (vnetRules.length === 0 && ipRules.length === 0) {
      cli.output(`\u26A0\uFE0F  No network rules specified (neither VNet nor IP rules)`);
      return;
    }
    if (vnetRules.length > 0) {
      cli.output(`\u{1F527} Enabling service endpoints on ${vnetRules.length} subnet(s)...`);
      for (const rule of vnetRules) {
        this.enableServiceEndpointOnSubnet(rule.subnet_id);
      }
    }
    cli.output(`\u{1F527} Configuring network access rules...`);
    this.updateCosmosDBNetworkRules(vnetRules, ipRules);
  }
  /**
   * Enable Microsoft.AzureCosmosDB service endpoint on a subnet
   */
  enableServiceEndpointOnSubnet(subnetId) {
    try {
      cli.output(`  \u{1F4CD} Enabling service endpoint for subnet: ${this.extractSubnetName(subnetId)}`);
      const networkApiVersion = "2023-11-01";
      const subnetUrl = `${subnetId}?api-version=${networkApiVersion}`;
      const getResponse = this.makeAzureRequest("GET", subnetUrl);
      if (getResponse.error) {
        throw new Error(`Failed to get subnet: ${getResponse.error}`);
      }
      const subnetData = this.parseResponseBody(getResponse);
      if (!subnetData || !subnetData.properties) {
        throw new Error(`Invalid subnet data received`);
      }
      const properties = subnetData.properties;
      const currentEndpoints = properties.serviceEndpoints || [];
      const hasCosmosEndpoint = currentEndpoints.some((endpoint) => {
        if (endpoint && typeof endpoint === "object") {
          const ep = endpoint;
          return ep.service === "Microsoft.AzureCosmosDB";
        }
        return false;
      });
      if (hasCosmosEndpoint) {
        cli.output(`    \u2705 Service endpoint already enabled`);
        return;
      }
      const updatedEndpoints = [
        ...currentEndpoints,
        { service: "Microsoft.AzureCosmosDB" }
      ];
      const updateBody = {
        properties: {
          ...properties,
          serviceEndpoints: updatedEndpoints
        }
      };
      const subnetUrlWithVersion = `${subnetId}?api-version=${networkApiVersion}`;
      const updateResponse = this.makeAzureRequest("PUT", subnetUrlWithVersion, updateBody);
      if (updateResponse.error) {
        throw new Error(`Failed to update subnet: ${updateResponse.error}`);
      }
      cli.output(`    \u2705 Service endpoint enabled successfully`);
    } catch (error) {
      cli.output(`    \u26A0\uFE0F  Warning: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  /**
   * Update Cosmos DB account with network rules (VNet + IP firewall)
   */
  updateCosmosDBNetworkRules(vnetRules, ipRules) {
    const accountPath = this.buildResourcePath(this.definition.account_name);
    const getResponse = this.makeAzureRequest("GET", accountPath);
    if (getResponse.error) {
      throw new Error(`Failed to get account: ${getResponse.error}`);
    }
    const accountData = this.parseResponseBody(getResponse);
    if (!accountData || !accountData.properties) {
      throw new Error(`Invalid account data received`);
    }
    const properties = accountData.properties;
    const location = accountData.location || this.getLocationFromAccountData(accountData);
    const virtualNetworkRules = vnetRules.map((rule) => ({
      id: rule.subnet_id,
      ignoreMissingVNetServiceEndpoint: rule.ignore_missing_vnet_service_endpoint || false
    }));
    const ipFirewallRules = ipRules.map((rule) => ({
      ipAddressOrRange: rule.ip_address_or_range
    }));
    const currentVnetRules = properties.virtualNetworkRules || [];
    const currentIpRules = properties.ipRules || [];
    const existingSubnetIds = new Set(
      currentVnetRules.map((rule) => rule.id).filter((id) => typeof id === "string")
    );
    const newVnetRules = virtualNetworkRules.filter((rule) => !existingSubnetIds.has(rule.id));
    const allVnetRules = [...currentVnetRules, ...newVnetRules];
    const existingIpRanges = new Set(
      currentIpRules.map((rule) => rule.ipAddressOrRange).filter((ip) => typeof ip === "string")
    );
    const newIpRules = ipFirewallRules.filter((rule) => !existingIpRanges.has(rule.ipAddressOrRange));
    const allIpRules = [...currentIpRules, ...newIpRules];
    const databaseAccountOfferType = properties.databaseAccountOfferType || "Standard";
    const locations = properties.locations;
    const updateBody = {
      location,
      properties: {
        databaseAccountOfferType,
        locations,
        isVirtualNetworkFilterEnabled: this.definition.enable_virtual_network_filter !== false,
        virtualNetworkRules: allVnetRules,
        ipRules: allIpRules
      }
    };
    const updateResponse = this.makeAzureRequest("PATCH", accountPath, updateBody);
    if (updateResponse.error) {
      throw new Error(`Failed to update Cosmos DB account: ${updateResponse.error}`);
    }
    cli.output(`\u2705 Added ${vnetRules.length} VNet rule(s) and ${ipRules.length} IP rule(s) to Cosmos DB account`);
  }
  /**
   * Extract location from account data
   */
  getLocationFromAccountData(accountData) {
    const locations = accountData.properties;
    if (locations && Array.isArray(locations.locations) && locations.locations.length > 0) {
      const firstLocation = locations.locations[0];
      if (firstLocation.locationName && typeof firstLocation.locationName === "string") {
        return firstLocation.locationName;
      }
    }
    return "eastus";
  }
  /**
   * Extract subnet name from subnet ID for logging
   */
  extractSubnetName(subnetId) {
    const parts = subnetId.split("/");
    return parts[parts.length - 1] || subnetId;
  }
};
__name(_AccessList, "AccessList");
__publicField(_AccessList, "readiness", { period: 5, initialDelay: 2, attempts: 30 });
var AccessList = _AccessList;



function main(def, state, ctx) {
  const entity = new AccessList(def, state, ctx);
  return entity.main(ctx);
}
