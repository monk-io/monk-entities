
// Generated by MonkEC - targeting Goja runtime
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined") return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);

// input/azure-cosmosdb/database.ts
const azureCosmosdbBase = require("azure-cosmosdb/azure-cosmosdb-base");
const AzureCosmosDBEntity = azureCosmosdbBase.AzureCosmosDBEntity;
const cli = require("cli");
const http = require("http");
const crypto = require("crypto");
var _azure = __require("cloud/azure");
var _Database = class _Database extends AzureCosmosDBEntity {
  constructor() {
    super(...arguments);
    __publicField(this, "_masterKey");
  }
  getEntityName() {
    return this.definition.database_id;
  }
  getResourceType() {
    return "dbs";
  }
  /**
   * Build the Cosmos DB data plane endpoint
   */
  buildDataPlaneEndpoint() {
    return `https://${this.definition.database_account_name}.documents.azure.com`;
  }
  /**
   * Get the master key for the Cosmos DB account
   */
  getMasterKey() {
    if (this._masterKey) {
      return this._masterKey;
    }
    const keysPath = `/subscriptions/${this.definition.subscription_id}/resourceGroups/${this.definition.resource_group_name}/providers/Microsoft.DocumentDB/databaseAccounts/${this.definition.database_account_name}/listKeys?api-version=${this.apiVersion}`;
    try {
      const response = this.makeAzureRequest("POST", keysPath);
      if (response.statusCode !== 200) {
        throw new Error(`Failed to retrieve master key: ${response.statusCode} - ${response.error || response.body}`);
      }
      const responseData = this.parseResponseBody(response);
      if (!responseData || typeof responseData !== "object") {
        throw new Error("Invalid response from listKeys API");
      }
      const keysData = responseData;
      const primaryMasterKey = keysData.primaryMasterKey;
      if (typeof primaryMasterKey !== "string") {
        throw new Error("Primary master key not found in response");
      }
      this._masterKey = primaryMasterKey;
      return this._masterKey;
    } catch (error) {
      throw new Error(`Failed to retrieve Cosmos DB master key: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  /**
   * Generate authorization signature for Cosmos DB Data Plane API
   * Implements the Azure Cosmos DB REST API authentication as per:
   * https://docs.microsoft.com/en-us/rest/api/cosmos-db/access-control-on-cosmosdb-resources
   */
  generateAuthorizationSignature(verb, resourceType, resourceLink, date) {
    const masterKey = this.getMasterKey();
    const stringToSign = (verb || "").toLowerCase() + "\n" + (resourceType || "").toLowerCase() + "\n" + (resourceLink || "") + "\n" + date.toLowerCase() + "\n\n";
    const hmacHash = crypto.hmac(masterKey, stringToSign);
    const signature = this.hexToBase64Fixed(hmacHash);
    const masterToken = "master";
    const tokenVersion = "1.0";
    const authString = "type=" + masterToken + "&ver=" + tokenVersion + "&sig=" + signature;
    return encodeURIComponent(authString).replace(/%[0-9A-F]{2}/g, (match) => match.toLowerCase());
  }
  /**
   * Convert hex string directly to base64 (FIXED - proper byte handling)
   */
  hexToBase64Fixed(hex) {
    const base64Chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    let result = "";
    for (let i = 0; i < hex.length; i += 6) {
      let bytes = "";
      for (let j = 0; j < 6 && i + j < hex.length; j += 2) {
        const byte = parseInt(hex.substr(i + j, 2), 16);
        bytes += String.fromCharCode(byte & 255);
      }
      while (bytes.length < 3) {
        bytes += "\0";
      }
      const b1 = bytes.charCodeAt(0);
      const b2 = bytes.charCodeAt(1);
      const b3 = bytes.charCodeAt(2);
      result += base64Chars[b1 >> 2 & 63];
      result += base64Chars[(b1 & 3) << 4 | b2 >> 4 & 15];
      result += base64Chars[(b2 & 15) << 2 | b3 >> 6 & 3];
      result += base64Chars[b3 & 63];
    }
    const padding = hex.length % 6;
    if (padding === 2) {
      result = result.substr(0, result.length - 2) + "==";
    } else if (padding === 4) {
      result = result.substr(0, result.length - 1) + "=";
    }
    return result;
  }
  /**
   * Build headers for Cosmos DB data plane requests
   */
  buildCosmosHeaders(verb, resourceType, resourceLink, additionalHeaders = {}) {
    const date = (/* @__PURE__ */ new Date()).toUTCString();
    cli.output(`\u{1F510} Generated date: ${date}`);
    const authSignature = this.generateAuthorizationSignature(verb, resourceType, resourceLink, date);
    const headers = {
      "Authorization": authSignature,
      // Required - MUST be capitalized per Azure docs
      "Content-Type": "application/json",
      // Required for POST/PUT operations
      "User-Agent": "MonkEC-AzureCosmosDB/1.0.0",
      // Recommended format per docs
      "x-ms-date": date,
      // Required - RFC 1123 format
      "x-ms-version": "2018-12-31",
      // Required - API version
      ...additionalHeaders
    };
    if ((verb.toUpperCase() === "POST" || verb.toUpperCase() === "PUT") && this.definition.manual_throughput) {
      headers["x-ms-offer-throughput"] = this.definition.manual_throughput.toString();
    } else if ((verb.toUpperCase() === "POST" || verb.toUpperCase() === "PUT") && this.definition.autoscale_settings) {
      headers["x-ms-cosmos-offer-autopilot-settings"] = JSON.stringify({
        maxThroughput: this.definition.autoscale_settings.max_throughput
      });
    }
    return headers;
  }
  /**
   * Make a request to Cosmos DB data plane API using raw HTTP client
   * Uses direct HTTP client instead of cloud/azure module to avoid request corruption
   */
  makeCosmosRequest(method, path, body) {
    const url = `${this.buildDataPlaneEndpoint()}/${path}`;
    let resourceType = "";
    let resourceLink = "";
    if (path === "dbs") {
      resourceType = "dbs";
      resourceLink = "";
    } else if (path.startsWith("dbs/")) {
      resourceType = "dbs";
      resourceLink = path;
    }
    const headers = this.buildCosmosHeaders(method, resourceType, resourceLink);
    const bodyString = body ? JSON.stringify(body) : void 0;
    let response;
    try {
      const requestOptions = {
        method: method.toUpperCase(),
        headers,
        body: bodyString,
        timeout: 3e4
        // 30 second timeout
      };
      switch (method.toUpperCase()) {
        case "GET":
          response = http.get(url, { headers });
          break;
        case "POST":
          response = http.post(url, requestOptions);
          break;
        case "PUT":
          response = http.put(url, requestOptions);
          break;
        case "DELETE":
          response = http.delete(url, { headers });
          break;
        default:
          throw new Error(`Unsupported HTTP method: ${method}`);
      }
    } catch (error) {
      throw new Error(`Cosmos DB ${method} request failed: ${error}`);
    }
    if (response.error) {
      throw new Error(`Cosmos DB API error: ${response.statusCode} - ${response.error} - ${response.body}`);
    }
    if (response.statusCode >= 400) {
      throw new Error(`Cosmos DB API error: ${response.statusCode} - ${response.body}`);
    }
    return response.body ? JSON.parse(response.body) : null;
  }
  /**
   * Check if database exists
   */
  checkDatabaseExists() {
    try {
      const response = this.makeCosmosRequest("GET", `dbs/${this.definition.database_id}`);
      return response;
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : "Unknown error";
      if (errorMessage.includes("404") || errorMessage.includes("not found")) {
        return null;
      }
      throw new Error(`Failed to check if database exists: ${errorMessage}`);
    }
  }
  /** Create a new Cosmos DB database */
  create() {
    const existingDatabase = this.checkDatabaseExists();
    if (existingDatabase) {
      const db2 = existingDatabase;
      this.state = {
        database_id: typeof db2.id === "string" ? db2.id : this.definition.database_id,
        resource_id: typeof db2._rid === "string" ? db2._rid : void 0,
        timestamp: typeof db2._ts === "number" ? db2._ts : void 0,
        self_link: typeof db2._self === "string" ? db2._self : void 0,
        etag: typeof db2._etag === "string" ? db2._etag : void 0,
        collections_path: typeof db2._colls === "string" ? db2._colls : void 0,
        users_path: typeof db2._users === "string" ? db2._users : void 0,
        existing: true
      };
      cli.output(`\u2705 Database ${this.definition.database_id} already exists`);
      return;
    }
    if (this.definition.create_when_missing === false) {
      cli.output(`\u26A0\uFE0F  Database ${this.definition.database_id} does not exist and create_when_missing is false`);
      this.state = { existing: false };
      return;
    }
    const requestBody = {
      id: this.definition.database_id
    };
    const response = this.makeCosmosRequest("POST", "dbs", requestBody);
    const db = response;
    this.state = {
      database_id: typeof db.id === "string" ? db.id : this.definition.database_id,
      resource_id: typeof db._rid === "string" ? db._rid : void 0,
      timestamp: typeof db._ts === "number" ? db._ts : void 0,
      self_link: typeof db._self === "string" ? db._self : void 0,
      etag: typeof db._etag === "string" ? db._etag : void 0,
      collections_path: typeof db._colls === "string" ? db._colls : void 0,
      users_path: typeof db._users === "string" ? db._users : void 0,
      existing: false
    };
    cli.output(`\u2705 Created Cosmos DB database: ${this.definition.database_id}`);
  }
  update() {
    if (!this.state.database_id) {
      this.create();
      return;
    }
    cli.output(`Database ${this.definition.database_id} properties cannot be updated`);
  }
  delete() {
    if (this.state.existing) {
      cli.output(`Database ${this.definition.database_id} wasn't created by this entity, skipping delete`);
      return;
    }
    if (!this.state.database_id) {
      cli.output("Database does not exist, nothing to delete");
      return;
    }
    try {
      this.makeCosmosRequest("DELETE", `dbs/${this.definition.database_id}`);
      cli.output(`Successfully deleted Cosmos DB database: ${this.definition.database_id}`);
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : "Unknown error";
      if (errorMessage.includes("404") || errorMessage.includes("not found")) {
        return;
      }
      throw new Error(`Failed to delete database ${this.definition.database_id}: ${errorMessage}`);
    }
  }
  checkReadiness() {
    if (!this.state.database_id) {
      return false;
    }
    try {
      const database = this.checkDatabaseExists();
      if (!database) {
        return false;
      }
      const db = database;
      this.state.resource_id = typeof db._rid === "string" ? db._rid : void 0;
      this.state.timestamp = typeof db._ts === "number" ? db._ts : void 0;
      this.state.etag = typeof db._etag === "string" ? db._etag : void 0;
      return true;
    } catch (_error) {
      return false;
    }
  }
  checkLiveness() {
    return this.checkReadiness();
  }
};
__name(_Database, "Database");
var Database = _Database;



function main(def, state, ctx) {
  const entity = new Database(def, state, ctx);
  return entity.main(ctx);
}
