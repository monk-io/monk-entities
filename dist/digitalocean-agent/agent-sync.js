
// Generated by MonkEC - targeting Goja runtime
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __knownSymbol = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined") return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});
var __decoratorStart = (base) => [, , , __create(base?.[__knownSymbol("metadata")] ?? null)];
var __decoratorStrings = ["class", "method", "getter", "setter", "accessor", "field", "value", "get", "set"];
var __expectFn = (fn) => fn !== void 0 && typeof fn !== "function" ? __typeError("Function expected") : fn;
var __decoratorContext = (kind, name, done, metadata, fns) => ({ kind: __decoratorStrings[kind], name, metadata, addInitializer: (fn) => done._ ? __typeError("Already initialized") : fns.push(__expectFn(fn || null)) });
var __decoratorMetadata = (array, target) => __defNormalProp(target, __knownSymbol("metadata"), array[3]);
var __runInitializers = (array, flags, self, value) => {
  for (var i = 0, fns = array[flags >> 1], n = fns && fns.length; i < n; i++) flags & 1 ? fns[i].call(self) : value = fns[i].call(self, value);
  return value;
};
var __decorateElement = (array, flags, name, decorators, target, extra) => {
  var fn, it, done, ctx, access, k = flags & 7, s = !!(flags & 8), p = !!(flags & 16);
  var j = k > 3 ? array.length + 1 : k ? s ? 1 : 2 : 0, key = __decoratorStrings[k + 5];
  var initializers = k > 3 && (array[j - 1] = []), extraInitializers = array[j] || (array[j] = []);
  var desc = k && (!p && !s && (target = target.prototype), k < 5 && (k > 3 || !p) && __getOwnPropDesc(k < 4 ? target : { get [name]() {
    return __privateGet(this, extra);
  }, set [name](x) {
    return __privateSet(this, extra, x);
  } }, name));
  k ? p && k < 4 && __name(extra, (k > 2 ? "set " : k > 1 ? "get " : "") + name) : __name(target, name);
  for (var i = decorators.length - 1; i >= 0; i--) {
    ctx = __decoratorContext(k, name, done = {}, array[3], extraInitializers);
    if (k) {
      ctx.static = s, ctx.private = p, access = ctx.access = { has: p ? (x) => __privateIn(target, x) : (x) => name in x };
      if (k ^ 3) access.get = p ? (x) => (k ^ 1 ? __privateGet : __privateMethod)(x, target, k ^ 4 ? extra : desc.get) : (x) => x[name];
      if (k > 2) access.set = p ? (x, y) => __privateSet(x, target, y, k ^ 4 ? extra : desc.set) : (x, y) => x[name] = y;
    }
    it = (0, decorators[i])(k ? k < 4 ? p ? extra : desc[key] : k > 4 ? void 0 : { get: desc.get, set: desc.set } : target, ctx), done._ = 1;
    if (k ^ 4 || it === void 0) __expectFn(it) && (k > 4 ? initializers.unshift(it) : k ? p ? extra = it : desc[key] = it : target = it);
    else if (typeof it !== "object" || it === null) __typeError("Object expected");
    else __expectFn(fn = it.get) && (desc.get = fn), __expectFn(fn = it.set) && (desc.set = fn), __expectFn(fn = it.init) && initializers.unshift(fn);
  }
  return k || __decoratorMetadata(array, target), desc && __defProp(target, name, desc), p ? k ^ 4 ? extra : desc : target;
};
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateIn = (member, obj) => Object(obj) !== obj ? __typeError('Cannot use the "in" operator on this value') : member.has(obj);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);

// input/digitalocean-agent/agent.ts
const cli = require("cli");
const MonkecBase = require("monkec/base");
var action2 = MonkecBase.action;
var digitalocean = __require("cloud/digitalocean");
var _models_dec, _makePublic_dec, _deploy_dec, _listApiKeys_dec, _deleteApiKey_dec, _revokeApiKey_dec, _createApiKey_dec, _setKnowledgeBases_dec, _setGuardrails_dec, _get_dec, _a, _init;
var _Agent = class _Agent extends (_a = MonkecBase.MonkEntity, _get_dec = [action2()], _setGuardrails_dec = [action2()], _setKnowledgeBases_dec = [action2()], _createApiKey_dec = [action2()], _revokeApiKey_dec = [action2()], _deleteApiKey_dec = [action2()], _listApiKeys_dec = [action2()], _deploy_dec = [action2()], _makePublic_dec = [action2()], _models_dec = [action2()], _a) {
  constructor() {
    super(...arguments);
    __runInitializers(_init, 5, this);
  }
  getEntityName() {
    return "digitalocean-agent/agent";
  }
  httpPost(path, body) {
    const resp = digitalocean.post(path, {
      headers: { "Accept": "application/json", "Content-Type": "application/json" },
      body: JSON.stringify(body)
    });
    if (resp.statusCode < 200 || resp.statusCode >= 300) {
      throw new Error(`DO API error: ${resp.statusCode} ${resp.status} - ${resp.body || ""}`);
    }
    return resp.body ? JSON.parse(resp.body) : {};
  }
  httpGet(path) {
    const resp = digitalocean.get(path, { headers: { "Accept": "application/json" } });
    if (resp.statusCode < 200 || resp.statusCode >= 300) {
      throw new Error(`DO API error: ${resp.statusCode} ${resp.status} - ${resp.body || ""}`);
    }
    return resp.body ? JSON.parse(resp.body) : {};
  }
  httpPatch(path, body) {
    try {
      const resp = digitalocean.do(path, {
        method: "PATCH",
        headers: { "Accept": "application/json", "Content-Type": "application/json" },
        body: JSON.stringify(body)
      });
      if (resp.statusCode < 200 || resp.statusCode >= 300) {
        throw new Error(`DO API error: ${resp.statusCode} ${resp.status} - ${resp.body || ""}`);
      }
      return resp.body ? JSON.parse(resp.body) : {};
    } catch (_e) {
      const resp = digitalocean.put(path, {
        headers: { "Accept": "application/json", "Content-Type": "application/json" },
        body: JSON.stringify(body)
      });
      if (resp.statusCode < 200 || resp.statusCode >= 300) {
        throw new Error(`DO API error: ${resp.statusCode} ${resp.status} - ${resp.body || ""}`);
      }
      return resp.body ? JSON.parse(resp.body) : {};
    }
  }
  del(path) {
    const resp = digitalocean.delete(path, { headers: { "Accept": "application/json" } });
    if (resp.statusCode >= 400 && resp.statusCode !== 404) {
      throw new Error(`DO API error: ${resp.statusCode} ${resp.status} - ${resp.body || ""}`);
    }
  }
  resolveModelUuid() {
    if (this.definition.model_uuid && this.definition.model_uuid.match(/[0-9a-fA-F-]{36}/)) {
      return this.definition.model_uuid;
    }
    const candidate = (this.definition.model_id || this.definition.inference_name || this.definition.model_uuid || "").trim();
    if (!candidate) {
      throw new Error("model_uuid or model_id/inference_name must be provided");
    }
    const modelsResp = this.httpGet("/v2/gen-ai/models");
    const models = modelsResp.models || modelsResp || [];
    const lower = candidate.toLowerCase();
    const match = models.find((m) => {
      const uuid = (m.uuid || "").toLowerCase();
      const id = (m.id || "").toLowerCase();
      const name = (m.name || "").toLowerCase();
      return uuid === lower || id === lower || name === lower;
    });
    if (!match) {
      throw new Error(`Unable to resolve model identifier '${candidate}' to a UUID`);
    }
    return match.uuid;
  }
  resolveProjectId() {
    if (this.definition.project_id && String(this.definition.project_id).trim().length > 0) {
      return this.definition.project_id;
    }
    try {
      const resp = this.httpGet("/v2/projects/default");
      const project = resp.project || resp || {};
      const projId = project.id || project.uuid;
      if (projId && String(projId).trim().length > 0) return projId;
    } catch (_e) {
    }
    return void 0;
  }
  // Waiting moved to readiness checks driven by Monk engine
  deployAgentIfNeeded() {
    if (!this.state.id) return;
    try {
      const body = {};
      if (this.definition.public_endpoint || this.definition.publish) {
        body.visibility = body.visibility || "public";
        body.public = true;
        body.is_public = true;
      }
      const data = this.httpPost(`/v2/gen-ai/agents/${this.state.id}/deployments`, body);
      const dep = data.deployment || data || {};
      if (dep.url) this.state.endpoint = dep.url;
      if (dep.status) this.state.status = dep.status;
    } catch (_e) {
    }
  }
  getApiKeysBasePath() {
    if (!this.state.id) throw new Error("Agent id missing in state");
    return `/v2/gen-ai/agents/${this.state.id}/api_keys`;
  }
  parseApiKeySecret(resp) {
    if (!resp) return void 0;
    if (resp.api_key_info && typeof resp.api_key_info === "object") {
      const info = resp.api_key_info;
      return info.secret_key || info.api_key || info.key || info.secret;
    }
    if (resp.api_key && typeof resp.api_key === "object") {
      const obj = resp.api_key;
      return obj.secret_key || obj.api_key || obj.key || obj.secret;
    }
    return resp.secret_key || resp.api_key || resp.key || resp.secret;
  }
  create() {
    const body = {
      name: this.definition.name,
      instruction: this.definition.instruction,
      model_uuid: this.resolveModelUuid()
    };
    const resolvedProjectId = this.resolveProjectId();
    if (resolvedProjectId) body.project_id = resolvedProjectId;
    if (this.definition.knowledge_base_uuids) body.knowledge_base_uuid = this.definition.knowledge_base_uuids;
    if (this.definition.guardrail_uuids) body.guardrail_uuids = this.definition.guardrail_uuids;
    if (this.definition.tags) body.tags = this.definition.tags;
    if (this.definition.region) body.region = this.definition.region;
    if (this.definition.provide_citations !== void 0) body.provide_citations = this.definition.provide_citations;
    if (this.definition.retrieval_method) body.retrieval_method = this.definition.retrieval_method;
    if (this.definition.k !== void 0) body.k = this.definition.k;
    if (this.definition.temperature !== void 0) body.temperature = this.definition.temperature;
    if (this.definition.top_p !== void 0) body.top_p = this.definition.top_p;
    if (this.definition.max_tokens !== void 0) body.max_tokens = this.definition.max_tokens;
    const data = this.httpPost("/v2/gen-ai/agents", body);
    const agent = data.agent || data || {};
    this.state.id = agent.id || agent.uuid || agent.agent_uuid;
    this.state.status = agent.status || agent.state || agent.deployment?.status;
    this.state.endpoint = agent.endpoint || agent.url || agent.deployment?.url;
    this.state.existing = false;
    if (!this.state.endpoint || this.definition.public_endpoint || this.definition.publish) {
      this.deployAgentIfNeeded();
    }
    try {
      const keyResp = this.httpPost(this.getApiKeysBasePath(), { agent_uuid: this.state.id, name: "default-key" });
      const apiKey = this.parseApiKeySecret(keyResp);
      if (apiKey) this.state.endpoint_api_key = apiKey;
    } catch (_e) {
    }
    cli.output(`Created DO Agent '${this.definition.name}' (id=${this.state.id || "unknown"})`);
  }
  update() {
    if (!this.state.id) {
      this.create();
      return;
    }
    const body = {};
    if (this.definition.instruction) body.instruction = this.definition.instruction;
    if (this.definition.knowledge_base_uuids) body.knowledge_base_uuid = this.definition.knowledge_base_uuids;
    if (this.definition.guardrail_uuids) body.guardrail_uuids = this.definition.guardrail_uuids;
    if (this.definition.tags) body.tags = this.definition.tags;
    if (this.definition.region) body.region = this.definition.region;
    if (this.definition.provide_citations !== void 0) body.provide_citations = this.definition.provide_citations;
    if (this.definition.retrieval_method) body.retrieval_method = this.definition.retrieval_method;
    if (this.definition.k !== void 0) body.k = this.definition.k;
    if (this.definition.temperature !== void 0) body.temperature = this.definition.temperature;
    if (this.definition.top_p !== void 0) body.top_p = this.definition.top_p;
    if (this.definition.max_tokens !== void 0) body.max_tokens = this.definition.max_tokens;
    if (this.definition.model_uuid || this.definition.model_id || this.definition.inference_name) {
      body.model_uuid = this.resolveModelUuid();
    }
    const resolvedProjectId2 = this.resolveProjectId();
    if (resolvedProjectId2) body.project_id = resolvedProjectId2;
    const data = this.httpPatch(`/v2/gen-ai/agents/${this.state.id}`, body);
    const agent = data.agent || data || {};
    this.state.status = agent.status || agent.state || agent.deployment?.status || this.state.status;
    this.state.endpoint = agent.endpoint || agent.url || agent.deployment?.url || this.state.endpoint;
    if (this.definition.public_endpoint && !this.state.endpoint) {
      this.deployAgentIfNeeded();
    }
    cli.output(`Updated DO Agent (id=${this.state.id})`);
  }
  delete() {
    if (!this.state.id) {
      cli.output("No agent id; nothing to delete");
      return;
    }
    this.del(`/v2/gen-ai/agents/${this.state.id}`);
    this.state.id = void 0;
    this.state.status = void 0;
    this.state.endpoint = void 0;
    this.state.existing = false;
    cli.output("Deleted DO Agent");
  }
  checkReadiness() {
    if (!this.state.id) return false;
    try {
      const data = this.httpGet(`/v2/gen-ai/agents/${this.state.id}`);
      console.log("checkReadiness", JSON.stringify(data));
      const agent = data.agent || data || {};
      const deployment = agent.deployment || {};
      const rawStatus = deployment.status || agent.status || agent.state || "";
      const status = String(rawStatus).toLowerCase().replace(/^status_/, "").replace(/^state_/, "");
      let endpoint = deployment.url || agent.endpoint || agent.url;
      if (!endpoint) {
        try {
          const deps = this.httpGet(`/v2/gen-ai/agents/${this.state.id}/deployments`);
          const list = deps.deployments || deps || [];
          if (Array.isArray(list) && list.length > 0) {
            const latest = list[0];
            endpoint = latest.url || latest.endpoint || endpoint;
          }
        } catch (_e) {
        }
      }
      if (endpoint) this.state.endpoint = endpoint;
      this.state.status = status;
      console.log("checkReadiness", status, endpoint);
      return ["active", "ready", "running", "enabled"].includes(status);
    } catch (_e) {
      return false;
    }
  }
  get(_args) {
    if (!this.state.id) throw new Error("Agent id missing in state");
    const data = this.httpGet(`/v2/gen-ai/agents/${this.state.id}`);
    cli.output(JSON.stringify(data, null, 2));
  }
  setGuardrails(args) {
    if (!this.state.id) throw new Error("Agent id missing in state");
    const raw = args?.guardrail_uuids || "";
    const guardrailUuids = raw ? raw.split(",").map((s) => s.trim()).filter(Boolean) : [];
    const body = { guardrail_uuids: guardrailUuids };
    const data = this.httpPatch(`/v2/gen-ai/agents/${this.state.id}`, body);
    cli.output(`Updated guardrails for Agent ${this.state.id}`);
    cli.output(JSON.stringify(data, null, 2));
  }
  setKnowledgeBases(args) {
    if (!this.state.id) throw new Error("Agent id missing in state");
    const raw = args?.knowledge_base_uuids || args?.knowledge_base_uuid || "";
    const kbUuids = raw ? raw.split(",").map((s) => s.trim()).filter(Boolean) : [];
    const body = { knowledge_base_uuid: kbUuids };
    const data = this.httpPatch(`/v2/gen-ai/agents/${this.state.id}`, body);
    cli.output(`Updated knowledge bases for Agent ${this.state.id}`);
    cli.output(JSON.stringify(data, null, 2));
  }
  createApiKey(args) {
    if (!this.state.id) throw new Error("Agent id missing in state");
    const name = args?.name || args?._?.[0] || void 0;
    const body = { agent_uuid: this.state.id };
    if (name) body.name = name;
    const data = this.httpPost(this.getApiKeysBasePath(), body);
    cli.output(`Created API key for Agent ${this.state.id}`);
    cli.output(JSON.stringify(data, null, 2));
    const apiKey = this.parseApiKeySecret(data);
    if (apiKey) this.state.endpoint_api_key = apiKey;
  }
  revokeApiKey(args) {
    if (!this.state.id) throw new Error("Agent id missing in state");
    const keyUuid = args?.api_key_uuid;
    if (!keyUuid) throw new Error("api_key_uuid is required");
    this.del(`${this.getApiKeysBasePath()}/${keyUuid}`);
    cli.output(`Revoked API key ${keyUuid} for Agent ${this.state.id}`);
  }
  deleteApiKey(args) {
    if (!this.state.id) throw new Error("Agent id missing in state");
    const keyUuid = args?.api_key_uuid || args?._?.[0];
    if (!keyUuid) throw new Error("api_key_uuid is required");
    this.del(`${this.getApiKeysBasePath()}/${keyUuid}`);
    cli.output(`Deleted API key ${keyUuid} for Agent ${this.state.id}`);
  }
  listApiKeys(_args) {
    if (!this.state.id) throw new Error("Agent id missing in state");
    const data = this.httpGet(this.getApiKeysBasePath());
    cli.output(JSON.stringify(data, null, 2));
  }
  deploy(_args) {
    if (!this.state.id) throw new Error("Agent id missing in state");
    const body = {};
    if (this.definition.public_endpoint) {
      body.visibility = body.visibility || "public";
      body.public = true;
      body.is_public = true;
    }
    const data = this.httpPost(`/v2/gen-ai/agents/${this.state.id}/deployments`, body);
    const dep = data.deployment || data || {};
    this.state.status = dep.status || this.state.status;
    this.state.endpoint = dep.url || this.state.endpoint;
    cli.output(`Triggered deployment for Agent ${this.state.id}`);
    cli.output(JSON.stringify(data, null, 2));
  }
  makePublic(_args) {
    if (!this.state.id) throw new Error("Agent id missing in state");
    this.definition.public_endpoint = true;
    this.deployAgentIfNeeded();
    try {
      const data = this.httpGet(`/v2/gen-ai/agents/${this.state.id}`);
      const agent = data.agent || data || {};
      this.state.status = agent.status || agent.state || agent.deployment?.status || this.state.status;
      const endpoint = agent.endpoint || agent.url || agent.deployment?.url;
      if (endpoint) this.state.endpoint = endpoint;
    } catch (_e) {
    }
    cli.output(`Made Agent ${this.state.id} public (if supported)`);
    cli.output(JSON.stringify({ endpoint: this.state.endpoint, status: this.state.status }, null, 2));
  }
  models(_args) {
    const data = this.httpGet("/v2/gen-ai/models");
    cli.output(JSON.stringify(data, null, 2));
  }
};
_init = __decoratorStart(_a);
__decorateElement(_init, 1, "get", _get_dec, _Agent);
__decorateElement(_init, 1, "setGuardrails", _setGuardrails_dec, _Agent);
__decorateElement(_init, 1, "setKnowledgeBases", _setKnowledgeBases_dec, _Agent);
__decorateElement(_init, 1, "createApiKey", _createApiKey_dec, _Agent);
__decorateElement(_init, 1, "revokeApiKey", _revokeApiKey_dec, _Agent);
__decorateElement(_init, 1, "deleteApiKey", _deleteApiKey_dec, _Agent);
__decorateElement(_init, 1, "listApiKeys", _listApiKeys_dec, _Agent);
__decorateElement(_init, 1, "deploy", _deploy_dec, _Agent);
__decorateElement(_init, 1, "makePublic", _makePublic_dec, _Agent);
__decorateElement(_init, 1, "models", _models_dec, _Agent);
__decoratorMetadata(_init, _Agent);
__name(_Agent, "Agent");
var Agent = _Agent;



function main(def, state, ctx) {
  const entity = new Agent(def, state, ctx);
  return entity.main(ctx);
}
