
// Generated by MonkEC - targeting Goja runtime
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined") return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);

// input/azure-cosmosdb/container.ts
const azureCosmosdbBase = require("azure-cosmosdb/azure-cosmosdb-base");
const AzureCosmosDBEntity = azureCosmosdbBase.AzureCosmosDBEntity;
const cli = require("cli");
const http = require("http");
const crypto = require("crypto");
var _azure = __require("cloud/azure");
var _Container = class _Container extends AzureCosmosDBEntity {
  constructor() {
    super(...arguments);
    __publicField(this, "_masterKey");
  }
  getEntityName() {
    return this.definition.container_id;
  }
  getResourceType() {
    return "colls";
  }
  buildDataPlaneEndpoint() {
    return `https://${this.definition.database_account_name}.documents.azure.com`;
  }
  /**
   * Retrieve the master key for the Cosmos DB account from the Azure Management API.
   */
  getMasterKey() {
    if (this._masterKey) {
      return this._masterKey;
    }
    const keysPath = `/subscriptions/${this.definition.subscription_id}/resourceGroups/${this.definition.resource_group_name}/providers/Microsoft.DocumentDB/databaseAccounts/${this.definition.database_account_name}/listKeys?api-version=${this.apiVersion}`;
    try {
      const response = this.makeAzureRequest("POST", keysPath);
      if (response.statusCode !== 200) {
        throw new Error(`Failed to retrieve master key: ${response.statusCode} - ${response.error || response.body}`);
      }
      const responseData = this.parseResponseBody(response);
      if (!responseData || typeof responseData !== "object") {
        throw new Error("Invalid response from listKeys API");
      }
      const keysData = responseData;
      const primaryMasterKey = keysData.primaryMasterKey;
      if (typeof primaryMasterKey !== "string") {
        throw new Error("Primary master key not found in response");
      }
      this._masterKey = primaryMasterKey;
      return this._masterKey;
    } catch (error) {
      throw new Error(`Failed to retrieve Cosmos DB master key: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  /**
   * Generate authorization signature for Cosmos DB Data Plane API
   * Implements the Azure Cosmos DB REST API authentication as per:
   * https://docs.microsoft.com/en-us/rest/api/cosmos-db/access-control-on-cosmosdb-resources
   */
  generateAuthorizationSignature(verb, resourceType, resourceLink, date) {
    const masterKey = this.getMasterKey();
    const stringToSign = (verb || "").toLowerCase() + "\n" + (resourceType || "").toLowerCase() + "\n" + (resourceLink || "") + "\n" + date.toLowerCase() + "\n\n";
    const hmacHash = crypto.hmac(masterKey, stringToSign);
    const signature = this.hexToBase64Fixed(hmacHash);
    const masterToken = "master";
    const tokenVersion = "1.0";
    const authString = "type=" + masterToken + "&ver=" + tokenVersion + "&sig=" + signature;
    return encodeURIComponent(authString).replace(/%[0-9A-F]{2}/g, (match) => match.toLowerCase());
  }
  /**
   * Convert hex string directly to base64 (FIXED - proper byte handling)
   */
  hexToBase64Fixed(hex) {
    const base64Chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    let result = "";
    let i = 0;
    while (i < hex.length) {
      const byte1 = parseInt(hex.substr(i, 2), 16);
      const byte2 = parseInt(hex.substr(i + 2, 2), 16);
      const byte3 = parseInt(hex.substr(i + 4, 2), 16);
      const enc1 = byte1 >> 2;
      const enc2 = (byte1 & 3) << 4 | byte2 >> 4;
      const enc3 = (byte2 & 15) << 2 | byte3 >> 6;
      const enc4 = byte3 & 63;
      if (isNaN(byte2)) {
        result += base64Chars.charAt(enc1) + base64Chars.charAt(enc2) + "==";
      } else if (isNaN(byte3)) {
        result += base64Chars.charAt(enc1) + base64Chars.charAt(enc2) + base64Chars.charAt(enc3) + "=";
      } else {
        result += base64Chars.charAt(enc1) + base64Chars.charAt(enc2) + base64Chars.charAt(enc3) + base64Chars.charAt(enc4);
      }
      i += 6;
    }
    return result;
  }
  /**
   * Build Cosmos DB specific headers including authorization and date.
   */
  buildCosmosHeaders(verb, resourceType, resourceLink, additionalHeaders = {}) {
    const date = (/* @__PURE__ */ new Date()).toUTCString();
    const authSignature = this.generateAuthorizationSignature(verb, resourceType, resourceLink, date);
    const headers = {
      "Authorization": authSignature,
      // Required - MUST be capitalized per Azure docs
      "Content-Type": "application/json",
      // Required for POST/PUT operations
      "User-Agent": "MonkEC-AzureCosmosDB/1.0.0",
      // Recommended format per docs
      "x-ms-date": date,
      // Required - RFC 1123 format
      "x-ms-version": "2018-12-31",
      // Required - API version
      ...additionalHeaders
    };
    if ((verb.toUpperCase() === "POST" || verb.toUpperCase() === "PUT") && this.definition.manual_throughput) {
      headers["x-ms-offer-throughput"] = this.definition.manual_throughput.toString();
    } else if ((verb.toUpperCase() === "POST" || verb.toUpperCase() === "PUT") && this.definition.autoscale_settings) {
      headers["x-ms-cosmos-offer-autopilot-settings"] = JSON.stringify({
        maxThroughput: this.definition.autoscale_settings.max_throughput
      });
    }
    return headers;
  }
  /**
   * Make a request to Cosmos DB data plane API using raw HTTP client
   * Uses direct HTTP client instead of cloud/azure module to avoid request corruption
   */
  makeCosmosRequest(method, path, body) {
    const url = `${this.buildDataPlaneEndpoint()}/${path}`;
    let resourceType = "";
    let resourceLink = "";
    if (path === `dbs/${this.definition.database_id}/colls`) {
      resourceType = "colls";
      resourceLink = `dbs/${this.definition.database_id}`;
    } else if (path.startsWith(`dbs/${this.definition.database_id}/colls/`)) {
      resourceType = "colls";
      resourceLink = path;
    }
    const headers = this.buildCosmosHeaders(method, resourceType, resourceLink);
    const bodyString = body ? JSON.stringify(body) : void 0;
    let response;
    try {
      const requestOptions = {
        method: method.toUpperCase(),
        headers,
        body: bodyString,
        timeout: 3e4
        // 30 second timeout
      };
      switch (method.toUpperCase()) {
        case "GET":
          response = http.get(url, { headers });
          break;
        case "POST":
          response = http.post(url, requestOptions);
          break;
        case "PUT":
          response = http.put(url, requestOptions);
          break;
        case "DELETE":
          response = http.delete(url, { headers });
          break;
        default:
          throw new Error(`Unsupported HTTP method: ${method}`);
      }
    } catch (error) {
      throw new Error(`Cosmos DB ${method} request failed: ${error}`);
    }
    if (response.error) {
      throw new Error(`Cosmos DB API error: ${response.statusCode} - ${response.error} - ${response.body}`);
    }
    if (response.statusCode >= 400) {
      throw new Error(`Cosmos DB API error: ${response.statusCode} - ${response.body}`);
    }
    return response.body ? JSON.parse(response.body) : null;
  }
  /**
   * Check if container exists
   */
  checkContainerExists() {
    try {
      const response = this.makeCosmosRequest("GET", `dbs/${this.definition.database_id}/colls/${this.definition.container_id}`);
      return response;
    } catch (_error) {
      const errorMessage = _error instanceof Error ? _error.message : "Unknown error";
      if (errorMessage.includes("404") || errorMessage.includes("not found")) {
        return null;
      }
      throw new Error(`Failed to check if container exists: ${errorMessage}`);
    }
  }
  /** Create a new Cosmos DB container */
  create() {
    const existingContainer = this.checkContainerExists();
    if (existingContainer) {
      const container2 = existingContainer;
      this.state = {
        container_id: typeof container2.id === "string" ? container2.id : this.definition.container_id,
        resource_id: typeof container2._rid === "string" ? container2._rid : void 0,
        timestamp: typeof container2._ts === "number" ? container2._ts : void 0,
        self_link: typeof container2._self === "string" ? container2._self : void 0,
        etag: typeof container2._etag === "string" ? container2._etag : void 0,
        documents_path: typeof container2._docs === "string" ? container2._docs : void 0,
        stored_procedures_path: typeof container2._sprocs === "string" ? container2._sprocs : void 0,
        triggers_path: typeof container2._triggers === "string" ? container2._triggers : void 0,
        user_defined_functions_path: typeof container2._udfs === "string" ? container2._udfs : void 0,
        conflicts_path: typeof container2._conflicts === "string" ? container2._conflicts : void 0,
        existing: true
      };
      cli.output(`\u2705 Container ${this.definition.container_id} already exists`);
      return;
    }
    if (!this.definition.partition_key || !this.definition.partition_key.paths || this.definition.partition_key.paths.length === 0) {
      throw new Error("Partition key configuration is required for container creation");
    }
    if (this.definition.manual_throughput && this.definition.autoscale_settings) {
      throw new Error("Cannot specify both manual_throughput and autoscale_settings");
    }
    const requestBody = {
      id: this.definition.container_id,
      partitionKey: this.definition.partition_key
    };
    if (this.definition.indexing_policy) {
      requestBody.indexingPolicy = this.definition.indexing_policy;
    }
    if (this.definition.default_ttl !== void 0) {
      requestBody.defaultTtl = this.definition.default_ttl;
    }
    if (this.definition.unique_key_policy) {
      requestBody.uniqueKeyPolicy = this.definition.unique_key_policy;
    }
    if (this.definition.conflict_resolution_policy) {
      requestBody.conflictResolutionPolicy = this.definition.conflict_resolution_policy;
    }
    const response = this.makeCosmosRequest("POST", `dbs/${this.definition.database_id}/colls`, requestBody);
    const container = response;
    this.state = {
      container_id: typeof container.id === "string" ? container.id : this.definition.container_id,
      resource_id: typeof container._rid === "string" ? container._rid : void 0,
      timestamp: typeof container._ts === "number" ? container._ts : void 0,
      self_link: typeof container._self === "string" ? container._self : void 0,
      etag: typeof container._etag === "string" ? container._etag : void 0,
      documents_path: typeof container._docs === "string" ? container._docs : void 0,
      stored_procedures_path: typeof container._sprocs === "string" ? container._sprocs : void 0,
      triggers_path: typeof container._triggers === "string" ? container._triggers : void 0,
      user_defined_functions_path: typeof container._udfs === "string" ? container._udfs : void 0,
      conflicts_path: typeof container._conflicts === "string" ? container._conflicts : void 0,
      existing: false
    };
    cli.output(`\u2705 Created Cosmos DB container: ${this.definition.container_id}`);
  }
  update() {
    if (!this.state.container_id) {
      this.create();
      return;
    }
    cli.output(`Container ${this.definition.container_id} properties cannot be updated after creation`);
    cli.output(`Use Azure portal or separate scripts to modify throughput or indexing policy`);
  }
  delete() {
    if (this.state.existing) {
      cli.output(`Container ${this.definition.container_id} wasn't created by this entity, skipping delete`);
      return;
    }
    if (!this.state.container_id) {
      cli.output("Container does not exist, nothing to delete");
      return;
    }
    try {
      this.makeCosmosRequest("DELETE", `dbs/${this.definition.database_id}/colls/${this.definition.container_id}`);
      cli.output(`Successfully deleted Cosmos DB container: ${this.definition.container_id}`);
    } catch (_error) {
      const errorMessage = _error instanceof Error ? _error.message : "Unknown error";
      if (errorMessage.includes("404") || errorMessage.includes("not found")) {
        return;
      }
      throw new Error(`Failed to delete container ${this.definition.container_id}: ${errorMessage}`);
    }
  }
  checkReadiness() {
    if (!this.state.container_id) {
      return false;
    }
    try {
      const container = this.checkContainerExists();
      if (!container) {
        return false;
      }
      const containerData = container;
      this.state.resource_id = typeof containerData._rid === "string" ? containerData._rid : void 0;
      this.state.timestamp = typeof containerData._ts === "number" ? containerData._ts : void 0;
      this.state.etag = typeof containerData._etag === "string" ? containerData._etag : void 0;
      return true;
    } catch (_error) {
      return false;
    }
  }
  checkLiveness() {
    return this.checkReadiness();
  }
};
__name(_Container, "Container");
var Container = _Container;



function main(def, state, ctx) {
  const entity = new Container(def, state, ctx);
  return entity.main(ctx);
}
