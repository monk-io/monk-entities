
// Generated by MonkEC - targeting Goja runtime
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __knownSymbol = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __decoratorStart = (base) => [, , , __create(base?.[__knownSymbol("metadata")] ?? null)];
var __decoratorStrings = ["class", "method", "getter", "setter", "accessor", "field", "value", "get", "set"];
var __expectFn = (fn) => fn !== void 0 && typeof fn !== "function" ? __typeError("Function expected") : fn;
var __decoratorContext = (kind, name, done, metadata, fns) => ({ kind: __decoratorStrings[kind], name, metadata, addInitializer: (fn) => done._ ? __typeError("Already initialized") : fns.push(__expectFn(fn || null)) });
var __decoratorMetadata = (array, target) => __defNormalProp(target, __knownSymbol("metadata"), array[3]);
var __runInitializers = (array, flags, self, value) => {
  for (var i = 0, fns = array[flags >> 1], n = fns && fns.length; i < n; i++) flags & 1 ? fns[i].call(self) : value = fns[i].call(self, value);
  return value;
};
var __decorateElement = (array, flags, name, decorators, target, extra) => {
  var fn, it, done, ctx, access, k = flags & 7, s = !!(flags & 8), p = !!(flags & 16);
  var j = k > 3 ? array.length + 1 : k ? s ? 1 : 2 : 0, key = __decoratorStrings[k + 5];
  var initializers = k > 3 && (array[j - 1] = []), extraInitializers = array[j] || (array[j] = []);
  var desc = k && (!p && !s && (target = target.prototype), k < 5 && (k > 3 || !p) && __getOwnPropDesc(k < 4 ? target : { get [name]() {
    return __privateGet(this, extra);
  }, set [name](x) {
    return __privateSet(this, extra, x);
  } }, name));
  k ? p && k < 4 && __name(extra, (k > 2 ? "set " : k > 1 ? "get " : "") + name) : __name(target, name);
  for (var i = decorators.length - 1; i >= 0; i--) {
    ctx = __decoratorContext(k, name, done = {}, array[3], extraInitializers);
    if (k) {
      ctx.static = s, ctx.private = p, access = ctx.access = { has: p ? (x) => __privateIn(target, x) : (x) => name in x };
      if (k ^ 3) access.get = p ? (x) => (k ^ 1 ? __privateGet : __privateMethod)(x, target, k ^ 4 ? extra : desc.get) : (x) => x[name];
      if (k > 2) access.set = p ? (x, y) => __privateSet(x, target, y, k ^ 4 ? extra : desc.set) : (x, y) => x[name] = y;
    }
    it = (0, decorators[i])(k ? k < 4 ? p ? extra : desc[key] : k > 4 ? void 0 : { get: desc.get, set: desc.set } : target, ctx), done._ = 1;
    if (k ^ 4 || it === void 0) __expectFn(it) && (k > 4 ? initializers.unshift(it) : k ? p ? extra = it : desc[key] = it : target = it);
    else if (typeof it !== "object" || it === null) __typeError("Object expected");
    else __expectFn(fn = it.get) && (desc.get = fn), __expectFn(fn = it.set) && (desc.set = fn), __expectFn(fn = it.init) && initializers.unshift(fn);
  }
  return k || __decoratorMetadata(array, target), desc && __defProp(target, name, desc), p ? k ^ 4 ? extra : desc : target;
};
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateIn = (member, obj) => Object(obj) !== obj ? __typeError('Cannot use the "in" operator on this value') : member.has(obj);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);

// input/aws-s3/bucket.ts
const base = require("aws-s3/base");
const AWSS3Entity = base.AWSS3Entity;
const MonkecBase = require("monkec/base");
const cli = require("cli");
const aws = require("cloud/aws");
const common = require("aws-s3/common");
const validateBucketName = common.validateBucketName;
const DEFAULT_BUCKET_CONFIG = common.DEFAULT_BUCKET_CONFIG;
const buildLifecycleConfigXml = common.buildLifecycleConfigXml;
const buildEncryptionConfigXml = common.buildEncryptionConfigXml;
const parseS3Error = common.parseS3Error;
var action2 = MonkecBase.action;
var _getWebsiteInfo_dec, _getBucketStatistics_dec, _emptyBucket_dec, _generatePresignedUrl_dec, _listObjects_dec, _getBucketInfo_dec, _a, _init;
var _S3Bucket = class _S3Bucket extends (_a = AWSS3Entity, _getBucketInfo_dec = [action2()], _listObjects_dec = [action2()], _generatePresignedUrl_dec = [action2()], _emptyBucket_dec = [action2()], _getBucketStatistics_dec = [action2()], _getWebsiteInfo_dec = [action2()], _a) {
  constructor() {
    super(...arguments);
    __runInitializers(_init, 5, this);
  }
  getBucketName() {
    return this.definition.bucket_name;
  }
  create() {
    if (!validateBucketName(this.getBucketName())) {
      throw new Error(`Invalid bucket name: ${this.getBucketName()}`);
    }
    if (this.bucketExists(this.getBucketName())) {
      cli.output(`Bucket ${this.getBucketName()} already exists, adopting it and applying configuration`);
      this.state.existing = true;
      this.state.bucket_name = this.getBucketName();
      this.state.region = this.region;
      try {
        const location = this.getBucketLocation(this.getBucketName());
        this.state.location = location.LocationConstraint || this.region;
      } catch (error) {
        this.state.location = this.region;
      }
      this.configureBucket();
      return;
    }
    cli.output(`Creating new bucket: ${this.getBucketName()}`);
    this.createBucket(this.getBucketName());
    this.state.existing = false;
    this.state.bucket_name = this.getBucketName();
    this.state.region = this.region;
    this.state.location = this.region;
    cli.output(`Configuring new bucket: ${this.getBucketName()}`);
    this.configureBucket();
  }
  configureBucket() {
    const bucketName = this.getBucketName();
    const versioning = this.definition.versioning ?? DEFAULT_BUCKET_CONFIG.versioning;
    if (versioning !== void 0) {
      this.setBucketVersioning(bucketName, versioning);
    }
    const publicReadAccess = this.definition.public_read_access ?? DEFAULT_BUCKET_CONFIG.public_read_access;
    const publicWriteAccess = this.definition.public_write_access ?? DEFAULT_BUCKET_CONFIG.public_write_access;
    this.setBucketPublicAccessBlock(bucketName, publicReadAccess, publicWriteAccess);
    if (this.definition.cors_configuration?.cors_rules) {
      this.setBucketCors(bucketName, [...this.definition.cors_configuration.cors_rules]);
    }
    if (this.definition.lifecycle_configuration?.rules) {
      this.setBucketLifecycle(bucketName, [...this.definition.lifecycle_configuration.rules]);
    }
    if (this.definition.server_side_encryption?.rules) {
      this.setBucketEncryption(bucketName, [...this.definition.server_side_encryption.rules]);
    }
    if (this.definition.website_configuration) {
      const indexDoc = this.definition.website_configuration.index_document || "index.html";
      const errorDoc = this.definition.website_configuration.error_document;
      cli.output(`Configuring website hosting: index=${indexDoc}, error=${errorDoc || "none"}`);
      this.setBucketWebsite(bucketName, indexDoc, errorDoc);
      cli.output(`Website hosting configured successfully`);
    }
    if (this.definition.bucket_policy) {
      cli.output(`Configuring bucket policy: ${this.definition.bucket_policy.policy}`);
      this.setBucketPolicy(bucketName, this.definition.bucket_policy.policy);
      cli.output(`Bucket policy configured successfully`);
    }
    if (this.definition.tags) {
      try {
        this.setBucketTags(bucketName, this.definition.tags);
      } catch (error) {
        cli.output(`Warning: Failed to set bucket tags (AWS S3 tagging requires checksum headers): ${error.message}`);
        cli.output(`Bucket created successfully, but tags were not applied. This is a known limitation.`);
      }
    }
  }
  start() {
    this.checkReadiness();
  }
  stop() {
  }
  update() {
    if (!this.state.bucket_name) {
      throw new Error("Bucket name not available for update");
    }
    this.configureBucket();
  }
  delete() {
    if (!this.state.bucket_name) {
      try {
        if (!this.bucketExists(this.getBucketName())) {
          return;
        }
      } catch (error) {
        return;
      }
    }
    try {
      this.deleteBucket(this.getBucketName());
    } catch (error) {
      throw new Error(`Failed to delete bucket: ${error.message}`);
    }
    this.state.bucket_name = void 0;
    this.state.region = void 0;
    this.state.location = void 0;
    this.state.existing = false;
  }
  checkReadiness() {
    if (!this.state.bucket_name) {
      return false;
    }
    try {
      return this.bucketExists(this.getBucketName());
    } catch (error) {
      return false;
    }
  }
  checkLiveness() {
    return this.checkReadiness();
  }
  getBucketInfo(_args) {
    if (!this.state.bucket_name) {
      throw new Error("Bucket not created yet");
    }
    try {
      const location = this.getBucketLocation(this.getBucketName());
      const bucketInfo = {
        bucket_name: this.state.bucket_name,
        region: this.state.region,
        location: location.LocationConstraint || this.state.region,
        url: this.getBucketUrl(this.getBucketName())
      };
      cli.output(`Bucket Information:
${JSON.stringify(bucketInfo, null, 2)}`);
    } catch (error) {
      throw new Error(`Failed to get bucket info: ${error.message}`);
    }
  }
  listObjects(args) {
    if (!this.state.bucket_name) {
      throw new Error("Bucket not created yet");
    }
    const prefix = args?.prefix || "";
    const maxKeys = parseInt(args?.max_keys || "1000", 10);
    const url = this.getBucketUrl(this.getBucketName(), `?list-type=2&max-keys=${maxKeys}${prefix ? `&prefix=${encodeURIComponent(prefix)}` : ""}`);
    try {
      this.headBucket(this.getBucketName());
      const listResponse = this.listBucketObjects(url);
      const objectKeys = this.parseObjectKeysFromResponse(listResponse.body);
      const objectInfo = this.parseObjectInfoFromResponse(listResponse.body);
      cli.output(`Found ${objectKeys.length} objects in bucket ${this.getBucketName()}:`);
      if (objectKeys.length > 0) {
        objectInfo.forEach((obj) => {
          cli.output(`  - ${obj.key} (${obj.size} bytes, modified: ${obj.lastModified})`);
        });
      } else {
        cli.output("  (bucket is empty)");
      }
    } catch (error) {
      throw new Error(`Failed to list objects: ${error.message}`);
    }
  }
  generatePresignedUrl(args) {
    if (!this.state.bucket_name) {
      throw new Error("Bucket not created yet");
    }
    const objectKey = args?.object_key;
    const method = args?.method || "GET";
    const expires = parseInt(args?.expires || "3600", 10);
    if (!objectKey) {
      throw new Error("object_key parameter is required");
    }
    const url = this.getBucketUrl(this.getBucketName(), objectKey);
    try {
      const presignedResult = this.generatePresignedUrlForObject(url, method, expires);
      cli.output(`Presigned URL for ${method} ${objectKey}:`);
      cli.output(`URL: ${presignedResult.url}`);
      if (presignedResult.headers && Object.keys(presignedResult.headers).length > 0) {
        cli.output(`Headers: ${JSON.stringify(presignedResult.headers, null, 2)}`);
      }
    } catch (error) {
      throw new Error(`Failed to generate presigned URL: ${error.message}`);
    }
  }
  emptyBucket(_args) {
    if (!this.state.bucket_name) {
      throw new Error("Bucket not created yet");
    }
    try {
      let deletedCount = 0;
      let continuationToken;
      do {
        let listUrl = this.getBucketUrl(this.getBucketName(), "?list-type=2&max-keys=1000");
        if (continuationToken) {
          listUrl += `&continuation-token=${encodeURIComponent(continuationToken)}`;
        }
        const listResponse = this.listBucketObjects(listUrl);
        const objectKeys = this.parseObjectKeysFromResponse(listResponse.body);
        if (objectKeys.length === 0) {
          break;
        }
        const deleteCount = this.deleteObjectsBatch(objectKeys);
        deletedCount += deleteCount;
        const nextTokenMatch = listResponse.body.match(/<NextContinuationToken>(.*?)<\/NextContinuationToken>/);
        continuationToken = nextTokenMatch ? nextTokenMatch[1] : void 0;
      } while (continuationToken);
      cli.output(`Successfully deleted ${deletedCount} objects from bucket ${this.getBucketName()}`);
    } catch (error) {
      throw new Error(`Failed to empty bucket: ${error.message}`);
    }
  }
  getBucketStatistics(_args) {
    if (!this.state.bucket_name) {
      throw new Error("Bucket not created yet");
    }
    try {
      let totalObjects = 0;
      let totalSize = 0;
      let continuationToken;
      do {
        let listUrl = this.getBucketUrl(this.getBucketName(), "?list-type=2&max-keys=1000");
        if (continuationToken) {
          listUrl += `&continuation-token=${encodeURIComponent(continuationToken)}`;
        }
        const listResponse = this.listBucketObjects(listUrl);
        const objectInfo = this.parseObjectInfoFromResponse(listResponse.body);
        totalObjects += objectInfo.length;
        totalSize += objectInfo.reduce((sum, obj) => sum + parseInt(obj.size, 10), 0);
        const nextTokenMatch = listResponse.body.match(/<NextContinuationToken>(.*?)<\/NextContinuationToken>/);
        continuationToken = nextTokenMatch ? nextTokenMatch[1] : void 0;
      } while (continuationToken);
      const statistics = {
        bucket_name: this.state.bucket_name,
        total_objects: totalObjects,
        total_size_bytes: totalSize,
        total_size_mb: Math.round(totalSize / (1024 * 1024) * 100) / 100,
        total_size_gb: Math.round(totalSize / (1024 * 1024 * 1024) * 100) / 100
      };
      cli.output(`Bucket Statistics:
${JSON.stringify(statistics, null, 2)}`);
    } catch (error) {
      throw new Error(`Failed to get bucket statistics: ${error.message}`);
    }
  }
  getWebsiteInfo(_args) {
    if (!this.state.bucket_name) {
      throw new Error("Bucket not created yet");
    }
    const bucketName = this.getBucketName();
    try {
      cli.output(`=== Website Configuration Information ===`);
      cli.output(`Bucket: ${bucketName}`);
      cli.output(`Region: ${this.region}`);
      const websiteConfig = this.getBucketWebsite(bucketName);
      if (websiteConfig) {
        cli.output(`\u2705 Website hosting: ENABLED`);
        cli.output(`\u{1F4C4} Website URL: http://${bucketName}.s3-website-${this.region}.amazonaws.com`);
        cli.output(`\u{1F30D} Website URL (alternative): http://${bucketName}.s3-website.${this.region}.amazonaws.com`);
        const indexMatch = websiteConfig.body.match(/<Suffix>(.*?)<\/Suffix>/);
        const errorMatch = websiteConfig.body.match(/<Key>(.*?)<\/Key>/);
        if (indexMatch) {
          cli.output(`\u{1F4DD} Index document: ${indexMatch[1]}`);
        }
        if (errorMatch) {
          cli.output(`\u274C Error document: ${errorMatch[1]}`);
        }
      } else {
        cli.output(`\u274C Website hosting: DISABLED`);
        cli.output(`\u{1F4A1} To enable: Configure website_configuration in entity definition`);
      }
    } catch (error) {
      throw new Error(`Failed to get website info: ${error.message}`);
    }
  }
  // Helper methods for custom actions
  listBucketObjects(url) {
    const response = aws.get(url, {
      service: "s3",
      region: this.region
    });
    if (response.statusCode !== 200) {
      const error = parseS3Error(response);
      throw new Error(`Failed to list bucket objects: ${error}`);
    }
    return response;
  }
  generatePresignedUrlForObject(url, method, expires) {
    try {
      const presignedResult = aws.presign(url, {
        method,
        service: "s3",
        region: this.region,
        expire: expires
      });
      return presignedResult;
    } catch (error) {
      throw new Error(`Failed to generate presigned URL: ${error.message}`);
    }
  }
  setBucketLifecycle(bucketName, rules) {
    const url = this.getBucketUrl(bucketName, "?lifecycle");
    const lifecycleConfig = buildLifecycleConfigXml(rules);
    const response = aws.put(url, {
      service: "s3",
      region: this.region,
      headers: {
        "Content-Type": "application/xml"
      },
      body: lifecycleConfig
    });
    if (response.statusCode !== 200) {
      const error = parseS3Error(response);
      throw new Error(`Failed to set bucket lifecycle: ${error}`);
    }
    return response;
  }
  setBucketEncryption(bucketName, rules) {
    const url = this.getBucketUrl(bucketName, "?encryption");
    const encryptionConfig = buildEncryptionConfigXml(rules);
    const response = aws.put(url, {
      service: "s3",
      region: this.region,
      headers: {
        "Content-Type": "application/xml"
      },
      body: encryptionConfig
    });
    if (response.statusCode !== 200) {
      const error = parseS3Error(response);
      throw new Error(`Failed to set bucket encryption: ${error}`);
    }
    return response;
  }
  parseObjectKeysFromResponse(xmlResponse) {
    const objectKeys = [];
    const keyMatches = xmlResponse.match(/<Key>(.*?)<\/Key>/g);
    if (keyMatches) {
      for (const match of keyMatches) {
        const keyMatch = match.match(/<Key>(.*?)<\/Key>/);
        if (keyMatch && keyMatch[1]) {
          objectKeys.push(keyMatch[1]);
        }
      }
    }
    return objectKeys;
  }
  parseObjectInfoFromResponse(xmlResponse) {
    const objects = [];
    const contentMatches = xmlResponse.match(/<Contents>[\s\S]*?<\/Contents>/g);
    if (contentMatches) {
      for (const match of contentMatches) {
        const keyMatch = match.match(/<Key>(.*?)<\/Key>/);
        const sizeMatch = match.match(/<Size>(.*?)<\/Size>/);
        const lastModifiedMatch = match.match(/<LastModified>(.*?)<\/LastModified>/);
        if (keyMatch && sizeMatch && lastModifiedMatch) {
          objects.push({
            key: keyMatch[1],
            size: sizeMatch[1],
            lastModified: lastModifiedMatch[1]
          });
        }
      }
    }
    return objects;
  }
  deleteObjectsBatch(objectKeys) {
    if (objectKeys.length === 0) {
      return 0;
    }
    const deleteObjectsXml = objectKeys.map(
      (key) => `<Object><Key>${this.escapeXml(key)}</Key></Object>`
    ).join("");
    const deleteRequestXml = `<?xml version="1.0" encoding="UTF-8"?>
<Delete xmlns="http://s3.amazonaws.com/doc/2006-03-01/">
    ${deleteObjectsXml}
</Delete>`;
    const url = this.getBucketUrl(this.getBucketName(), "?delete");
    try {
      const response = aws.post(url, {
        service: "s3",
        region: this.region,
        headers: {
          "Content-Type": "application/xml"
        },
        body: deleteRequestXml
      });
      if (response.statusCode !== 200) {
        const error = parseS3Error(response);
        throw new Error(`Failed to delete objects: ${error}`);
      }
      return objectKeys.length;
    } catch (error) {
      const errorMessage = error && error.message ? error.message : String(error);
      cli.output(`Bulk delete failed, falling back to individual deletes: ${errorMessage}`);
      return this.deleteObjectsIndividually(objectKeys);
    }
  }
  deleteObjectsIndividually(objectKeys) {
    let deletedCount = 0;
    cli.output(`Attempting to delete ${objectKeys.length} objects individually...`);
    for (const key of objectKeys) {
      try {
        const url = this.getBucketUrl(this.getBucketName(), encodeURIComponent(key));
        cli.output(`Deleting object: ${key} (URL: ${url})`);
        const response = aws.delete(url, {
          service: "s3",
          region: this.region
        });
        if (response.statusCode === 204 || response.statusCode === 200) {
          deletedCount++;
          cli.output(`Successfully deleted object: ${key}`);
        } else {
          cli.output(`Warning: Failed to delete object ${key}: status ${response.statusCode}`);
        }
      } catch (error) {
        cli.output(`Warning: Failed to delete object ${key}: ${error.message}`);
      }
    }
    cli.output(`Individual delete completed. Deleted ${deletedCount} out of ${objectKeys.length} objects.`);
    return deletedCount;
  }
  escapeXml(unsafe) {
    return unsafe.replace(/[<>&'"]/g, function(c) {
      switch (c) {
        case "<":
          return "&lt;";
        case ">":
          return "&gt;";
        case "&":
          return "&amp;";
        case "'":
          return "&apos;";
        case '"':
          return "&quot;";
        default:
          return c;
      }
    });
  }
};
_init = __decoratorStart(_a);
__decorateElement(_init, 1, "getBucketInfo", _getBucketInfo_dec, _S3Bucket);
__decorateElement(_init, 1, "listObjects", _listObjects_dec, _S3Bucket);
__decorateElement(_init, 1, "generatePresignedUrl", _generatePresignedUrl_dec, _S3Bucket);
__decorateElement(_init, 1, "emptyBucket", _emptyBucket_dec, _S3Bucket);
__decorateElement(_init, 1, "getBucketStatistics", _getBucketStatistics_dec, _S3Bucket);
__decorateElement(_init, 1, "getWebsiteInfo", _getWebsiteInfo_dec, _S3Bucket);
__decoratorMetadata(_init, _S3Bucket);
__name(_S3Bucket, "S3Bucket");
var S3Bucket = _S3Bucket;



function main(def, state, ctx) {
  const entity = new S3Bucket(def, state, ctx);
  return entity.main(ctx);
}
