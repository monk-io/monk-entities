// Generated by MonkEC - targeting Goja runtime
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// input/aws-s3/base.ts
var base_exports = {};
__export(base_exports, {
  AWSS3Entity: () => AWSS3Entity
});
module.exports = __toCommonJS(base_exports);
var import_base = require("monkec/base");
var import_aws = __toESM(require("cloud/aws"));

// input/aws-s3/common.ts
function parseS3Error(response) {
  if (response.error) {
    return response.error;
  }
  if (response.body) {
    try {
      const errorCodeMatch = response.body.match(/<Code>(.*?)<\/Code>/);
      const errorMessageMatch = response.body.match(/<Message>(.*?)<\/Message>/);
      if (errorCodeMatch && errorMessageMatch) {
        return `${errorCodeMatch[1]}: ${errorMessageMatch[1]}`;
      }
      if (errorCodeMatch) {
        return errorCodeMatch[1];
      }
      if (errorMessageMatch) {
        return errorMessageMatch[1];
      }
    } catch (e) {
      return response.body;
    }
  }
  return `HTTP ${response.statusCode}: ${response.status || "Unknown error"}`;
}

// input/aws-s3/base.ts
var AWSS3Entity = class extends import_base.MonkEntity {
  get region() {
    return this.definition.region;
  }
  getBucketUrl(bucketName, path) {
    const basePath = path ? path.startsWith("?") ? path : `/${path}` : "";
    return `https://${bucketName}.s3.${this.region}.amazonaws.com${basePath}`;
  }
  bucketExists(bucketName) {
    try {
      const response = this.headBucket(bucketName);
      return response.statusCode === 200;
    } catch (error) {
      return false;
    }
  }
  headBucket(bucketName) {
    const url = this.getBucketUrl(bucketName);
    const response = import_aws.default.do(url, {
      method: "HEAD",
      service: "s3",
      region: this.region
    });
    if (response.statusCode !== 200 && response.statusCode !== 404) {
      const error = parseS3Error(response);
      throw new Error(`Failed to check bucket existence: ${error}`);
    }
    return response;
  }
  createBucket(bucketName) {
    const url = this.getBucketUrl(bucketName);
    let body = "";
    if (this.region !== "us-east-1") {
      body = `<CreateBucketConfiguration xmlns="http://s3.amazonaws.com/doc/2006-03-01/">
                <LocationConstraint>${this.region}</LocationConstraint>
            </CreateBucketConfiguration>`;
    }
    const response = import_aws.default.put(url, {
      service: "s3",
      region: this.region,
      headers: {
        "Content-Type": "application/xml"
      },
      body
    });
    if (response.statusCode !== 200) {
      const error = parseS3Error(response);
      throw new Error(`Failed to create bucket: ${error}`);
    }
    return response;
  }
  deleteBucket(bucketName) {
    const url = this.getBucketUrl(bucketName);
    const response = import_aws.default.delete(url, {
      service: "s3",
      region: this.region
    });
    if (response.statusCode !== 204 && response.statusCode !== 404) {
      const error = parseS3Error(response);
      throw new Error(`Failed to delete bucket: ${error}`);
    }
    return response;
  }
  getBucketLocation(bucketName) {
    const url = this.getBucketUrl(bucketName, "?location");
    const response = import_aws.default.get(url, {
      service: "s3",
      region: this.region
    });
    if (response.statusCode !== 200) {
      const error = parseS3Error(response);
      throw new Error(`Failed to get bucket location: ${error}`);
    }
    const locationMatch = response.body.match(/<LocationConstraint>(.*?)<\/LocationConstraint>/);
    return {
      LocationConstraint: locationMatch ? locationMatch[1] : void 0
    };
  }
  setBucketVersioning(bucketName, enabled) {
    const url = this.getBucketUrl(bucketName, "?versioning");
    const versioningConfig = `<VersioningConfiguration xmlns="http://s3.amazonaws.com/doc/2006-03-01/">
            <Status>${enabled ? "Enabled" : "Suspended"}</Status>
        </VersioningConfiguration>`;
    const response = import_aws.default.put(url, {
      service: "s3",
      region: this.region,
      headers: {
        "Content-Type": "application/xml"
      },
      body: versioningConfig
    });
    if (response.statusCode !== 200) {
      const error = parseS3Error(response);
      throw new Error(`Failed to set bucket versioning: ${error}`);
    }
    return response;
  }
  setBucketPublicAccessBlock(bucketName, publicReadAccess, publicWriteAccess) {
    const url = this.getBucketUrl(bucketName, "?publicAccessBlock");
    const publicAccessBlockConfig = `<PublicAccessBlockConfiguration xmlns="http://s3.amazonaws.com/doc/2006-03-01/">
            <BlockPublicAcls>${!publicWriteAccess}</BlockPublicAcls>
            <IgnorePublicAcls>${!publicWriteAccess}</IgnorePublicAcls>
            <BlockPublicPolicy>${!publicReadAccess}</BlockPublicPolicy>
            <RestrictPublicBuckets>${!publicReadAccess}</RestrictPublicBuckets>
        </PublicAccessBlockConfiguration>`;
    const response = import_aws.default.put(url, {
      service: "s3",
      region: this.region,
      headers: {
        "Content-Type": "application/xml"
      },
      body: publicAccessBlockConfig
    });
    if (response.statusCode !== 200) {
      const error = parseS3Error(response);
      throw new Error(`Failed to set bucket public access block: ${error}`);
    }
    return response;
  }
  setBucketCors(bucketName, corsRules) {
    const url = this.getBucketUrl(bucketName, "?cors");
    const corsRulesXml = corsRules.map((rule) => `
            <CORSRule>
                ${rule.allowed_methods.map((method) => `<AllowedMethod>${method}</AllowedMethod>`).join("")}
                ${rule.allowed_origins.map((origin) => `<AllowedOrigin>${origin}</AllowedOrigin>`).join("")}
                ${rule.allowed_headers ? rule.allowed_headers.map((header) => `<AllowedHeader>${header}</AllowedHeader>`).join("") : ""}
                ${rule.expose_headers ? rule.expose_headers.map((header) => `<ExposeHeader>${header}</ExposeHeader>`).join("") : ""}
                ${rule.max_age_seconds ? `<MaxAgeSeconds>${rule.max_age_seconds}</MaxAgeSeconds>` : ""}
            </CORSRule>
        `).join("");
    const corsConfig = `<CORSConfiguration xmlns="http://s3.amazonaws.com/doc/2006-03-01/">
            ${corsRulesXml}
        </CORSConfiguration>`;
    const response = import_aws.default.put(url, {
      service: "s3",
      region: this.region,
      headers: {
        "Content-Type": "application/xml"
      },
      body: corsConfig
    });
    if (response.statusCode !== 200) {
      const error = parseS3Error(response);
      throw new Error(`Failed to set bucket CORS: ${error}`);
    }
    return response;
  }
  setBucketTags(bucketName, tags) {
    const url = this.getBucketUrl(bucketName, "?tagging");
    const tagsXml = Object.entries(tags).map(([key, value]) => `
            <Tag>
                <Key>${key}</Key>
                <Value>${value}</Value>
            </Tag>
        `).join("");
    const taggingConfig = `<Tagging xmlns="http://s3.amazonaws.com/doc/2006-03-01/">
            <TagSet>
                ${tagsXml}
            </TagSet>
        </Tagging>`;
    const response = import_aws.default.put(url, {
      service: "s3",
      region: this.region,
      headers: {
        "Content-Type": "application/xml"
      },
      body: taggingConfig
    });
    if (response.statusCode !== 200) {
      const error = parseS3Error(response);
      throw new Error(`Failed to set bucket tags: ${error}`);
    }
    return response;
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  AWSS3Entity
});
