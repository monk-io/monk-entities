
// Generated by MonkEC - targeting Goja runtime
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __knownSymbol = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __decoratorStart = (base) => [, , , __create(base?.[__knownSymbol("metadata")] ?? null)];
var __decoratorStrings = ["class", "method", "getter", "setter", "accessor", "field", "value", "get", "set"];
var __expectFn = (fn) => fn !== void 0 && typeof fn !== "function" ? __typeError("Function expected") : fn;
var __decoratorContext = (kind, name, done, metadata, fns) => ({ kind: __decoratorStrings[kind], name, metadata, addInitializer: (fn) => done._ ? __typeError("Already initialized") : fns.push(__expectFn(fn || null)) });
var __decoratorMetadata = (array, target) => __defNormalProp(target, __knownSymbol("metadata"), array[3]);
var __runInitializers = (array, flags, self, value) => {
  for (var i = 0, fns = array[flags >> 1], n = fns && fns.length; i < n; i++) flags & 1 ? fns[i].call(self) : value = fns[i].call(self, value);
  return value;
};
var __decorateElement = (array, flags, name, decorators, target, extra) => {
  var fn, it, done, ctx, access, k = flags & 7, s = !!(flags & 8), p = !!(flags & 16);
  var j = k > 3 ? array.length + 1 : k ? s ? 1 : 2 : 0, key = __decoratorStrings[k + 5];
  var initializers = k > 3 && (array[j - 1] = []), extraInitializers = array[j] || (array[j] = []);
  var desc = k && (!p && !s && (target = target.prototype), k < 5 && (k > 3 || !p) && __getOwnPropDesc(k < 4 ? target : { get [name]() {
    return __privateGet(this, extra);
  }, set [name](x) {
    return __privateSet(this, extra, x);
  } }, name));
  k ? p && k < 4 && __name(extra, (k > 2 ? "set " : k > 1 ? "get " : "") + name) : __name(target, name);
  for (var i = decorators.length - 1; i >= 0; i--) {
    ctx = __decoratorContext(k, name, done = {}, array[3], extraInitializers);
    if (k) {
      ctx.static = s, ctx.private = p, access = ctx.access = { has: p ? (x) => __privateIn(target, x) : (x) => name in x };
      if (k ^ 3) access.get = p ? (x) => (k ^ 1 ? __privateGet : __privateMethod)(x, target, k ^ 4 ? extra : desc.get) : (x) => x[name];
      if (k > 2) access.set = p ? (x, y) => __privateSet(x, target, y, k ^ 4 ? extra : desc.set) : (x, y) => x[name] = y;
    }
    it = (0, decorators[i])(k ? k < 4 ? p ? extra : desc[key] : k > 4 ? void 0 : { get: desc.get, set: desc.set } : target, ctx), done._ = 1;
    if (k ^ 4 || it === void 0) __expectFn(it) && (k > 4 ? initializers.unshift(it) : k ? p ? extra = it : desc[key] = it : target = it);
    else if (typeof it !== "object" || it === null) __typeError("Object expected");
    else __expectFn(fn = it.get) && (desc.get = fn), __expectFn(fn = it.set) && (desc.set = fn), __expectFn(fn = it.init) && initializers.unshift(fn);
  }
  return k || __decoratorMetadata(array, target), desc && __defProp(target, name, desc), p ? k ^ 4 ? extra : desc : target;
};
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateIn = (member, obj) => Object(obj) !== obj ? __typeError('Cannot use the "in" operator on this value') : member.has(obj);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);

// input/aws-lambda/function.ts
const lambdaBase = require("aws-lambda/lambda-base");
const AWSLambdaEntity = lambdaBase.AWSLambdaEntity;
const base = require("monkec/base");
const action = base.action;
const cli = require("cli");
var _updateCode_dec, _getLogs_dec, _invoke_dec, _a, _init;
var _LambdaFunction = class _LambdaFunction extends (_a = AWSLambdaEntity, _invoke_dec = [action("invoke")], _getLogs_dec = [action("get-logs")], _updateCode_dec = [action("update-code")], _a) {
  constructor() {
    super(...arguments);
    __runInitializers(_init, 5, this);
  }
  getFunctionName() {
    return this.definition.function_name;
  }
  validateContainerImageConfiguration() {
    const packageType = this.definition.package_type || "Zip";
    if (packageType === "Image") {
      if (!this.definition.image_uri) {
        throw new Error("image_uri is required when package_type is 'Image'");
      }
      const ecrUriPattern = /^[0-9]{12}\.dkr\.ecr\.[a-z0-9\-]+\.amazonaws\.com\/[a-zA-Z0-9\-_\/]+:[a-zA-Z0-9\-_\.]+$/;
      if (!ecrUriPattern.test(this.definition.image_uri)) {
        throw new Error(
          `Invalid ECR image URI format: ${this.definition.image_uri}
Expected format: 123456789012.dkr.ecr.region.amazonaws.com/repository:tag
Note: AWS Lambda only supports ECR images, not Docker Hub or other registries`
        );
      }
      const uriRegionMatch = this.definition.image_uri.match(/\.dkr\.ecr\.([a-z0-9\-]+)\.amazonaws\.com\//);
      if (uriRegionMatch && uriRegionMatch[1] !== this.definition.region) {
        throw new Error(
          `ECR image region (${uriRegionMatch[1]}) does not match Lambda function region (${this.definition.region})
The ECR repository must be in the same region as the Lambda function`
        );
      }
    }
  }
  buildCreateFunctionRequest() {
    const packageType = this.definition.package_type || "Zip";
    if (packageType === "Image") {
      this.validateContainerImageConfiguration();
    } else {
      if (!this.definition.runtime) {
        throw new Error("runtime is required when package_type is 'Zip'");
      }
      if (!this.definition.handler) {
        throw new Error("handler is required when package_type is 'Zip'");
      }
    }
    const request = {
      FunctionName: this.definition.function_name,
      Role: this.definition.role,
      PackageType: packageType,
      Publish: this.definition.publish || false,
      Code: {}
    };
    if (packageType === "Image") {
      request.Code.ImageUri = this.definition.image_uri;
    } else {
      const zipContent = this.getLambdaZipFromBlob();
      request.Code.ZipFile = zipContent;
      request.Runtime = this.definition.runtime;
      request.Handler = this.definition.handler;
    }
    if (this.definition.summary) {
      request.Description = this.definition.summary;
    }
    if (this.definition.timeout) {
      request.Timeout = this.definition.timeout;
    }
    if (this.definition.memory_size) {
      request.MemorySize = this.definition.memory_size;
    }
    if (this.definition.environment) {
      request.Environment = {
        Variables: this.definition.environment.variables || {}
      };
    }
    if (this.definition.dead_letter_config) {
      request.DeadLetterConfig = {
        TargetArn: this.definition.dead_letter_config.target_arn
      };
    }
    if (this.definition.kms_key_arn) {
      request.KMSKeyArn = this.definition.kms_key_arn;
    }
    if (this.definition.tracing_config) {
      request.TracingConfig = {
        Mode: this.definition.tracing_config.mode
      };
    }
    if (this.definition.tags) {
      request.Tags = this.definition.tags;
    }
    if (this.definition.layers) {
      request.Layers = [...this.definition.layers];
    }
    if (this.definition.file_system_configs) {
      request.FileSystemConfigs = this.definition.file_system_configs.map((config) => ({
        Arn: config.arn,
        LocalMountPath: config.local_mount_path
      }));
    }
    if (this.definition.image_config) {
      request.ImageConfig = {
        EntryPoint: this.definition.image_config.entry_point ? [...this.definition.image_config.entry_point] : void 0,
        Command: this.definition.image_config.command ? [...this.definition.image_config.command] : void 0,
        WorkingDirectory: this.definition.image_config.working_directory
      };
    }
    if (this.definition.code_signing_config_arn) {
      request.CodeSigningConfigArn = this.definition.code_signing_config_arn;
    }
    if (this.definition.architectures) {
      request.Architectures = [...this.definition.architectures];
    }
    if (this.definition.ephemeral_storage) {
      request.EphemeralStorage = {
        Size: this.definition.ephemeral_storage.size
      };
    }
    if (this.definition.snap_start) {
      request.SnapStart = {
        ApplyOn: this.definition.snap_start.apply_on
      };
    }
    if (this.definition.vpc_config) {
      request.VpcConfig = {
        SubnetIds: this.definition.vpc_config.subnet_ids ? [...this.definition.vpc_config.subnet_ids] : void 0,
        SecurityGroupIds: this.definition.vpc_config.security_group_ids ? [...this.definition.vpc_config.security_group_ids] : void 0
      };
    }
    if (this.definition.logging_config) {
      request.LoggingConfig = {
        LogFormat: this.definition.logging_config.log_format,
        ApplicationLogLevel: this.definition.logging_config.application_log_level,
        SystemLogLevel: this.definition.logging_config.system_log_level,
        LogGroup: this.definition.logging_config.log_group
      };
    }
    return request;
  }
  buildUpdateConfigurationRequest() {
    const packageType = this.definition.package_type || "Zip";
    const config = {
      FunctionName: this.definition.function_name
    };
    if (packageType === "Zip") {
      if (this.definition.runtime !== void 0) {
        config.Runtime = this.definition.runtime;
      }
      if (this.definition.handler !== void 0) {
        config.Handler = this.definition.handler;
      }
    }
    if (this.definition.summary !== void 0) {
      config.Description = this.definition.summary;
    }
    if (this.definition.timeout !== void 0) {
      config.Timeout = this.definition.timeout;
    }
    if (this.definition.memory_size !== void 0) {
      config.MemorySize = this.definition.memory_size;
    }
    if (this.definition.environment !== void 0) {
      config.Environment = {
        Variables: this.definition.environment.variables || {}
      };
    }
    if (this.definition.dead_letter_config !== void 0) {
      config.DeadLetterConfig = {
        TargetArn: this.definition.dead_letter_config.target_arn
      };
    }
    if (this.definition.kms_key_arn !== void 0) {
      config.KMSKeyArn = this.definition.kms_key_arn;
    }
    if (this.definition.tracing_config !== void 0) {
      config.TracingConfig = {
        Mode: this.definition.tracing_config.mode
      };
    }
    if (this.definition.layers !== void 0) {
      config.Layers = this.definition.layers ? [...this.definition.layers] : void 0;
    }
    if (this.definition.file_system_configs !== void 0) {
      config.FileSystemConfigs = this.definition.file_system_configs.map((config2) => ({
        Arn: config2.arn,
        LocalMountPath: config2.local_mount_path
      }));
    }
    if (this.definition.image_config !== void 0) {
      config.ImageConfig = {
        EntryPoint: this.definition.image_config.entry_point ? [...this.definition.image_config.entry_point] : void 0,
        Command: this.definition.image_config.command ? [...this.definition.image_config.command] : void 0,
        WorkingDirectory: this.definition.image_config.working_directory
      };
    }
    if (this.definition.ephemeral_storage !== void 0) {
      config.EphemeralStorage = {
        Size: this.definition.ephemeral_storage.size
      };
    }
    if (this.definition.snap_start !== void 0) {
      config.SnapStart = {
        ApplyOn: this.definition.snap_start.apply_on
      };
    }
    if (this.definition.vpc_config !== void 0) {
      config.VpcConfig = {
        SubnetIds: this.definition.vpc_config.subnet_ids ? [...this.definition.vpc_config.subnet_ids] : void 0,
        SecurityGroupIds: this.definition.vpc_config.security_group_ids ? [...this.definition.vpc_config.security_group_ids] : void 0
      };
    }
    if (this.definition.logging_config !== void 0) {
      config.LoggingConfig = {
        LogFormat: this.definition.logging_config.log_format,
        ApplicationLogLevel: this.definition.logging_config.application_log_level,
        SystemLogLevel: this.definition.logging_config.system_log_level,
        LogGroup: this.definition.logging_config.log_group
      };
    }
    return config;
  }
  updateStateFromResponse(response) {
    const config = response.Configuration || response;
    this.state = {
      ...this.state,
      function_name: config.FunctionName,
      function_arn: config.FunctionArn,
      code_sha256: config.CodeSha256,
      last_modified: config.LastModified,
      state: config.State,
      state_reason: config.StateReason,
      runtime: config.Runtime,
      role: config.Role,
      handler: config.Handler,
      timeout: config.Timeout,
      memory_size: config.MemorySize,
      code_size: config.CodeSize,
      version: config.Version,
      last_update_status: config.LastUpdateStatus,
      revision_id: config.RevisionId
    };
  }
  create() {
    const existingFunction = this.checkFunctionExists(this.definition.function_name);
    if (existingFunction) {
      cli.output(`Lambda function ${this.definition.function_name} already exists, marking as existing`);
      this.updateStateFromResponse(existingFunction);
      this.state.existing = true;
      return;
    }
    const createRequest = this.buildCreateFunctionRequest();
    try {
      const response = this.makeAWSRequest("POST", "/2015-03-31/functions", createRequest);
      this.updateStateFromResponse(response);
      this.state.existing = false;
    } catch (error) {
      throw new Error(`Failed to create Lambda function ${this.definition.function_name}: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  update() {
    if (!this.state.function_name) {
      cli.output("Function does not exist, creating instead");
      this.create();
      return;
    }
    try {
      const packageType = this.definition.package_type || "Zip";
      let updateCodeRequest;
      if (packageType === "Image") {
        if (!this.definition.image_uri) {
          throw new Error("image_uri is required for container image updates");
        }
        updateCodeRequest = {
          ImageUri: this.definition.image_uri
        };
      } else {
        const zipContent = this.getLambdaZipFromBlob();
        updateCodeRequest = {
          ZipFile: zipContent
        };
      }
      this.makeAWSRequest(
        "PUT",
        `/2015-03-31/functions/${encodeURIComponent(this.definition.function_name)}/code`,
        updateCodeRequest
      );
      if (!this.waitForFunctionState(this.definition.function_name, "Active")) {
        throw new Error("Function did not become active after code update");
      }
      const configRequest = this.buildUpdateConfigurationRequest();
      const maxRetries = 5;
      let configResponse;
      for (let attempt = 0; attempt < maxRetries; attempt++) {
        try {
          configResponse = this.makeAWSRequest(
            "PUT",
            `/2015-03-31/functions/${encodeURIComponent(this.definition.function_name)}/configuration`,
            configRequest
          );
          break;
        } catch (error) {
          const isConflictError = error instanceof Error && (error.message.includes("409") || error.message.includes("ResourceConflictException") || error.message.includes("update is in progress"));
          if (isConflictError && attempt < maxRetries - 1) {
            const start = Date.now();
            while (Date.now() - start < 1e4) {
            }
            if (!this.waitForFunctionState(this.definition.function_name, "Active")) {
              throw new Error("Function became unavailable during retry");
            }
            continue;
          }
          throw error;
        }
      }
      if (configResponse) {
        this.updateStateFromResponse(configResponse);
      }
    } catch (error) {
      throw new Error(`Failed to update Lambda function ${this.definition.function_name}: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  delete() {
    if (!this.state.function_name) {
      cli.output("Lambda function does not exist, nothing to delete");
      return;
    }
    this.deleteLambdaFunction(this.definition.function_name);
  }
  checkReadiness() {
    if (!this.state.function_name) {
      return false;
    }
    try {
      const response = this.checkFunctionExists(this.definition.function_name);
      if (!response) {
        return false;
      }
      const config = response.Configuration || response;
      const isActive = config.State === "Active";
      const updateSuccessful = config.LastUpdateStatus === "Successful";
      if (isActive && updateSuccessful) {
        this.updateStateFromResponse(response);
        return true;
      }
      return false;
    } catch (error) {
      return false;
    }
  }
  checkLiveness() {
    return this.checkReadiness();
  }
  invoke(args) {
    if (!this.state.function_name) {
      throw new Error("Function does not exist, cannot invoke");
    }
    const payload = args?.payload || "{}";
    const invocationType = args?.invocationType || "RequestResponse";
    try {
      const response = this.makeAWSRequest(
        "POST",
        `/2015-03-31/functions/${encodeURIComponent(this.definition.function_name)}/invocations?InvocationType=${invocationType}`,
        payload
      );
      if (response && typeof response === "object") {
        cli.output(`Response: ${JSON.stringify(response, null, 2)}`);
      }
    } catch (error) {
      throw new Error(`Failed to invoke function: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  getLogs(_args) {
    if (!this.state.function_name) {
      throw new Error("Function does not exist, cannot get logs");
    }
    const logGroupName = `/aws/lambda/${this.definition.function_name}`;
    cli.output(`Lambda function logs are available in CloudWatch Log Group: ${logGroupName}`);
    cli.output("Use AWS CLI or Console to view logs:");
    cli.output(`aws logs describe-log-streams --log-group-name "${logGroupName}"`);
  }
  updateCode(_args) {
    if (!this.state.function_name) {
      throw new Error("Function does not exist, cannot update code");
    }
    try {
      const packageType = this.definition.package_type || "Zip";
      let updateCodeRequest;
      if (packageType === "Image") {
        if (!this.definition.image_uri) {
          throw new Error("image_uri is required for container image updates");
        }
        updateCodeRequest = {
          ImageUri: this.definition.image_uri
        };
        cli.output(`Updating Lambda function code with container image: ${this.definition.image_uri}`);
      } else {
        const zipContent = this.getLambdaZipFromBlob();
        updateCodeRequest = {
          ZipFile: zipContent
        };
        cli.output(`Updating Lambda function code from blob: ${this.definition.blob_name}`);
      }
      const response = this.makeAWSRequest(
        "PUT",
        `/2015-03-31/functions/${encodeURIComponent(this.definition.function_name)}/code`,
        updateCodeRequest
      );
      this.updateStateFromResponse(response);
      cli.output("Function code updated successfully");
    } catch (error) {
      throw new Error(`Failed to update function code: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
};
_init = __decoratorStart(_a);
__decorateElement(_init, 1, "invoke", _invoke_dec, _LambdaFunction);
__decorateElement(_init, 1, "getLogs", _getLogs_dec, _LambdaFunction);
__decorateElement(_init, 1, "updateCode", _updateCode_dec, _LambdaFunction);
__decoratorMetadata(_init, _LambdaFunction);
__name(_LambdaFunction, "LambdaFunction");
// Customize readiness check parameters
__publicField(_LambdaFunction, "readiness", { period: 10, initialDelay: 5, attempts: 30 });
var LambdaFunction = _LambdaFunction;



function main(def, state, ctx) {
  const entity = new LambdaFunction(def, state, ctx);
  return entity.main(ctx);
}
