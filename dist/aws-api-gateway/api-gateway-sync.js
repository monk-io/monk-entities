
// Generated by MonkEC - targeting Goja runtime
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __knownSymbol = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __decoratorStart = (base) => [, , , __create(base?.[__knownSymbol("metadata")] ?? null)];
var __decoratorStrings = ["class", "method", "getter", "setter", "accessor", "field", "value", "get", "set"];
var __expectFn = (fn) => fn !== void 0 && typeof fn !== "function" ? __typeError("Function expected") : fn;
var __decoratorContext = (kind, name, done, metadata, fns) => ({ kind: __decoratorStrings[kind], name, metadata, addInitializer: (fn) => done._ ? __typeError("Already initialized") : fns.push(__expectFn(fn || null)) });
var __decoratorMetadata = (array, target) => __defNormalProp(target, __knownSymbol("metadata"), array[3]);
var __runInitializers = (array, flags, self, value) => {
  for (var i = 0, fns = array[flags >> 1], n = fns && fns.length; i < n; i++) flags & 1 ? fns[i].call(self) : value = fns[i].call(self, value);
  return value;
};
var __decorateElement = (array, flags, name, decorators, target, extra) => {
  var fn, it, done, ctx, access, k = flags & 7, s = !!(flags & 8), p = !!(flags & 16);
  var j = k > 3 ? array.length + 1 : k ? s ? 1 : 2 : 0, key = __decoratorStrings[k + 5];
  var initializers = k > 3 && (array[j - 1] = []), extraInitializers = array[j] || (array[j] = []);
  var desc = k && (!p && !s && (target = target.prototype), k < 5 && (k > 3 || !p) && __getOwnPropDesc(k < 4 ? target : { get [name]() {
    return __privateGet(this, extra);
  }, set [name](x) {
    return __privateSet(this, extra, x);
  } }, name));
  k ? p && k < 4 && __name(extra, (k > 2 ? "set " : k > 1 ? "get " : "") + name) : __name(target, name);
  for (var i = decorators.length - 1; i >= 0; i--) {
    ctx = __decoratorContext(k, name, done = {}, array[3], extraInitializers);
    if (k) {
      ctx.static = s, ctx.private = p, access = ctx.access = { has: p ? (x) => __privateIn(target, x) : (x) => name in x };
      if (k ^ 3) access.get = p ? (x) => (k ^ 1 ? __privateGet : __privateMethod)(x, target, k ^ 4 ? extra : desc.get) : (x) => x[name];
      if (k > 2) access.set = p ? (x, y) => __privateSet(x, target, y, k ^ 4 ? extra : desc.set) : (x, y) => x[name] = y;
    }
    it = (0, decorators[i])(k ? k < 4 ? p ? extra : desc[key] : k > 4 ? void 0 : { get: desc.get, set: desc.set } : target, ctx), done._ = 1;
    if (k ^ 4 || it === void 0) __expectFn(it) && (k > 4 ? initializers.unshift(it) : k ? p ? extra = it : desc[key] = it : target = it);
    else if (typeof it !== "object" || it === null) __typeError("Object expected");
    else __expectFn(fn = it.get) && (desc.get = fn), __expectFn(fn = it.set) && (desc.set = fn), __expectFn(fn = it.init) && initializers.unshift(fn);
  }
  return k || __decoratorMetadata(array, target), desc && __defProp(target, name, desc), p ? k ^ 4 ? extra : desc : target;
};
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateIn = (member, obj) => Object(obj) !== obj ? __typeError('Cannot use the "in" operator on this value') : member.has(obj);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);

// input/aws-api-gateway/apiGateway.ts
const base = require("aws-api-gateway/base");
const AWSAPIGatewayEntity = base.AWSAPIGatewayEntity;
const base = require("monkec/base");
const action = base.action;
const cli = require("cli");
var _listRoutes_dec, _getEndpoint_dec, _syncRoutes_dec, _a, _init;
var _APIGateway = class _APIGateway extends (_a = AWSAPIGatewayEntity, _syncRoutes_dec = [action("sync-routes")], _getEndpoint_dec = [action("get-endpoint")], _listRoutes_dec = [action("list-routes")], _a) {
  constructor() {
    super(...arguments);
    __runInitializers(_init, 5, this);
  }
  getApiName() {
    return this.definition.name;
  }
  getConfiguredRoutes() {
    const defAny = this.definition;
    const raw = defAny?.routes;
    const list = [];
    if (raw) {
      if (Array.isArray(raw)) {
        list.push(...raw);
      } else if (typeof raw === "object") {
        list.push(...Object.values(raw));
      }
    }
    if (defAny && typeof defAny === "object") {
      const routeKeys = Object.keys(defAny).filter((k) => /^routes!\d+$/.test(k)).sort((a, b) => parseInt(a.split("!")[1]) - parseInt(b.split("!")[1]));
      for (const k of routeKeys) {
        list.push(defAny[k]);
      }
    }
    if (list.length === 0) {
      cli.output("[aws-api-gateway] routes not present in definition");
      return [];
    }
    const normalized = [];
    for (const item of list) {
      if (!item || typeof item !== "object") continue;
      const path = item.path ?? item.Path ?? item.route ?? item.Route ?? item.uri;
      let method = item.method ?? item.Method ?? item.httpMethod ?? item.verb;
      const integration = item.integration ?? item.Integration ?? item.target;
      const integrationFunction = integration?.function ?? integration?.Function ?? integration?.lambdaArn ?? integration?.lambda ?? integration?.arn;
      if (typeof path === "string" && path && typeof method === "string" && integrationFunction) {
        normalized.push({
          path,
          method: String(method).toUpperCase(),
          integration: { type: "lambda", function: String(integrationFunction) }
        });
      }
    }
    cli.output(`[aws-api-gateway] normalized routes count: ${normalized.length}`);
    return normalized;
  }
  findApiByName(name) {
    const res = this.makeV2Request("GET", "/v2/apis");
    const items = res.items || res.Items || [];
    const api = items.find((i) => (i.Name || i.name) === name);
    return api?.ApiId || api?.apiId || null;
  }
  createApi() {
    const isWebSocket = String(this.definition.protocol_type).toUpperCase() === "WEBSOCKET";
    const body = {
      name: this.definition.name,
      protocolType: String(this.definition.protocol_type).toUpperCase()
    };
    if (this.definition.tags) {
      body.tags = this.definition.tags;
    }
    if (isWebSocket) {
      body.routeSelectionExpression = "$request.body.action";
    }
    const res = this.makeV2Request("POST", "/v2/apis", body);
    const rawId = res.ApiId ?? res.apiId;
    const apiId = typeof rawId === "string" ? rawId : rawId ? String(rawId) : void 0;
    if (!apiId) {
      throw new Error("[aws-api-gateway] CreateApi did not return ApiId");
    }
    const endpointVal = res.ApiEndpoint ?? res.apiEndpoint;
    const endpoint = endpointVal ? String(endpointVal) : void 0;
    return { apiId, endpoint };
  }
  getIntegrationId(apiId, integrationUri) {
    const res = this.makeV2Request("GET", `/v2/apis/${encodeURIComponent(apiId)}/integrations`);
    const items = res.items || res.Items || [];
    const match = items.find((i) => (i.IntegrationUri || i.integrationUri) === integrationUri);
    const id = match ? match.IntegrationId || match.integrationId : void 0;
    cli.output(`[aws-api-gateway] lookup integration: ${match ? "FOUND" : "NOT FOUND"}`);
    return id ? String(id) : null;
  }
  routeExists(apiId, routeKey) {
    const res = this.makeV2Request("GET", `/v2/apis/${encodeURIComponent(apiId)}/routes`);
    const items = res.items || res.Items || [];
    const exists = items.some((i) => (i.RouteKey || i.routeKey) === routeKey);
    cli.output(`[aws-api-gateway] route check '${routeKey}': ${exists ? "EXISTS" : "MISSING"} (total: ${items.length})`);
    return exists;
  }
  logExistingRoutes(apiId, context) {
    try {
      const res = this.makeV2Request("GET", `/v2/apis/${encodeURIComponent(apiId)}/routes`);
      const items = res.items || res.Items || [];
      const keys = items.map((i) => i.RouteKey || i.routeKey);
      cli.output(`[aws-api-gateway] existing routes (${context}): ${items.length} -> ${JSON.stringify(keys)}`);
    } catch (_e) {
      cli.output(`[aws-api-gateway] failed to list routes (${context})`);
    }
  }
  ensureRouteAndIntegration(apiId, route) {
    const routeKey = `${route.method.toUpperCase()} ${route.path}`;
    const lambdaArn = route.integration.function;
    const integrationUri = `arn:aws:apigateway:${this.definition.region}:lambda:path/2015-03-31/functions/${lambdaArn}/invocations`;
    cli.output(`[aws-api-gateway] ensure route '${routeKey}' with integration URI: ${integrationUri}`);
    let integrationId = null;
    try {
      cli.output(`[aws-api-gateway] creating integration...`);
      const intRes = this.makeV2Request("POST", `/v2/apis/${encodeURIComponent(apiId)}/integrations`, {
        integrationType: "AWS_PROXY",
        integrationUri,
        payloadFormatVersion: "2.0",
        integrationMethod: "POST"
      });
      integrationId = String(intRes.IntegrationId || intRes.integrationId);
      cli.output(`[aws-api-gateway] integration created: ${integrationId}`);
    } catch (e) {
      const maybe = this.getIntegrationId(apiId, integrationUri);
      if (!maybe) throw e;
      integrationId = maybe;
      cli.output(`[aws-api-gateway] integration reused: ${integrationId}`);
    }
    if (!this.routeExists(apiId, routeKey)) {
      cli.output(`[aws-api-gateway] creating route '${routeKey}' -> integrations/${integrationId}`);
      this.makeV2Request("POST", `/v2/apis/${encodeURIComponent(apiId)}/routes`, {
        routeKey,
        target: `integrations/${integrationId}`
      });
      cli.output(`[aws-api-gateway] route created: ${routeKey}`);
    } else {
      cli.output(`[aws-api-gateway] route already exists: ${routeKey}`);
    }
  }
  createDefaultStage(apiId) {
    try {
      this.makeV2Request("POST", `/v2/apis/${encodeURIComponent(apiId)}/stages`, {
        stageName: "$default",
        autoDeploy: true
      });
    } catch (_e) {
    }
  }
  logDefinition() {
    try {
      cli.output(`[aws-api-gateway] definition summary: ${JSON.stringify(this.definition)}`);
    } catch (_e) {
    }
  }
  create() {
    const existingId = this.findApiByName(this.getApiName());
    this.logDefinition();
    if (existingId) {
      this.state.existing = true;
      this.state.api_id = existingId;
      this.state.name = this.definition.name;
      this.state.protocol_type = this.definition.protocol_type;
    } else {
      const { apiId, endpoint } = this.createApi();
      this.state.existing = false;
      this.state.api_id = apiId;
      this.state.api_endpoint = endpoint;
      this.state.name = this.definition.name;
      this.state.protocol_type = this.definition.protocol_type;
    }
    cli.output(`[aws-api-gateway] configured routes count: ${this.definition.routes ? this.definition.routes.length : 0}`);
    const routes = this.getConfiguredRoutes();
    cli.output(`[aws-api-gateway] configured routes count: ${routes.length}`);
    if (routes.length > 0) {
      for (const r of routes) {
        if (r.integration.type !== "lambda") continue;
        this.ensureRouteAndIntegration(this.state.api_id, r);
      }
    }
    this.createDefaultStage(this.state.api_id);
    this.logExistingRoutes(this.state.api_id, "after-create");
  }
  syncRoutes() {
    if (!this.state.api_id) {
      return;
    }
    const routes = this.getConfiguredRoutes();
    cli.output(`[aws-api-gateway] configured routes count: ${routes.length}`);
    if (routes.length > 0) {
      for (const r of routes) {
        if (r.integration.type !== "lambda") continue;
        this.ensureRouteAndIntegration(this.state.api_id, r);
      }
    }
    this.createDefaultStage(this.state.api_id);
    this.logExistingRoutes(this.state.api_id, "after-sync");
  }
  start() {
    if (!this.state.api_id) {
      return;
    }
    const routes = this.getConfiguredRoutes();
    cli.output(`[aws-api-gateway] configured routes count: ${routes.length}`);
    if (routes.length > 0) {
      for (const r of routes) {
        if (r.integration.type !== "lambda") continue;
        this.ensureRouteAndIntegration(this.state.api_id, r);
      }
    }
    this.createDefaultStage(this.state.api_id);
    this.logExistingRoutes(this.state.api_id, "after-start");
  }
  stop() {
  }
  update() {
    if (!this.state.api_id) {
      this.create();
      return;
    }
    const apiId = this.state.api_id;
    const routes = this.getConfiguredRoutes();
    cli.output(`[aws-api-gateway] configured routes count: ${routes.length}`);
    if (routes.length > 0) {
      for (const r of routes) {
        if (r.integration.type !== "lambda") continue;
        this.ensureRouteAndIntegration(apiId, r);
      }
    }
  }
  delete() {
    if (!this.state.api_id) return;
    try {
      this.makeV2Request("DELETE", `/v2/apis/${encodeURIComponent(this.state.api_id)}`);
    } catch (_e) {
    }
    this.state.api_id = void 0;
    this.state.api_endpoint = void 0;
    this.state.existing = false;
  }
  checkReadiness() {
    if (!this.state.api_id) return false;
    try {
      const res = this.makeV2Request("GET", `/v2/apis/${encodeURIComponent(this.state.api_id)}`);
      const hasEndpoint = !!res.ApiEndpoint;
      if (hasEndpoint) this.state.api_endpoint = res.ApiEndpoint;
      return hasEndpoint;
    } catch (_e) {
      return false;
    }
  }
  checkLiveness() {
    const id = this.state.api_id;
    if (!id) {
      throw new Error("API ID is missing");
    }
    const res = this.makeV2Request("GET", `/v2/apis/${encodeURIComponent(id)}`);
    const endpoint = res.ApiEndpoint ?? res.apiEndpoint;
    if (!endpoint) {
      throw new Error(`API ${id} has no endpoint yet`);
    }
    return true;
  }
  getEndpoint() {
  }
  listRoutes() {
    if (!this.state.api_id) {
      cli.output("[aws-api-gateway] no api_id in state");
      return;
    }
    const res = this.makeV2Request("GET", `/v2/apis/${encodeURIComponent(this.state.api_id)}/routes`);
    const items = res.items || res.Items || [];
    const keys = items.map((i) => i.RouteKey || i.routeKey);
    cli.output(`[aws-api-gateway] routes (${this.state.api_id}): ${items.length}`);
    cli.output(JSON.stringify(keys, null, 2));
  }
};
_init = __decoratorStart(_a);
__decorateElement(_init, 1, "syncRoutes", _syncRoutes_dec, _APIGateway);
__decorateElement(_init, 1, "getEndpoint", _getEndpoint_dec, _APIGateway);
__decorateElement(_init, 1, "listRoutes", _listRoutes_dec, _APIGateway);
__decoratorMetadata(_init, _APIGateway);
__name(_APIGateway, "APIGateway");
var APIGateway = _APIGateway;



function main(def, state, ctx) {
  const entity = new APIGateway(def, state, ctx);
  return entity.main(ctx);
}
