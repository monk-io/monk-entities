// Generated by MonkEC - targeting Goja runtime
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// input/aws-dynamo-db/common.ts
var common_exports = {};
__export(common_exports, {
  DEFAULT_PAY_PER_REQUEST_CONFIG: () => DEFAULT_PAY_PER_REQUEST_CONFIG,
  DEFAULT_PROVISIONED_CONFIG: () => DEFAULT_PROVISIONED_CONFIG,
  convertTagsToArray: () => convertTagsToArray,
  convertTagsToObject: () => convertTagsToObject,
  parseDynamoDBError: () => parseDynamoDBError,
  validateAttributeName: () => validateAttributeName,
  validateBillingMode: () => validateBillingMode,
  validateKeySchemaAttributes: () => validateKeySchemaAttributes,
  validateTableName: () => validateTableName
});
module.exports = __toCommonJS(common_exports);
function validateTableName(name) {
  if (!name || typeof name !== "string") {
    return false;
  }
  if (name.length < 3 || name.length > 255) {
    return false;
  }
  const validPattern = /^[a-zA-Z0-9_.-]+$/;
  return validPattern.test(name);
}
function validateAttributeName(name) {
  if (!name || typeof name !== "string") {
    return false;
  }
  if (name.length < 1 || name.length > 255) {
    return false;
  }
  return true;
}
function validateBillingMode(billingMode, provisionedThroughput) {
  if (!billingMode) {
    billingMode = "PAY_PER_REQUEST";
  }
  if (billingMode === "PROVISIONED") {
    return !!(provisionedThroughput?.ReadCapacityUnits && provisionedThroughput?.WriteCapacityUnits);
  }
  return billingMode === "PAY_PER_REQUEST";
}
function convertTagsToArray(tags) {
  if (!tags || Object.keys(tags).length === 0) {
    return void 0;
  }
  return Object.entries(tags).map(([key, value]) => ({
    Key: key,
    Value: value
  }));
}
function convertTagsToObject(tags) {
  if (!tags || tags.length === 0) {
    return void 0;
  }
  const result = {};
  for (const tag of tags) {
    result[tag.Key] = tag.Value;
  }
  return result;
}
var DEFAULT_PAY_PER_REQUEST_CONFIG = {
  BillingMode: "PAY_PER_REQUEST",
  DeletionProtectionEnabled: false
};
var DEFAULT_PROVISIONED_CONFIG = {
  BillingMode: "PROVISIONED",
  ProvisionedThroughput: {
    ReadCapacityUnits: 5,
    WriteCapacityUnits: 5
  },
  DeletionProtectionEnabled: false
};
function validateKeySchemaAttributes(attributeDefinitions, keySchema, globalSecondaryIndexes, localSecondaryIndexes) {
  console.log("[DEBUG] validateKeySchemaAttributes called with:");
  console.log("  attributeDefinitions:", JSON.stringify(attributeDefinitions, null, 2));
  console.log("  keySchema:", JSON.stringify(keySchema, null, 2));
  console.log("  globalSecondaryIndexes:", JSON.stringify(globalSecondaryIndexes, null, 2));
  console.log("  localSecondaryIndexes:", JSON.stringify(localSecondaryIndexes, null, 2));
  const definedAttributeNames = attributeDefinitions.map((attr) => attr.AttributeName);
  const uniqueDefinedAttributes = new Set(definedAttributeNames);
  const duplicateAttributes = definedAttributeNames.filter(
    (name, index) => definedAttributeNames.indexOf(name) !== index
  );
  const requiredAttributes = /* @__PURE__ */ new Set();
  keySchema.forEach((key) => requiredAttributes.add(key.AttributeName));
  console.log("  After main table KeySchema, required attributes:", Array.from(requiredAttributes));
  if (globalSecondaryIndexes) {
    globalSecondaryIndexes.forEach((gsi) => {
      if (gsi.KeySchema && Array.isArray(gsi.KeySchema)) {
        gsi.KeySchema.forEach((key) => requiredAttributes.add(key.AttributeName));
      }
    });
  }
  console.log("  After GSI KeySchemas, required attributes:", Array.from(requiredAttributes));
  if (localSecondaryIndexes) {
    localSecondaryIndexes.forEach((lsi) => {
      if (lsi.KeySchema && Array.isArray(lsi.KeySchema)) {
        lsi.KeySchema.forEach((key) => requiredAttributes.add(key.AttributeName));
      }
    });
  }
  console.log("  After LSI KeySchemas, required attributes:", Array.from(requiredAttributes));
  const missingAttributes = Array.from(requiredAttributes).filter((attr) => !uniqueDefinedAttributes.has(attr));
  const extraAttributes = Array.from(uniqueDefinedAttributes).filter((attr) => !requiredAttributes.has(attr));
  console.log("  Missing attributes:", missingAttributes);
  console.log("  Extra attributes (not used in any KeySchema):", extraAttributes);
  console.log("  Duplicate attributes:", duplicateAttributes);
  const isValid = missingAttributes.length === 0 && duplicateAttributes.length === 0;
  return {
    isValid,
    missingAttributes,
    extraAttributes,
    duplicateAttributes
  };
}
function parseDynamoDBError(errorBody) {
  try {
    const parsed = JSON.parse(errorBody);
    return {
      type: parsed.__type || "UnknownError",
      message: parsed.message || "Unknown error occurred"
    };
  } catch (e) {
    return {
      type: "ParseError",
      message: "Could not parse error response"
    };
  }
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  DEFAULT_PAY_PER_REQUEST_CONFIG,
  DEFAULT_PROVISIONED_CONFIG,
  convertTagsToArray,
  convertTagsToObject,
  parseDynamoDBError,
  validateAttributeName,
  validateBillingMode,
  validateKeySchemaAttributes,
  validateTableName
});
