
// Generated by MonkEC - targeting Goja runtime
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __knownSymbol = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __decoratorStart = (base) => [, , , __create(base?.[__knownSymbol("metadata")] ?? null)];
var __decoratorStrings = ["class", "method", "getter", "setter", "accessor", "field", "value", "get", "set"];
var __expectFn = (fn) => fn !== void 0 && typeof fn !== "function" ? __typeError("Function expected") : fn;
var __decoratorContext = (kind, name, done, metadata, fns) => ({ kind: __decoratorStrings[kind], name, metadata, addInitializer: (fn) => done._ ? __typeError("Already initialized") : fns.push(__expectFn(fn || null)) });
var __decoratorMetadata = (array, target) => __defNormalProp(target, __knownSymbol("metadata"), array[3]);
var __runInitializers = (array, flags, self, value) => {
  for (var i = 0, fns = array[flags >> 1], n = fns && fns.length; i < n; i++) flags & 1 ? fns[i].call(self) : value = fns[i].call(self, value);
  return value;
};
var __decorateElement = (array, flags, name, decorators, target, extra) => {
  var fn, it, done, ctx, access, k = flags & 7, s = !!(flags & 8), p = !!(flags & 16);
  var j = k > 3 ? array.length + 1 : k ? s ? 1 : 2 : 0, key = __decoratorStrings[k + 5];
  var initializers = k > 3 && (array[j - 1] = []), extraInitializers = array[j] || (array[j] = []);
  var desc = k && (!p && !s && (target = target.prototype), k < 5 && (k > 3 || !p) && __getOwnPropDesc(k < 4 ? target : { get [name]() {
    return __privateGet(this, extra);
  }, set [name](x) {
    return __privateSet(this, extra, x);
  } }, name));
  k ? p && k < 4 && __name(extra, (k > 2 ? "set " : k > 1 ? "get " : "") + name) : __name(target, name);
  for (var i = decorators.length - 1; i >= 0; i--) {
    ctx = __decoratorContext(k, name, done = {}, array[3], extraInitializers);
    if (k) {
      ctx.static = s, ctx.private = p, access = ctx.access = { has: p ? (x) => __privateIn(target, x) : (x) => name in x };
      if (k ^ 3) access.get = p ? (x) => (k ^ 1 ? __privateGet : __privateMethod)(x, target, k ^ 4 ? extra : desc.get) : (x) => x[name];
      if (k > 2) access.set = p ? (x, y) => __privateSet(x, target, y, k ^ 4 ? extra : desc.set) : (x, y) => x[name] = y;
    }
    it = (0, decorators[i])(k ? k < 4 ? p ? extra : desc[key] : k > 4 ? void 0 : { get: desc.get, set: desc.set } : target, ctx), done._ = 1;
    if (k ^ 4 || it === void 0) __expectFn(it) && (k > 4 ? initializers.unshift(it) : k ? p ? extra = it : desc[key] = it : target = it);
    else if (typeof it !== "object" || it === null) __typeError("Object expected");
    else __expectFn(fn = it.get) && (desc.get = fn), __expectFn(fn = it.set) && (desc.set = fn), __expectFn(fn = it.init) && initializers.unshift(fn);
  }
  return k || __decoratorMetadata(array, target), desc && __defProp(target, name, desc), p ? k ^ 4 ? extra : desc : target;
};
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateIn = (member, obj) => Object(obj) !== obj ? __typeError('Cannot use the "in" operator on this value') : member.has(obj);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);

// input/digitalocean-database/database.ts
const base = require("monkec/base");
const action = base.action;
const doProviderBase = require("digitalocean-database/do-provider-base");
const DOProviderEntity = doProviderBase.DOProviderEntity;
const common = require("digitalocean-database/common");
const validateDatabaseEngine = common.validateDatabaseEngine;
const validateDatabaseRegion = common.validateDatabaseRegion;
const validateDatabaseSize = common.validateDatabaseSize;
const cli = require("cli");
var _resizeCluster_dec, _getConnectionInfo_dec, _deleteDatabase_dec, _createDatabase_dec, _listDatabases_dec, _getDatabase_dec, _a, _init;
var _DigitalOceanDatabase = class _DigitalOceanDatabase extends (_a = DOProviderEntity, _getDatabase_dec = [action("getDatabase")], _listDatabases_dec = [action("listDatabases")], _createDatabase_dec = [action("createDatabase")], _deleteDatabase_dec = [action("deleteDatabase")], _getConnectionInfo_dec = [action("getConnectionInfo")], _resizeCluster_dec = [action("resizeCluster")], _a) {
  constructor() {
    super(...arguments);
    __runInitializers(_init, 5, this);
  }
  getEntityName() {
    return `DigitalOcean Database: ${this.definition.name}`;
  }
  create() {
    cli.output(`\u{1F680} Creating DigitalOcean database cluster: ${this.definition.name}`);
    const validatedEngine = validateDatabaseEngine(this.definition.engine);
    const validatedRegion = validateDatabaseRegion(this.definition.region);
    const validatedSize = validateDatabaseSize(this.definition.size);
    const existingDatabase = this.findExistingDatabase();
    if (existingDatabase) {
      cli.output(`\u2705 Database cluster ${this.definition.name} already exists`);
      this.state.existing = true;
      this.updateStateFromDatabase(existingDatabase);
      return;
    }
    const createRequest = {
      name: this.definition.name,
      engine: validatedEngine,
      version: this.definition.version,
      region: validatedRegion,
      size: validatedSize,
      num_nodes: this.definition.num_nodes,
      tags: this.definition.tags || [],
      private_network_uuid: this.definition.private_network_uuid,
      db_config: this.definition.db_config || {}
    };
    Object.keys(createRequest).forEach((key) => {
      if (createRequest[key] === void 0) {
        delete createRequest[key];
      }
    });
    try {
      const response = this.makeRequest("POST", "/databases", createRequest);
      if (response.database) {
        this.updateStateFromDatabase(response.database);
        cli.output(`\u2705 Database cluster creation initiated: ${this.state.id}`);
      } else {
        throw new Error("Invalid response from DigitalOcean API - no database object returned");
      }
    } catch (error) {
      throw new Error(`Failed to create database cluster: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  update() {
    if (!this.state.id) {
      throw new Error("Cannot update database - no database ID in state");
    }
    cli.output(`\u{1F504} Checking for DigitalOcean database cluster updates: ${this.state.id}`);
    let hasUpdates = false;
    if (this.definition.size !== this.state.size) {
      cli.output(`\u{1F4CF} Resizing database cluster to: ${this.definition.size}`);
      try {
        this.makeRequest("PUT", `/databases/${this.state.id}/resize`, {
          size: validateDatabaseSize(this.definition.size),
          num_nodes: this.definition.num_nodes
        });
        cli.output(`\u2705 Database cluster resize initiated`);
        hasUpdates = true;
      } catch (error) {
        throw new Error(`Failed to resize database cluster: ${error instanceof Error ? error.message : "Unknown error"}`);
      }
    } else if (this.definition.num_nodes !== this.state.num_nodes) {
      cli.output(`\u{1F522} Changing node count to: ${this.definition.num_nodes}`);
      try {
        this.makeRequest("PUT", `/databases/${this.state.id}/resize`, {
          size: this.state.size,
          num_nodes: this.definition.num_nodes
        });
        cli.output(`\u2705 Database cluster node count change initiated`);
        hasUpdates = true;
      } catch (error) {
        throw new Error(`Failed to change node count: ${error instanceof Error ? error.message : "Unknown error"}`);
      }
    }
    if (JSON.stringify(this.definition.tags || []) !== JSON.stringify(this.state.tags || [])) {
      cli.output(`\u26A0\uFE0F  Note: Tags cannot be updated for existing DigitalOcean database clusters`);
      cli.output(`   Current tags will remain: ${(this.state.tags || []).join(", ")}`);
    }
    if (!hasUpdates) {
      cli.output("\u26AA No supported changes detected, skipping update");
      return;
    }
    cli.output("\u23F3 Waiting for database cluster update to complete...");
    this.waitForDatabaseStatus(this.state.id, "online", 60);
    try {
      const response = this.makeRequest("GET", `/databases/${this.state.id}`);
      if (response.database) {
        this.updateStateFromDatabase(response.database);
        cli.output(`\u2705 Database cluster updated successfully`);
      }
    } catch (error) {
      cli.output(`\u26A0\uFE0F  Update completed but failed to refresh state: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  delete() {
    if (!this.state.id) {
      cli.output("\u26AA No database ID in state, nothing to delete");
      return;
    }
    this.deleteResource(`/databases/${this.state.id}`, `database cluster ${this.state.name || this.state.id}`);
    this.state.id = void 0;
    this.state.status = void 0;
    this.state.connection = void 0;
  }
  checkReadiness() {
    if (!this.state.id) {
      return false;
    }
    try {
      const response = this.makeRequest("GET", `/databases/${this.state.id}`);
      if (response.database) {
        this.updateStateFromDatabase(response.database);
        const isReady = this.state.status === "online";
        if (isReady) {
          cli.output(`\u2705 Database cluster ${this.state.id} is ready`);
        } else {
          cli.output(`\u23F3 Database cluster ${this.state.id} status: ${this.state.status}`);
        }
        return isReady;
      }
      return false;
    } catch (error) {
      cli.output(`\u274C Failed to check database readiness: ${error instanceof Error ? error.message : "Unknown error"}`);
      return false;
    }
  }
  getDatabase(_args) {
    if (!this.state.id) {
      throw new Error("No database ID available");
    }
    try {
      const response = this.makeRequest("GET", `/databases/${this.state.id}`);
      if (response.database) {
        this.updateStateFromDatabase(response.database);
        cli.output(`\u{1F4CA} Database Information:`);
        cli.output(`   ID: ${response.database.id}`);
        cli.output(`   Name: ${response.database.name}`);
        cli.output(`   Engine: ${response.database.engine} v${response.database.version}`);
        cli.output(`   Status: ${response.database.status}`);
        cli.output(`   Region: ${response.database.region}`);
        cli.output(`   Size: ${response.database.size}`);
        cli.output(`   Nodes: ${response.database.num_nodes}`);
        cli.output(`   Created: ${response.database.created_at}`);
        if (response.database.connection) {
          cli.output(`
\u{1F517} Connection Details:`);
          cli.output(`   Host: ${response.database.connection.host}`);
          cli.output(`   Port: ${response.database.connection.port}`);
          cli.output(`   User: ${response.database.connection.user}`);
          cli.output(`   SSL: ${response.database.connection.ssl ? "enabled" : "disabled"}`);
        }
      } else {
        throw new Error("Database not found");
      }
    } catch (error) {
      throw new Error(`Failed to get database info: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  listDatabases(_args) {
    if (!this.state.id) {
      throw new Error("No database ID available");
    }
    try {
      const response = this.makeRequest("GET", `/databases/${this.state.id}/dbs`);
      const databases = response.dbs || [];
      cli.output(`\u{1F4CB} Databases in cluster "${this.state.name}" (${databases.length} total):`);
      if (databases.length === 0) {
        cli.output("   No databases found");
      } else {
        databases.forEach((db, index) => {
          cli.output(`   ${index + 1}. ${db.name}`);
        });
      }
      cli.output(`
Cluster ID: ${this.state.id}`);
      cli.output(`Engine: ${this.state.engine}`);
      let result = `\u{1F4CB} Databases in cluster "${this.state.name}" (${databases.length} total):
`;
      if (databases.length === 0) {
        result += "   No databases found\n";
      } else {
        databases.forEach((db, index) => {
          result += `   ${index + 1}. ${db.name}
`;
        });
      }
      result += `
Cluster ID: ${this.state.id}
`;
      result += `Engine: ${this.state.engine}`;
      return result;
    } catch (error) {
      throw new Error(`Failed to list databases: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  createDatabase(args) {
    if (!this.state.id) {
      throw new Error("No database ID available");
    }
    const dbName = args.db_name;
    if (!dbName) {
      throw new Error("Database name is required (use --db_name=your_database_name)");
    }
    try {
      this.makeRequest("POST", `/databases/${this.state.id}/dbs`, {
        name: dbName
      });
      cli.output(`\u2705 Successfully created database "${dbName}"`);
      cli.output(`   Cluster: ${this.state.name}`);
      cli.output(`   Engine: ${this.state.engine}`);
      cli.output(`   Cluster ID: ${this.state.id}`);
    } catch (error) {
      throw new Error(`Failed to create database: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  deleteDatabase(args) {
    if (!this.state.id) {
      throw new Error("No database ID available");
    }
    const dbName = args.db_name;
    if (!dbName) {
      throw new Error("Database name is required (use --db_name=your_database_name)");
    }
    try {
      this.makeRequest("DELETE", `/databases/${this.state.id}/dbs/${dbName}`);
      cli.output(`\u2705 Successfully deleted database "${dbName}"`);
      cli.output(`   Cluster: ${this.state.name}`);
      cli.output(`   Cluster ID: ${this.state.id}`);
    } catch (error) {
      throw new Error(`Failed to delete database: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  getConnectionInfo(_args) {
    if (!this.state.connection) {
      throw new Error("No connection information available");
    }
    cli.output(`\u{1F517} Connection Information for "${this.state.name}":`);
    cli.output(`   Engine: ${this.state.engine}`);
    cli.output(`   Host: ${this.state.connection.host}`);
    cli.output(`   Port: ${this.state.connection.port}`);
    cli.output(`   User: ${this.state.connection.user}`);
    cli.output(`   Database: ${this.state.connection.database}`);
    cli.output(`   SSL: ${this.state.connection.ssl ? "enabled" : "disabled"}`);
    if (this.state.connection.uri) {
      cli.output(`
\u{1F4CB} Connection URI:`);
      cli.output(`   ${this.state.connection.uri}`);
    }
  }
  resizeCluster(args) {
    if (!this.state.id) {
      throw new Error("No database ID available");
    }
    const newSize = args.size;
    const newNodeCount = args.num_nodes;
    if (!newSize && !newNodeCount) {
      throw new Error("Either size or num_nodes parameter is required (use --size=db-s-2vcpu-4gb or --num_nodes=3)");
    }
    const resizeRequest = {
      size: newSize || this.state.size,
      num_nodes: newNodeCount ? parseInt(newNodeCount) : this.state.num_nodes
    };
    try {
      cli.output(`\u{1F4CF} Resizing database cluster...`);
      cli.output(`   Current: ${this.state.size} with ${this.state.num_nodes} nodes`);
      cli.output(`   New: ${resizeRequest.size} with ${resizeRequest.num_nodes} nodes`);
      this.makeRequest("PUT", `/databases/${this.state.id}/resize`, resizeRequest);
      cli.output(`\u2705 Database cluster resize initiated`);
      cli.output(`\u23F3 This operation may take several minutes to complete`);
      cli.output(`   Use 'monk do <entity>/get-database' to check status`);
    } catch (error) {
      throw new Error(`Failed to resize database cluster: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  /**
   * Find existing database by name
   */
  findExistingDatabase() {
    try {
      const response = this.makeRequest("GET", "/databases");
      if (response.databases && Array.isArray(response.databases)) {
        return response.databases.find(
          (db) => db.name === this.definition.name
        );
      }
      return null;
    } catch (error) {
      return null;
    }
  }
  /**
   * Update internal state from database object
   */
  updateStateFromDatabase(database) {
    this.state.id = database.id;
    this.state.name = database.name;
    this.state.engine = database.engine;
    this.state.version = database.version;
    this.state.status = database.status;
    this.state.num_nodes = database.num_nodes;
    this.state.region = database.region;
    this.state.size = database.size;
    this.state.created_at = database.created_at;
    this.state.tags = database.tags;
    if (database.connection) {
      this.state.connection = {
        uri: database.connection.uri,
        host: database.connection.host,
        port: database.connection.port,
        user: database.connection.user,
        password: database.connection.password,
        database: database.connection.database,
        ssl: database.connection.ssl
      };
    }
  }
};
_init = __decoratorStart(_a);
__decorateElement(_init, 1, "getDatabase", _getDatabase_dec, _DigitalOceanDatabase);
__decorateElement(_init, 1, "listDatabases", _listDatabases_dec, _DigitalOceanDatabase);
__decorateElement(_init, 1, "createDatabase", _createDatabase_dec, _DigitalOceanDatabase);
__decorateElement(_init, 1, "deleteDatabase", _deleteDatabase_dec, _DigitalOceanDatabase);
__decorateElement(_init, 1, "getConnectionInfo", _getConnectionInfo_dec, _DigitalOceanDatabase);
__decorateElement(_init, 1, "resizeCluster", _resizeCluster_dec, _DigitalOceanDatabase);
__decoratorMetadata(_init, _DigitalOceanDatabase);
__name(_DigitalOceanDatabase, "DigitalOceanDatabase");
var DigitalOceanDatabase = _DigitalOceanDatabase;



function main(def, state, ctx) {
  const entity = new DigitalOceanDatabase(def, state, ctx);
  return entity.main(ctx);
}
