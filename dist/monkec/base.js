// Generated by MonkEC - targeting Goja runtime
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);

// input/monkec/base.ts
var base_exports = {};
__export(base_exports, {
  MonkEntity: () => MonkEntity,
  action: () => action
});
module.exports = __toCommonJS(base_exports);
var ACTION_METADATA_KEY = Symbol("monk:actions");
function camelToKebab(str) {
  return str.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase();
}
function action(actionName) {
  return function(originalMethod, context) {
    const propertyKey = String(context.name);
    const name = actionName || camelToKebab(propertyKey);
    context.addInitializer(function() {
      const actions = this[ACTION_METADATA_KEY] || /* @__PURE__ */ new Map();
      actions.set(name, propertyKey);
      this[ACTION_METADATA_KEY] = actions;
    });
    return originalMethod;
  };
}
var MonkEntity = class _MonkEntity {
  /**
   * Creates a new MonkEntity instance
   * @param definition - The entity definition
   * @param state - The entity state
   * @param ctx - The context object
   */
  constructor(definition, state, ctx) {
    /** The entity definition */
    __publicField(this, "definition");
    /** The entity state */
    __publicField(this, "state");
    __publicField(this, "path");
    this.definition = definition;
    this.state = state;
    this.path = ctx?.path || "";
  }
  /**
   * Main entry point called by the Monk runtime
   * @param ctx - The context object
   * @returns The updated state
   */
  main(ctx) {
    const action2 = ctx.action;
    if (!action2) {
      console.log("No action provided");
      return this.state;
    }
    if (this.isMethodImplemented("before")) {
      this.before();
    }
    try {
      if (this.tryBuiltinAction(action2, ctx.args)) {
        return this.state;
      }
      if (this.tryRegisteredAction(action2, ctx.args)) {
        return this.state;
      }
      this.handleUnknownAction(action2, ctx.args);
      return this.state;
    } finally {
      if (this.isMethodImplemented("after")) {
        try {
          this.after();
        } catch (afterError) {
          console.error("Error in after() hook:", afterError);
        }
      }
    }
  }
  /**
   * Try to execute a built-in action if it's implemented
   */
  tryBuiltinAction(action2, _args) {
    switch (action2) {
      case "create":
        if (this.isMethodImplemented("create")) {
          this.create();
          return true;
        }
        break;
      case "start":
        if (this.isMethodImplemented("start")) {
          this.start();
          return true;
        }
        break;
      case "stop":
        if (this.isMethodImplemented("stop")) {
          this.stop();
          return true;
        }
        break;
      case "purge":
        if (this.isMethodImplemented("delete")) {
          this.delete();
          return true;
        }
        break;
      case "update":
        if (this.isMethodImplemented("update")) {
          this.update();
          return true;
        }
        break;
      case "check-readiness":
        if (this.isMethodImplemented("checkReadiness")) {
          const isReady = this.checkReadiness();
          if (!isReady) {
            throw new Error("not ready");
          }
          return true;
        }
        break;
    }
    return false;
  }
  /**
   * Try to execute a registered @action method
   */
  tryRegisteredAction(action2, args) {
    const actions = this.getRegisteredActions();
    const methodName = actions.get(action2);
    if (methodName && typeof this[methodName] === "function") {
      this[methodName].call(this, args);
      return true;
    }
    return false;
  }
  /**
   * Get all registered actions from the instance
   */
  getRegisteredActions() {
    const actions = this[ACTION_METADATA_KEY];
    if (actions instanceof Map) {
      return new Map(actions);
    }
    return /* @__PURE__ */ new Map();
  }
  /**
   * Check if a method has been overridden from the base implementation
   */
  isMethodImplemented(methodName) {
    const method = this[methodName];
    if (typeof method !== "function") {
      return false;
    }
    const baseMethod = _MonkEntity.prototype[methodName];
    return method !== baseMethod;
  }
  /**
   * Handle unknown actions - can be overridden by subclasses
   */
  handleUnknownAction(action2, _args) {
    console.log(`Action ${action2} not defined`);
  }
  /**
   * Called before action execution - can be overridden by subclasses
   * Useful for common setup like reading secrets, initializing connections, etc.
   */
  before() {
  }
  /**
   * Called after action execution - can be overridden by subclasses
   * Useful for common teardown like closing connections, cleanup, etc.
   */
  after() {
  }
  /**
   * Creates the entity
   * Override in subclasses if needed
   */
  create() {
  }
  /**
   * Starts the entity
   * Override in subclasses if needed
   */
  start() {
  }
  /**
   * Stops the entity
   * Override in subclasses if needed
   */
  stop() {
  }
  /**
   * Updates the entity
   * Override in subclasses if needed
   */
  update() {
  }
  /**
   * Deletes the entity
   * Override in subclasses if needed
   */
  delete() {
  }
  /**
   * Checks if the entity is ready
   * Override in subclasses if needed
   * @returns True if the entity is ready
   */
  checkReadiness() {
    return true;
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  MonkEntity,
  action
});
