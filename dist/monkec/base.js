// Generated by MonkEC - targeting Goja runtime
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);

// input/monkec/base.ts
var base_exports = {};
__export(base_exports, {
  MonkEntity: () => MonkEntity,
  action: () => action
});
module.exports = __toCommonJS(base_exports);
var import_crypto = __toESM(require("crypto"));
var ACTION_METADATA_KEY = Symbol("monk:actions");
function camelToKebab(str) {
  return str.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase();
}
function action(actionName) {
  return function(originalMethod, context) {
    const propertyKey = String(context.name);
    const name = actionName || camelToKebab(propertyKey);
    context.addInitializer(function() {
      const actions = this[ACTION_METADATA_KEY] || /* @__PURE__ */ new Map();
      actions.set(name, propertyKey);
      this[ACTION_METADATA_KEY] = actions;
    });
    return originalMethod;
  };
}
var MonkEntity = class _MonkEntity {
  /**
   * Creates a new MonkEntity instance
   * @param definition - The entity definition
   * @param state - The entity state
   * @param ctx - The context object
   */
  constructor(definition, state, ctx) {
    /** The entity definition */
    __publicField(this, "definition");
    /** The entity state */
    __publicField(this, "state");
    __publicField(this, "path");
    __publicField(this, "metadata");
    this.definition = definition;
    this.state = state;
    this.path = ctx?.path || "";
  }
  /**
   * Main entry point called by the Monk runtime
   * @param ctx - The context object
   * @returns The updated state
   */
  main(ctx) {
    const action2 = ctx.action;
    if (ctx.metadata) {
      this.metadata = ctx.metadata;
    }
    if (!action2) {
      console.log("No action provided");
      return this.state;
    }
    if (this.isMethodImplemented("before")) {
      this.before();
    }
    try {
      if (this.tryBuiltinAction(action2, ctx.args)) {
        return this.state;
      }
      if (this.tryRegisteredAction(action2, ctx.args)) {
        return this.state;
      }
      this.handleUnknownAction(action2, ctx.args);
      return this.state;
    } finally {
      if (this.isMethodImplemented("after")) {
        try {
          this.after();
        } catch (afterError) {
          console.error("Error in after() hook:", afterError);
        }
      }
    }
  }
  /**
   * Try to execute a built-in action if it's implemented
   */
  tryBuiltinAction(action2, _args) {
    switch (action2) {
      case "create":
        if (this.isMethodImplemented("create")) {
          this.create();
          if (this.isIdempotentUpdateEnabled()) {
            this.persistCurrentDefinitionHash();
          }
          return true;
        }
        break;
      case "start":
        if (this.isMethodImplemented("start")) {
          this.start();
          return true;
        }
        break;
      case "stop":
        if (this.isMethodImplemented("stop")) {
          this.stop();
          return true;
        }
        break;
      case "purge":
        if (this.isMethodImplemented("delete")) {
          this.delete();
          return true;
        }
        break;
      case "update":
        if (this.isMethodImplemented("update")) {
          if (this.isIdempotentUpdateEnabled()) {
            const currentHash = this.computeDefinitionHash();
            const previousHash = this.getPersistedDefinitionHash();
            if (previousHash && previousHash === currentHash) {
              console.log("No definition changes detected; skipping update");
              return true;
            }
            this.update();
            this.setPersistedDefinitionHash(currentHash);
            return true;
          }
          this.update();
          return true;
        }
        break;
      case "check-readiness":
        if (this.isMethodImplemented("checkReadiness")) {
          const isReady = this.checkReadiness();
          if (!isReady) {
            throw new Error("not ready");
          }
          return true;
        }
        break;
    }
    return false;
  }
  /**
   * Try to execute a registered @action method
   */
  tryRegisteredAction(action2, args) {
    const actions = this.getRegisteredActions();
    const methodName = actions.get(action2);
    if (methodName && typeof this[methodName] === "function") {
      this[methodName].call(this, args);
      return true;
    }
    return false;
  }
  /**
   * Get all registered actions from the instance
   */
  getRegisteredActions() {
    const actions = this[ACTION_METADATA_KEY];
    if (actions instanceof Map) {
      return new Map(actions);
    }
    return /* @__PURE__ */ new Map();
  }
  /**
   * Check if a method has been overridden from the base implementation
   */
  isMethodImplemented(methodName) {
    const method = this[methodName];
    if (typeof method !== "function") {
      return false;
    }
    const baseMethod = _MonkEntity.prototype[methodName];
    return method !== baseMethod;
  }
  /**
   * Handle unknown actions - can be overridden by subclasses
   */
  handleUnknownAction(action2, _args) {
    console.log(`Action ${action2} not defined`);
  }
  /**
   * Called before action execution - can be overridden by subclasses
   * Useful for common setup like reading secrets, initializing connections, etc.
   */
  before() {
  }
  /**
   * Called after action execution - can be overridden by subclasses
   * Useful for common teardown like closing connections, cleanup, etc.
   */
  after() {
  }
  /**
   * Creates the entity
   * Override in subclasses if needed
   */
  create() {
  }
  /**
   * Starts the entity
   * Override in subclasses if needed
   */
  start() {
  }
  /**
   * Stops the entity
   * Override in subclasses if needed
   */
  stop() {
  }
  /**
   * Updates the entity
   * Override in subclasses if needed
   */
  update() {
  }
  /**
   * Deletes the entity
   * Override in subclasses if needed
   */
  delete() {
  }
  /**
   * Checks if the entity is ready
   * Override in subclasses if needed
   * @returns True if the entity is ready
   */
  checkReadiness() {
    return true;
  }
  /**
   * Whether base-level idempotent update short-circuiting by definition hash is enabled.
   * Subclasses can override to opt-out for providers that require always-on reconciliation.
   */
  isIdempotentUpdateEnabled() {
    return true;
  }
  /**
   * Allows subclasses to customize what part of the definition participates in the hash.
   * Default: the entire definition.
   */
  getDefinitionForHash() {
    return this.definition;
  }
  /** Compute a stable SHA-256 hash of the definition used for idempotence. */
  computeDefinitionHash() {
    const base = this.getDefinitionForHash();
    const meta = this.metadata || {};
    const withMeta = {
      __meta__: {
        version: meta.version || "",
        version_hash: meta["version-hash"] || ""
      },
      definition: base
    };
    const canonical = _MonkEntity.canonicalStringify(withMeta);
    return import_crypto.default.sha256(canonical);
  }
  /** Persist the current definition hash into state. */
  persistCurrentDefinitionHash() {
    const hash = this.computeDefinitionHash();
    this.setPersistedDefinitionHash(hash);
  }
  /** Read the persisted definition hash from state, if present. */
  getPersistedDefinitionHash() {
    const s = this.state;
    return s && typeof s.definition_hash === "string" ? s.definition_hash : void 0;
  }
  /** Write the definition hash into state. */
  setPersistedDefinitionHash(hash) {
    this.state.definition_hash = hash;
  }
  /** Stable stringify that sorts object keys recursively for deterministic hashing. */
  static canonicalStringify(value) {
    if (Array.isArray(value)) {
      return `[${value.map((v) => _MonkEntity.canonicalStringify(v)).join(",")}]`;
    }
    if (value && typeof value === "object") {
      const entries = Object.entries(value).filter(([, v]) => v !== void 0).sort(([a], [b]) => a < b ? -1 : a > b ? 1 : 0);
      return `{${entries.map(([k, v]) => `${JSON.stringify(k)}:${_MonkEntity.canonicalStringify(v)}`).join(",")}}`;
    }
    return JSON.stringify(value);
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  MonkEntity,
  action
});
