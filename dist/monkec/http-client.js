// Generated by MonkEC - targeting Goja runtime
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);

// input/httpClient.ts
var http_client_exports = {};
__export(http_client_exports, {
  HttpClient: () => HttpClient
});
module.exports = __toCommonJS(http_client_exports);
var import_http = __toESM(require("http"));
var HttpClient = class {
  /**
   * Create a new HTTP client with the specified options
   * @param options - Configuration options for the HTTP client
   * @throws {Error} When configuration options are invalid
   */
  constructor(options = {}) {
    __publicField(this, "options");
    if (options.baseUrl && !this.isValidUrl(options.baseUrl)) {
      throw new Error(
        `Invalid baseUrl format: "${options.baseUrl}". Must be a valid URL or empty string.`
      );
    }
    if (options.timeout !== void 0 && options.timeout <= 0) {
      throw new Error(
        `Invalid timeout: ${options.timeout}. Must be a positive number in milliseconds.`
      );
    }
    if (options.timeout !== void 0 && options.timeout > 3e5) {
      throw new Error(
        `Timeout too large: ${options.timeout}ms. Maximum allowed is 300000ms (5 minutes).`
      );
    }
    if (options.headers) {
      for (const [key, _value] of Object.entries(options.headers)) {
        if (key.trim() === "") {
          throw new Error("Header keys cannot be empty or whitespace only");
        }
      }
    }
    this.options = {
      baseUrl: options.baseUrl || "",
      headers: options.headers || {},
      timeout: options.timeout || 3e4,
      parseJson: options.parseJson !== false,
      stringifyJson: options.stringifyJson !== false
    };
    if (this.options.stringifyJson && !this.options.headers["Content-Type"]) {
      this.options.headers["Content-Type"] = "application/json";
    }
    if (this.options.parseJson && !this.options.headers["Accept"]) {
      this.options.headers["Accept"] = "application/json";
    }
  }
  /**
   * Perform a GET request
   * @param url - The URL to request (relative to baseUrl if configured)
   * @param options - Additional request options
   * @returns HTTP response with parsed data
   * @throws {Error} When URL is invalid, request configuration is malformed, network request fails, or response parsing fails
   */
  get(url, options = {}) {
    return this.request("GET", url, options);
  }
  /**
   * Perform a POST request
   * @param url - The URL to request (relative to baseUrl if configured)
   * @param options - Additional request options including body data
   * @returns HTTP response with parsed data
   * @throws {Error} When URL is invalid, request configuration is malformed, body serialization fails, network request fails, or response parsing fails
   */
  post(url, options = {}) {
    return this.request("POST", url, options);
  }
  /**
   * Perform a PUT request
   * @param url - The URL to request (relative to baseUrl if configured)
   * @param options - Additional request options including body data
   * @returns HTTP response with parsed data
   * @throws {Error} When URL is invalid, request configuration is malformed, body serialization fails, network request fails, or response parsing fails
   */
  put(url, options = {}) {
    return this.request("PUT", url, options);
  }
  /**
   * Perform a PATCH request (polyfilled using the builtin http.do method)
   * @param url - The URL to request (relative to baseUrl if configured)
   * @param options - Additional request options including body data
   * @returns HTTP response with parsed data
   * @throws {Error} When URL is invalid, request configuration is malformed, body serialization fails, network request fails, or response parsing fails
   */
  patch(url, options = {}) {
    return this.request("PATCH", url, options);
  }
  /**
   * Perform a DELETE request
   * @param url - The URL to request (relative to baseUrl if configured)
   * @param options - Additional request options
   * @returns HTTP response with parsed data
   * @throws {Error} When URL is invalid, request configuration is malformed, network request fails, or response parsing fails
   */
  delete(url, options = {}) {
    return this.request("DELETE", url, options);
  }
  /**
   * Perform a custom HTTP request
   * @param method - HTTP method (GET, POST, PUT, PATCH, DELETE, etc.)
   * @param url - The URL to request (relative to baseUrl if configured)
   * @param options - Additional request options
   * @returns HTTP response with parsed data
   * @throws {Error} When method is invalid, URL is invalid, request configuration is malformed, body serialization fails, network request fails, or response parsing fails
   */
  request(method, url, options = {}) {
    if (!url || url.trim() === "") {
      throw new Error("URL is required and must be a nonEmpty string");
    }
    const trimmedUrl = url.trim();
    if (trimmedUrl.length > 2048) {
      throw new Error(
        `URL too long: ${trimmedUrl.length} characters. Maximum allowed is 2048 characters.`
      );
    }
    this.validateRequestOptions(options);
    const normalizedMethod = method.toUpperCase();
    let fullUrl;
    let headers;
    let body;
    try {
      fullUrl = this.buildUrl(trimmedUrl, options.query);
      headers = {
        ...this.options.headers,
        ...options.headers
      };
      body = this.prepareBody(options.body);
    } catch (error) {
      throw new Error(
        `Failed to prepare ${normalizedMethod} request to "${trimmedUrl}": ${error instanceof Error ? error.message : "Unknown preparation error"}`
      );
    }
    const request = {
      method: normalizedMethod,
      headers,
      body,
      timeout: options.timeout || this.options.timeout
    };
    let response;
    try {
      if (normalizedMethod === "GET") {
        response = import_http.default.get(fullUrl, request);
      } else if (normalizedMethod === "POST") {
        response = import_http.default.post(fullUrl, request);
      } else if (normalizedMethod === "PUT") {
        response = import_http.default.put(fullUrl, request);
      } else if (normalizedMethod === "DELETE") {
        response = import_http.default.delete(fullUrl, request);
      } else {
        response = import_http.default.do(fullUrl, request);
      }
    } catch (error) {
      throw new Error(
        `${normalizedMethod} request to "${fullUrl}" failed during execution: ${error instanceof Error ? error.message : "Unknown network error"}`
      );
    }
    if (response.error) {
      throw new Error(
        `${normalizedMethod} request to "${fullUrl}" failed: ${response.error}. ` + response.body
      );
    }
    try {
      return this.parseResponse(response);
    } catch (error) {
      throw new Error(
        `${normalizedMethod} request to "${fullUrl}" succeeded but response parsing failed: ${error instanceof Error ? error.message : "Unknown parsing error"}`
      );
    }
  }
  /**
   * Build the full URL with base URL and query parameters
   * @throws {Error} When URL construction fails or results in invalid URL
   */
  buildUrl(url, query) {
    let fullUrl = url;
    if (this.options.baseUrl && !url.startsWith("http")) {
      const baseUrl = this.options.baseUrl.endsWith("/") ? this.options.baseUrl.slice(0, -1) : this.options.baseUrl;
      const path = url.startsWith("/") ? url : `/${url}`;
      fullUrl = `${baseUrl}${path}`;
    }
    if (query && Object.keys(query).length > 0) {
      try {
        const queryParts = Object.entries(query).map(
          ([key, value]) => `${encodeURIComponent(key)}=${encodeURIComponent(value)}`
        ).join("&");
        fullUrl += (fullUrl.includes("?") ? "&" : "?") + queryParts;
      } catch (error) {
        throw new Error(
          `Failed to build query string: ${error instanceof Error ? error.message : "Invalid query parameters"}`
        );
      }
    }
    if (fullUrl.length > 2048) {
      throw new Error(
        `Final URL too long: ${fullUrl.length} characters (maximum: 2048)`
      );
    }
    return fullUrl;
  }
  /**
   * Parse the HTTP response into our format
   * @throws {Error} When response parsing fails
   */
  parseResponse(response) {
    if (!response || typeof response !== "object") {
      throw new Error("Invalid response object received from HTTP request");
    }
    let data = response.body;
    if (this.options.parseJson && response.body) {
      const contentType = response.headers?.["contentType"] || response.headers?.["Content-Type"] || "";
      if (contentType.includes("application/json")) {
        try {
          data = JSON.parse(response.body);
        } catch (error) {
          console.warn(
            `Failed to parse JSON response (Content-Type: ${contentType}): ${error instanceof Error ? error.message : "Unknown JSON parse error"}`
          );
        }
      }
    }
    return {
      statusCode: response.statusCode || 0,
      status: response.status || "Unknown",
      headers: response.headers || {},
      data,
      raw: response.body || "",
      contentLength: response.contentLength || 0,
      ok: (response.statusCode || 0) >= 200 && (response.statusCode || 0) < 300
    };
  }
  /**
   * Validate request options
   * @throws {Error} When request options are invalid
   */
  validateRequestOptions(options) {
    if (options.timeout !== void 0 && options.timeout <= 0) {
      throw new Error(
        `Invalid request timeout: ${options.timeout}. Must be a positive number in milliseconds.`
      );
    }
    if (options.timeout !== void 0 && options.timeout > 3e5) {
      throw new Error(
        `Request timeout too large: ${options.timeout}ms. Maximum allowed is 300000ms (5 minutes).`
      );
    }
    if (options.headers) {
      for (const [key] of Object.entries(options.headers)) {
        if (key.trim() === "") {
          throw new Error(
            "Request header keys cannot be empty or whitespace only"
          );
        }
      }
    }
    if (options.query) {
      for (const [key] of Object.entries(options.query)) {
        if (key.trim() === "") {
          throw new Error(
            "Query parameter keys cannot be empty or whitespace only"
          );
        }
      }
    }
  }
  /**
   * Prepare request body for sending
   * @throws {Error} When body serialization fails
   */
  prepareBody(body) {
    if (body === void 0 || body === null) {
      return void 0;
    }
    if (typeof body === "string") {
      return body;
    }
    if (this.options.stringifyJson && typeof body === "object") {
      try {
        return JSON.stringify(body);
      } catch (error) {
        throw new Error(
          `Failed to JSON stringify request body: ${error instanceof Error ? error.message : "Invalid JSON data"}`
        );
      }
    }
    try {
      return String(body);
    } catch (error) {
      throw new Error(
        `Failed to convert request body to string: ${error instanceof Error ? error.message : "Unknown conversion error"}`
      );
    }
  }
  /**
   * Check if a string is a valid URL format
   */
  isValidUrl(urlString) {
    if (!urlString || urlString.trim() === "") {
      return true;
    }
    const urlPattern = /^https?:\/\/.+/;
    return urlPattern.test(urlString.trim());
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  HttpClient
});
