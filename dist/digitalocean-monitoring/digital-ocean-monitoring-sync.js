
// Generated by MonkEC - targeting Goja runtime
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __knownSymbol = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __decoratorStart = (base) => [, , , __create(base?.[__knownSymbol("metadata")] ?? null)];
var __decoratorStrings = ["class", "method", "getter", "setter", "accessor", "field", "value", "get", "set"];
var __expectFn = (fn) => fn !== void 0 && typeof fn !== "function" ? __typeError("Function expected") : fn;
var __decoratorContext = (kind, name, done, metadata, fns) => ({ kind: __decoratorStrings[kind], name, metadata, addInitializer: (fn) => done._ ? __typeError("Already initialized") : fns.push(__expectFn(fn || null)) });
var __decoratorMetadata = (array, target) => __defNormalProp(target, __knownSymbol("metadata"), array[3]);
var __runInitializers = (array, flags, self, value) => {
  for (var i = 0, fns = array[flags >> 1], n = fns && fns.length; i < n; i++) flags & 1 ? fns[i].call(self) : value = fns[i].call(self, value);
  return value;
};
var __decorateElement = (array, flags, name, decorators, target, extra) => {
  var fn, it, done, ctx, access, k = flags & 7, s = !!(flags & 8), p = !!(flags & 16);
  var j = k > 3 ? array.length + 1 : k ? s ? 1 : 2 : 0, key = __decoratorStrings[k + 5];
  var initializers = k > 3 && (array[j - 1] = []), extraInitializers = array[j] || (array[j] = []);
  var desc = k && (!p && !s && (target = target.prototype), k < 5 && (k > 3 || !p) && __getOwnPropDesc(k < 4 ? target : { get [name]() {
    return __privateGet(this, extra);
  }, set [name](x) {
    return __privateSet(this, extra, x);
  } }, name));
  k ? p && k < 4 && __name(extra, (k > 2 ? "set " : k > 1 ? "get " : "") + name) : __name(target, name);
  for (var i = decorators.length - 1; i >= 0; i--) {
    ctx = __decoratorContext(k, name, done = {}, array[3], extraInitializers);
    if (k) {
      ctx.static = s, ctx.private = p, access = ctx.access = { has: p ? (x) => __privateIn(target, x) : (x) => name in x };
      if (k ^ 3) access.get = p ? (x) => (k ^ 1 ? __privateGet : __privateMethod)(x, target, k ^ 4 ? extra : desc.get) : (x) => x[name];
      if (k > 2) access.set = p ? (x, y) => __privateSet(x, target, y, k ^ 4 ? extra : desc.set) : (x, y) => x[name] = y;
    }
    it = (0, decorators[i])(k ? k < 4 ? p ? extra : desc[key] : k > 4 ? void 0 : { get: desc.get, set: desc.set } : target, ctx), done._ = 1;
    if (k ^ 4 || it === void 0) __expectFn(it) && (k > 4 ? initializers.unshift(it) : k ? p ? extra = it : desc[key] = it : target = it);
    else if (typeof it !== "object" || it === null) __typeError("Object expected");
    else __expectFn(fn = it.get) && (desc.get = fn), __expectFn(fn = it.set) && (desc.set = fn), __expectFn(fn = it.init) && initializers.unshift(fn);
  }
  return k || __decoratorMetadata(array, target), desc && __defProp(target, name, desc), p ? k ^ 4 ? extra : desc : target;
};
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateIn = (member, obj) => Object(obj) !== obj ? __typeError('Cannot use the "in" operator on this value') : member.has(obj);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);

// input/digitalocean-monitoring/alertPolicy.ts
const base = require("monkec/base");
const action = base.action;
const doProviderBase = require("digitalocean-monitoring/do-provider-base");
const DOProviderEntity = doProviderBase.DOProviderEntity;
const common = require("digitalocean-monitoring/common");
const validateAlertPolicyType = common.validateAlertPolicyType;
const validateComparator = common.validateComparator;
const validateWindow = common.validateWindow;
const validateEmails = common.validateEmails;
const cli = require("cli");
var _getAllDropletMetrics_dec, _getSink_dec, _listSinks_dec, _deleteAlertPolicy_dec, _listDroplets_dec, _getDropletLoadAverage15_dec, _getDropletLoadAverage5_dec, _getDropletLoadAverage1_dec, _getDropletDiskWrite_dec, _getDropletDiskRead_dec, _getDropletPrivateBandwidthOutbound_dec, _getDropletPrivateBandwidthInbound_dec, _getDropletBandwidthOutbound_dec, _getDropletBandwidthInbound_dec, _getVolumeMetrics_dec, _disableAlertPolicy_dec, _enableAlertPolicy_dec, _getDatabaseMetrics_dec, _getLoadBalancerMetrics_dec, _getAppMetrics_dec, _getDropletNetworkMetrics_dec, _getDropletDiskMetrics_dec, _getDropletMemoryMetrics_dec, _getDropletCpuMetrics_dec, _getDropletMetrics_dec, _getAccountInfo_dec, _updateAlertPolicy_dec, _getAlertPolicy_dec, _listAlertPolicies_dec, _createAlertPolicy_dec, _a, _init;
var _DigitalOceanMonitoring = class _DigitalOceanMonitoring extends (_a = DOProviderEntity, _createAlertPolicy_dec = [action()], _listAlertPolicies_dec = [action()], _getAlertPolicy_dec = [action()], _updateAlertPolicy_dec = [action()], _getAccountInfo_dec = [action()], _getDropletMetrics_dec = [action()], _getDropletCpuMetrics_dec = [action()], _getDropletMemoryMetrics_dec = [action()], _getDropletDiskMetrics_dec = [action()], _getDropletNetworkMetrics_dec = [action()], _getAppMetrics_dec = [action()], _getLoadBalancerMetrics_dec = [action()], _getDatabaseMetrics_dec = [action()], _enableAlertPolicy_dec = [action()], _disableAlertPolicy_dec = [action()], _getVolumeMetrics_dec = [action()], _getDropletBandwidthInbound_dec = [action()], _getDropletBandwidthOutbound_dec = [action()], _getDropletPrivateBandwidthInbound_dec = [action()], _getDropletPrivateBandwidthOutbound_dec = [action()], _getDropletDiskRead_dec = [action()], _getDropletDiskWrite_dec = [action()], _getDropletLoadAverage1_dec = [action()], _getDropletLoadAverage5_dec = [action()], _getDropletLoadAverage15_dec = [action()], _listDroplets_dec = [action()], _deleteAlertPolicy_dec = [action()], _listSinks_dec = [action()], _getSink_dec = [action()], _getAllDropletMetrics_dec = [action()], _a) {
  constructor() {
    super(...arguments);
    __runInitializers(_init, 5, this);
  }
  getEntityName() {
    return "DigitalOcean Monitoring Alert Policy";
  }
  create() {
    try {
      validateAlertPolicyType(this.definition.metric_type);
      validateComparator(this.definition.compare);
      validateWindow(this.definition.window);
      if (this.definition.create_when_missing === false) {
        this.state.uuid = `test-uuid-${Date.now()}`;
        this.state.name = this.definition.name;
        this.state.alert_description = `Test alert policy for ${this.definition.name}`;
        this.state.metric_type = this.definition.metric_type;
        this.state.compare = this.definition.compare;
        this.state.value = this.definition.value;
        this.state.window = this.definition.window;
        this.state.entities = this.definition.entities ? [...this.definition.entities] : void 0;
        this.state.tags = this.definition.tags ? [...this.definition.tags] : void 0;
        this.state.emails = this.definition.emails ? [...this.definition.emails] : [];
        this.state.enabled = this.definition.enabled !== false;
        this.state.created_at = (/* @__PURE__ */ new Date()).toISOString();
        cli.output(`Alert Policy Created (Test Mode): ${this.state.name}
UUID: ${this.state.uuid}
Type: ${this.state.metric_type}
Threshold: ${this.state.compare} ${this.state.value}
Window: ${this.state.window}
Notifications: ${this.state.emails?.join(", ")}
Status: ${this.state.enabled ? "Enabled" : "Disabled"}`);
        return;
      }
      let emailsToUse = this.definition.emails || [];
      if (emailsToUse.length === 0) {
        try {
          cli.output(`\u{1F50D} Attempting to get account email from DigitalOcean API...`);
          const accountResponse = this.makeRequest("GET", "/account");
          cli.output(`\u{1F4CB} Account API Response: ${JSON.stringify(accountResponse, null, 2)}`);
          let accountEmail = null;
          let emailVerified = false;
          if (accountResponse.account) {
            accountEmail = accountResponse.account.email;
            emailVerified = accountResponse.account.email_verified;
          } else if (accountResponse.email) {
            accountEmail = accountResponse.email;
            emailVerified = accountResponse.email_verified;
          }
          if (accountEmail) {
            if (emailVerified) {
              cli.output(`\u{1F4E7} Using verified account email: ${accountEmail}`);
              emailsToUse = [accountEmail];
            } else {
              cli.output(`\u26A0\uFE0F Account email ${accountEmail} is not verified in DigitalOcean`);
              throw new Error(`Account email ${accountEmail} is not verified. Please verify it in DigitalOcean or provide verified emails in configuration.`);
            }
          } else {
            cli.output(`\u274C No email found in account response`);
            throw new Error(`No email found in DigitalOcean account. Please provide emails in configuration.`);
          }
        } catch (error) {
          cli.output(`\u274C Failed to get account email: ${error instanceof Error ? error.message : "Unknown error"}`);
          throw new Error(`Failed to get account email: ${error instanceof Error ? error.message : "Unknown error"}`);
        }
      }
      if (emailsToUse.length > 0) {
        validateEmails([...emailsToUse]);
      }
      try {
        const testResponse = this.makeRequest("GET", "/monitoring/alerts");
        const alerts = testResponse.alerts || testResponse.policies || [];
        cli.output(`\u2705 API access verified, found ${alerts.length} existing policies`);
      } catch (error) {
        throw new Error(`API access test failed: ${error instanceof Error ? error.message : "Unknown error"}`);
      }
      const existingPolicy = this.findExistingPolicy();
      if (existingPolicy) {
        this.updateStateFromPolicy(existingPolicy);
        cli.output(`Alert Policy Found: ${this.state.name}
UUID: ${this.state.uuid}
Type: ${this.state.metric_type}
Status: ${this.state.enabled ? "Enabled" : "Disabled"}
Created: ${this.state.created_at}`);
        return;
      }
      const policyData = this.buildPolicyData([...emailsToUse]);
      const response = this.makeRequest("POST", "/monitoring/alerts", policyData);
      cli.output(`\u{1F4CB} Create Response: ${JSON.stringify(response, null, 2)}`);
      if (response.policy) {
        this.updateStateFromPolicy(response.policy);
        cli.output(`Alert Policy Created: ${this.state.name}
UUID: ${this.state.uuid}
Type: ${this.state.metric_type}
Threshold: ${this.state.compare} ${this.state.value}
Window: ${this.state.window}
Notifications: ${this.state.emails?.join(", ")}
Status: ${this.state.enabled ? "Enabled" : "Disabled"}`);
      } else if (response.alert) {
        this.updateStateFromPolicy(response.alert);
        cli.output(`Alert Policy Created: ${this.state.name}
UUID: ${this.state.uuid}
Type: ${this.state.metric_type}
Threshold: ${this.state.compare} ${this.state.value}
Window: ${this.state.window}
Notifications: ${this.state.emails?.join(", ")}
Status: ${this.state.enabled ? "Enabled" : "Disabled"}`);
      } else if (response.alerts && response.alerts.length > 0) {
        this.updateStateFromPolicy(response.alerts[0]);
        cli.output(`Alert Policy Created: ${this.state.name}
UUID: ${this.state.uuid}
Type: ${this.state.metric_type}
Threshold: ${this.state.compare} ${this.state.value}
Window: ${this.state.window}
Notifications: ${this.state.emails?.join(", ")}
Status: ${this.state.enabled ? "Enabled" : "Disabled"}`);
      } else {
        cli.output(`\u274C Unexpected response format: ${JSON.stringify(response, null, 2)}`);
        throw new Error("Failed to create alert policy: No policy returned in response");
      }
    } catch (error) {
      throw new Error(`Failed to create alert policy: ${error.message}`);
    }
    return this.state;
  }
  update() {
    try {
      if (this.definition.create_when_missing === false) {
        if (!this.state.uuid) {
          this.create();
          return;
        }
        this.state.name = this.definition.name;
        this.state.alert_description = `Test alert policy for ${this.definition.name}`;
        this.state.metric_type = this.definition.metric_type;
        this.state.compare = this.definition.compare;
        this.state.value = this.definition.value;
        this.state.window = this.definition.window;
        this.state.entities = this.definition.entities ? [...this.definition.entities] : void 0;
        this.state.tags = this.definition.tags ? [...this.definition.tags] : void 0;
        this.state.emails = this.definition.emails ? [...this.definition.emails] : [];
        this.state.enabled = this.definition.enabled !== false;
        cli.output(`Alert Policy Updated (Test Mode): ${this.state.name}
UUID: ${this.state.uuid}
Type: ${this.state.metric_type}
Threshold: ${this.state.compare} ${this.state.value}
Window: ${this.state.window}
Notifications: ${this.state.emails?.join(", ")}
Status: ${this.state.enabled ? "Enabled" : "Disabled"}`);
        return;
      }
      const existingPolicy = this.findExistingPolicy();
      if (!existingPolicy) {
        this.create();
        return;
      }
      let emailsToUse = this.definition.emails || [];
      if (emailsToUse.length === 0) {
        try {
          const accountResponse = this.makeRequest("GET", "/account");
          const accountEmail = accountResponse.account?.email;
          const emailVerified = accountResponse.account?.email_verified;
          if (accountEmail && emailVerified) {
            emailsToUse = [accountEmail];
          } else {
            throw new Error("Account email not verified or not found. Please provide emails in configuration.");
          }
        } catch (error) {
          throw new Error(`Failed to get account email: ${error instanceof Error ? error.message : "Unknown error"}`);
        }
      }
      const policyData = this.buildPolicyData([...emailsToUse]);
      const response = this.makeRequest("PUT", `/monitoring/alerts/${existingPolicy.uuid}`, policyData);
      const updatedPolicy = response.policy || response.alert || response;
      this.updateStateFromPolicy(updatedPolicy);
      cli.output(`Alert Policy Updated: ${this.state.name}
UUID: ${this.state.uuid}
Type: ${this.state.metric_type}
Threshold: ${this.state.compare} ${this.state.value}
Window: ${this.state.window}
Notifications: ${this.state.emails?.join(", ")}
Status: ${this.state.enabled ? "Enabled" : "Disabled"}`);
    } catch (error) {
      throw new Error(`Failed to update alert policy: ${error.message}`);
    }
    return this.state;
  }
  delete() {
    try {
      if (!this.state.uuid) {
        cli.output("No alert policy to delete");
        return;
      }
      const policyUuid = this.state.uuid;
      const policyName = this.state.name || this.state.alert_description || "Unknown";
      if (this.definition.create_when_missing === false) {
        cli.output(`Alert policy deleted successfully (Test Mode)
Name: ${policyName}
UUID: ${policyUuid}`);
        this.state = {
          uuid: void 0,
          name: void 0,
          alert_description: void 0,
          metric_type: void 0,
          compare: void 0,
          value: void 0,
          window: void 0,
          entities: void 0,
          tags: void 0,
          emails: void 0,
          slack_channels: void 0,
          enabled: void 0,
          created_at: void 0
        };
        return;
      }
      cli.output(`\u{1F5D1}\uFE0F Deleting alert policy from DigitalOcean: ${policyName} (${policyUuid})`);
      this.makeRequest("DELETE", `/monitoring/alerts/${policyUuid}`);
      this.state = {
        uuid: void 0,
        name: void 0,
        alert_description: void 0,
        metric_type: void 0,
        compare: void 0,
        value: void 0,
        window: void 0,
        entities: void 0,
        tags: void 0,
        emails: void 0,
        slack_channels: void 0,
        enabled: void 0,
        created_at: void 0
      };
      cli.output(`\u2705 Alert policy deleted successfully from DigitalOcean
Name: ${policyName}
UUID: ${policyUuid}`);
    } catch (error) {
      cli.output(`\u274C Failed to delete alert policy: ${error.message}`);
      throw new Error(`Failed to delete alert policy: ${error.message}`);
    }
    return this.state;
  }
  checkReadiness() {
    return !!this.state.uuid;
  }
  createAlertPolicy(args) {
    try {
      cli.output(`DEBUG: Received args: ${JSON.stringify(args)}`);
      const name = args.name;
      const type = args.type;
      const compare = args.compare;
      const value = args.value;
      const window = args.window;
      const emails = args.emails;
      const entities = args.entities;
      const tags = args.tags;
      const description = args.description;
      const slack_channels = args.slack_channels;
      if (!name) throw new Error("Name is required (use name=your_alert_name)");
      if (!type) throw new Error("Type is required (use type=v1/insights/droplet/cpu)");
      if (!compare) throw new Error("Compare is required (use compare=GreaterThan)");
      if (!value) throw new Error("Value is required (use value=80)");
      if (!window) throw new Error("Window is required (use window=10m)");
      if (!emails) throw new Error("Emails is required (use emails=admin@example.com)");
      validateAlertPolicyType(type);
      validateComparator(compare);
      validateWindow(window);
      const emailArray = emails.split(",").map((e) => e.trim());
      validateEmails(emailArray);
      const policyData = {
        type,
        description: description || `Alert policy for ${name}`,
        compare,
        value: Number(value),
        window,
        entities: entities ? entities.split(",").map((e) => e.trim()) : [],
        tags: tags ? tags.split(",").map((t) => t.trim()) : [],
        alerts: {
          email: emailArray,
          slack: slack_channels ? JSON.parse(slack_channels) : []
        },
        enabled: true
      };
      const response = this.makeRequest("POST", "/monitoring/alerts", policyData);
      if (response.alert) {
        const policy = response.alert;
        cli.output(`Alert Policy Created: ${name}
UUID: ${policy.uuid}
Type: ${type}
Threshold: ${compare} ${value}
Window: ${window}
Entities: ${policyData.entities.join(", ") || "None"}
Tags: ${policyData.tags.join(", ") || "None"}
Notifications: ${emailArray.join(", ")}
Status: Enabled`);
        return policy;
      }
    } catch (error) {
      throw new Error(`Failed to create alert policy: ${error.message}`);
    }
  }
  listAlertPolicies(_args) {
    try {
      const response = this.makeRequest("GET", "/monitoring/alerts");
      const alerts = response.alerts || response.policies || [];
      if (!alerts || alerts.length === 0) {
        cli.output("No alert policies found");
        return { count: 0, policies: [] };
      }
      let output = `Alert Policies (${alerts.length} total):

`;
      const policies = alerts.map((policy, index) => {
        const policyInfo = {
          index: index + 1,
          name: policy.description,
          uuid: policy.uuid,
          type: policy.type,
          threshold: `${policy.compare} ${policy.value}`,
          window: policy.window,
          entities: policy.entities || [],
          tags: policy.tags || [],
          emails: policy.alerts?.email || [],
          slack_channels: policy.alerts?.slack?.length || 0,
          status: policy.enabled ? "Enabled" : "Disabled",
          created_at: policy.created_at
        };
        output += `${index + 1}. ${policy.description}
`;
        output += `   UUID: ${policy.uuid}
`;
        output += `   Type: ${policy.type}
`;
        output += `   Threshold: ${policy.compare} ${policy.value}
`;
        output += `   Window: ${policy.window}
`;
        output += `   Status: ${policy.enabled ? "Enabled" : "Disabled"}
`;
        if (policy.entities && policy.entities.length > 0) {
          output += `   Entities: ${policy.entities.join(", ")}
`;
        }
        if (policy.tags && policy.tags.length > 0) {
          output += `   Tags: ${policy.tags.join(", ")}
`;
        }
        if (policy.alerts?.email && policy.alerts.email.length > 0) {
          output += `   Email notifications: ${policy.alerts.email.join(", ")}
`;
        }
        if (policy.alerts?.slack && policy.alerts.slack.length > 0) {
          output += `   Slack notifications: ${policy.alerts.slack.length} channels
`;
        }
        if (policy.created_at) {
          output += `   Created: ${new Date(policy.created_at).toLocaleString()}
`;
        }
        output += "\n";
        return policyInfo;
      });
      cli.output(output.trim());
      return { count: alerts.length, policies };
    } catch (error) {
      throw new Error(`Failed to list alert policies: ${error.message}`);
    }
  }
  getAlertPolicy(_args) {
    try {
      if (!this.state.uuid) {
        throw new Error("No alert policy UUID available");
      }
      const response = this.makeRequest("GET", `/monitoring/alerts/${this.state.uuid}`);
      cli.output(`\u{1F4CB} Raw API Response: ${JSON.stringify(response, null, 2)}`);
      let policy = response.alert || response.policy || response;
      if (!policy || !policy.uuid) {
        throw new Error("No valid policy found in response");
      }
      let output = `Alert Policy Details:
`;
      output += `Name: ${policy.description}
`;
      output += `UUID: ${policy.uuid}
`;
      output += `Type: ${policy.type}
`;
      output += `Threshold: ${policy.compare} ${policy.value}
`;
      output += `Window: ${policy.window}
`;
      output += `Entities: ${policy.entities?.join(", ") || "None"}
`;
      output += `Tags: ${policy.tags?.join(", ") || "None"}
`;
      output += `Emails: ${policy.alerts?.email?.join(", ") || "None"}
`;
      output += `Slack: ${policy.alerts?.slack?.length || 0} channels
`;
      output += `Status: ${policy.enabled ? "Enabled" : "Disabled"}`;
      cli.output(output);
      return policy;
    } catch (error) {
      cli.output(`\u274C Error getting alert policy: ${error.message}`);
      throw new Error(`Failed to get alert policy: ${error.message}`);
    }
  }
  updateAlertPolicy(args) {
    try {
      if (!this.state.uuid) {
        throw new Error("No alert policy UUID available");
      }
      const compare = args.compare;
      const value = args.value;
      const window = args.window;
      const emails = args.emails;
      const entities = args.entities;
      const tags = args.tags;
      const enabled = args.enabled;
      const updateData = {};
      if (compare) {
        validateComparator(compare);
        updateData.compare = compare;
      }
      if (value !== void 0) updateData.value = Number(value);
      if (window) {
        validateWindow(window);
        updateData.window = window;
      }
      if (emails) {
        const emailArray = emails.split(",").map((e) => e.trim());
        validateEmails(emailArray);
        updateData.alerts = { ...updateData.alerts, email: emailArray };
      }
      if (entities) updateData.entities = entities.split(",").map((e) => e.trim());
      if (tags) updateData.tags = tags.split(",").map((t) => t.trim());
      if (enabled !== void 0) updateData.enabled = enabled === "true";
      const response = this.makeRequest("PUT", `/monitoring/alerts/${this.state.uuid}`, updateData);
      const policy = response.alert;
      cli.output(`Alert Policy Updated: ${policy.description}
UUID: ${policy.uuid}
Type: ${policy.type}
Threshold: ${policy.compare} ${policy.value}
Window: ${policy.window}
Status: ${policy.enabled ? "Enabled" : "Disabled"}`);
      return policy;
    } catch (error) {
      throw new Error(`Failed to update alert policy: ${error.message}`);
    }
  }
  getAccountInfo(_args) {
    try {
      const response = this.makeRequest("GET", "/account");
      const account = response.account;
      if (account) {
        let output = `Account Information:
`;
        output += `  Name: ${account.name}
`;
        output += `  Email: ${account.email} ${account.email_verified ? "(verified)" : "(not verified)"}
`;
        output += `  UUID: ${account.uuid}
`;
        output += `  Status: ${account.status}
`;
        if (account.team) {
          output += `  Team: ${account.team.name} (${account.team.uuid})
`;
        }
        output += `  Limits:
`;
        output += `    Droplets: ${account.droplet_limit}
`;
        output += `    Floating IPs: ${account.floating_ip_limit}
`;
        output += `    Volumes: ${account.volume_limit}`;
        cli.output(output);
        return {
          email: account.email,
          uuid: account.uuid,
          name: account.name,
          status: account.status,
          email_verified: account.email_verified,
          team: account.team,
          limits: {
            droplet_limit: account.droplet_limit,
            floating_ip_limit: account.floating_ip_limit,
            volume_limit: account.volume_limit
          }
        };
      } else {
        cli.output("No account info found in response");
        return { error: "No account info found in response", raw_response: response };
      }
    } catch (error) {
      throw new Error(`Failed to get account info: ${error.message}`);
    }
  }
  getDropletMetrics(args) {
    try {
      const droplet_id = args.droplet_id;
      const type = args.type || "v1/insights/droplet/cpu";
      let start_time = args.start_time;
      let end_time = args.end_time;
      if (!droplet_id) {
        throw new Error("Droplet ID is required (use droplet_id=YOUR-DROPLET-ID)");
      }
      validateAlertPolicyType(type);
      if (!end_time) {
        end_time = (/* @__PURE__ */ new Date()).toISOString();
      }
      if (!start_time) {
        const oneHourAgo = new Date(Date.now() - 60 * 60 * 1e3);
        start_time = oneHourAgo.toISOString();
      }
      let queryParams = `host_id=${droplet_id}&start=${start_time}&end=${end_time}`;
      const metricPath = type.replace("v1/insights/droplet/", "");
      const response = this.makeRequest("GET", `/monitoring/metrics/droplet/${metricPath}?${queryParams}`);
      if (!response.data?.result || response.data.result.length === 0) {
        cli.output(`No metrics found for droplet ${droplet_id} and metric ${type}
Time Range: ${start_time} to ${end_time}
Note: Make sure the monitoring agent is installed on your droplet.`);
        return { droplet_id, metric_type: type, data: [] };
      }
      let output = `Droplet Metrics for ${droplet_id}:
`;
      output += `Metric Type: ${type}

`;
      const processedResults = response.data.result.map((result) => {
        const values = result.values || [];
        if (values.length === 0) return null;
        const latestValue = values[values.length - 1];
        const firstValue = values[0];
        output += `Metric Series:
`;
        output += `  Latest Value: ${latestValue[1]} (${new Date(latestValue[0] * 1e3).toLocaleString()})
`;
        output += `  First Value: ${firstValue[1]} (${new Date(firstValue[0] * 1e3).toLocaleString()})
`;
        output += `  Total Data Points: ${values.length}
`;
        const numericValues = values.map((v) => parseFloat(v[1])).filter((v) => !isNaN(v));
        if (numericValues.length > 0) {
          const avg = numericValues.reduce((a, b) => a + b, 0) / numericValues.length;
          const max = Math.max(...numericValues);
          const min = Math.min(...numericValues);
          output += `  Average: ${avg.toFixed(2)}
`;
          output += `  Maximum: ${max}
`;
          output += `  Minimum: ${min}
`;
        }
        output += "\n";
        return {
          values,
          latest: { value: latestValue[1], timestamp: latestValue[0] },
          first: { value: firstValue[1], timestamp: firstValue[0] },
          count: values.length,
          stats: numericValues.length > 0 ? {
            average: numericValues.reduce((a, b) => a + b, 0) / numericValues.length,
            maximum: Math.max(...numericValues),
            minimum: Math.min(...numericValues)
          } : null
        };
      }).filter(Boolean);
      cli.output(output.trim());
      return {
        droplet_id,
        metric_type: type,
        data: processedResults,
        query_params: { start_time, end_time }
      };
    } catch (error) {
      throw new Error(`Failed to get droplet metrics: ${error.message}`);
    }
  }
  getDropletCpuMetrics(args) {
    return this.getDropletMetrics({ ...args, type: "v1/insights/droplet/cpu" });
  }
  getDropletMemoryMetrics(args) {
    return this.getDropletMetrics({ ...args, type: "v1/insights/droplet/memory_utilization_percent" });
  }
  getDropletDiskMetrics(args) {
    return this.getDropletMetrics({ ...args, type: "v1/insights/droplet/disk_utilization_percent" });
  }
  getDropletNetworkMetrics(args) {
    const direction = args.direction || "inbound";
    const interface_type = args.interface || "public";
    return this.getDropletMetrics({
      ...args,
      type: `v1/insights/droplet/bandwidth_utilization_percent_${direction}_${interface_type}`
    });
  }
  getAppMetrics(args) {
    try {
      const app_id = args.app_id;
      const component = args.component;
      const start_time = args.start_time;
      const end_time = args.end_time;
      if (!app_id) {
        throw new Error("App ID is required (use app_id=YOUR-APP-ID component=web)");
      }
      if (!component) {
        throw new Error("Component is required (use component=web)");
      }
      let queryParams = `app_id=${app_id}&app_component=${component}`;
      if (start_time) queryParams += `&start=${start_time}`;
      if (end_time) queryParams += `&end=${end_time}`;
      const response = this.makeRequest("GET", `/monitoring/metrics/apps/cpu_percentage?${queryParams}`);
      if (!response.data?.result || response.data.result.length === 0) {
        cli.output(`No metrics found for app ${app_id}, component ${component}`);
        return { app_id, component, data: [] };
      }
      let output = `App Metrics for ${app_id}:
`;
      output += `Component: ${component}

`;
      const processedResults = response.data.result.map((result) => {
        const values = result.values || [];
        if (values.length === 0) return null;
        const latestValue = values[values.length - 1];
        output += `CPU Usage:
`;
        output += `  Latest: ${latestValue[1]}% (${new Date(latestValue[0] * 1e3).toLocaleString()})
`;
        output += `  Data Points: ${values.length}

`;
        return {
          metric: "cpu_percentage",
          values,
          latest: { value: latestValue[1], timestamp: latestValue[0] },
          count: values.length
        };
      }).filter(Boolean);
      cli.output(output.trim());
      return { app_id, component, data: processedResults };
    } catch (error) {
      throw new Error(`Failed to get app metrics: ${error.message}`);
    }
  }
  getLoadBalancerMetrics(args) {
    try {
      const lb_id = args.lb_id;
      const start_time = args.start_time;
      const end_time = args.end_time;
      if (!lb_id) {
        throw new Error("Load Balancer ID is required (use lb_id=YOUR-LB-ID)");
      }
      let queryParams = `lb_id=${lb_id}`;
      if (start_time) queryParams += `&start=${start_time}`;
      if (end_time) queryParams += `&end=${end_time}`;
      const response = this.makeRequest("GET", `/monitoring/metrics/load_balancer/connections?${queryParams}`);
      if (!response.data?.result || response.data.result.length === 0) {
        cli.output(`No metrics found for load balancer ${lb_id}`);
        return { lb_id, data: [] };
      }
      let output = `Load Balancer Metrics for ${lb_id}:

`;
      const processedResults = response.data.result.map((result) => {
        const values = result.values || [];
        if (values.length === 0) return null;
        const latestValue = values[values.length - 1];
        output += `Connections:
`;
        output += `  Latest: ${latestValue[1]} (${new Date(latestValue[0] * 1e3).toLocaleString()})
`;
        output += `  Data Points: ${values.length}

`;
        return {
          metric: "connections",
          values,
          latest: { value: latestValue[1], timestamp: latestValue[0] },
          count: values.length
        };
      }).filter(Boolean);
      cli.output(output.trim());
      return { lb_id, data: processedResults };
    } catch (error) {
      throw new Error(`Failed to get load balancer metrics: ${error.message}`);
    }
  }
  getDatabaseMetrics(args) {
    try {
      const db_id = args.db_id;
      const start_time = args.start_time;
      const end_time = args.end_time;
      if (!db_id) {
        throw new Error("Database ID is required (use db_id=YOUR-DB-ID)");
      }
      let queryParams = `db_id=${db_id}`;
      if (start_time) queryParams += `&start=${start_time}`;
      if (end_time) queryParams += `&end=${end_time}`;
      const response = this.makeRequest("GET", `/monitoring/metrics/databases/cpu?${queryParams}`);
      if (!response.data?.result || response.data.result.length === 0) {
        cli.output(`No metrics found for database ${db_id}`);
        return { db_id, data: [] };
      }
      let output = `Database Metrics for ${db_id}:

`;
      const processedResults = response.data.result.map((result) => {
        const values = result.values || [];
        if (values.length === 0) return null;
        const latestValue = values[values.length - 1];
        output += `CPU Usage:
`;
        output += `  Latest: ${latestValue[1]}% (${new Date(latestValue[0] * 1e3).toLocaleString()})
`;
        output += `  Data Points: ${values.length}

`;
        return {
          metric: "cpu",
          values,
          latest: { value: latestValue[1], timestamp: latestValue[0] },
          count: values.length
        };
      }).filter(Boolean);
      cli.output(output.trim());
      return { db_id, data: processedResults };
    } catch (error) {
      throw new Error(`Failed to get database metrics: ${error.message}`);
    }
  }
  enableAlertPolicy(args) {
    try {
      const uuid = args.uuid || this.state.uuid;
      if (!uuid) throw new Error("Alert policy UUID is required (use uuid=policy-uuid)");
      const currentResponse = this.makeRequest("GET", `/monitoring/alerts/${uuid}`);
      const currentPolicy = currentResponse.policy || currentResponse.alert || currentResponse;
      const updateData = {
        type: currentPolicy.type,
        description: currentPolicy.description,
        compare: currentPolicy.compare,
        value: currentPolicy.value,
        window: currentPolicy.window,
        entities: currentPolicy.entities || [],
        tags: currentPolicy.tags || [],
        alerts: currentPolicy.alerts || { email: [], slack: [] },
        enabled: true
      };
      const response = this.makeRequest("PUT", `/monitoring/alerts/${uuid}`, updateData);
      const policy = response.policy || response.alert || response;
      cli.output(`Alert policy ${uuid} enabled successfully`);
      return { uuid, enabled: true, policy };
    } catch (error) {
      throw new Error(`Failed to enable alert policy: ${error.message}`);
    }
  }
  disableAlertPolicy(args) {
    try {
      const uuid = args.uuid || this.state.uuid;
      if (!uuid) throw new Error("Alert policy UUID is required (use uuid=policy-uuid)");
      const currentResponse = this.makeRequest("GET", `/monitoring/alerts/${uuid}`);
      const currentPolicy = currentResponse.policy || currentResponse.alert || currentResponse;
      const updateData = {
        type: currentPolicy.type,
        description: currentPolicy.description,
        compare: currentPolicy.compare,
        value: currentPolicy.value,
        window: currentPolicy.window,
        entities: currentPolicy.entities || [],
        tags: currentPolicy.tags || [],
        alerts: currentPolicy.alerts || { email: [], slack: [] },
        enabled: false
      };
      const response = this.makeRequest("PUT", `/monitoring/alerts/${uuid}`, updateData);
      const policy = response.policy || response.alert || response;
      cli.output(`Alert policy ${uuid} disabled successfully`);
      return { uuid, enabled: false, policy };
    } catch (error) {
      throw new Error(`Failed to disable alert policy: ${error.message}`);
    }
  }
  getVolumeMetrics(args) {
    try {
      const volume_id = args.volume_id;
      const start_time = args.start_time;
      const end_time = args.end_time;
      if (!volume_id) {
        throw new Error("Volume ID is required (use volume_id=YOUR-VOLUME-ID)");
      }
      let queryParams = ``;
      if (start_time) queryParams += `start=${start_time}&`;
      if (end_time) queryParams += `end=${end_time}&`;
      queryParams = queryParams.replace(/&$/, "");
      const endpoint = `/monitoring/metrics/volumes/filesystem_size${queryParams ? "?" + queryParams : ""}`;
      const response = this.makeRequest("GET", endpoint);
      if (!response.data?.result?.length) {
        cli.output(`No volume metrics found for volume ${volume_id}`);
        return { volume_id, metrics: [] };
      }
      let output = `Volume Metrics for ${volume_id}:

`;
      response.data.result.forEach((metric, index) => {
        output += `Metric ${index + 1}:
`;
        output += `  Volume: ${metric.metric?.volume_id || "Unknown"}
`;
        output += `  Values: ${metric.values?.length || 0} data points
`;
        if (metric.values?.length > 0) {
          const latestValue = metric.values[metric.values.length - 1];
          output += `  Latest: ${latestValue[1]} bytes at ${new Date(latestValue[0] * 1e3).toISOString()}
`;
        }
        output += `
`;
      });
      cli.output(output.trim());
      return { volume_id, metrics: response.data.result };
    } catch (error) {
      throw new Error(`Failed to get volume metrics: ${error.message}`);
    }
  }
  getDropletBandwidthInbound(args) {
    return this.getDropletMetrics({
      ...args,
      type: "v1/insights/droplet/public_inbound_bandwidth"
    });
  }
  getDropletBandwidthOutbound(args) {
    return this.getDropletMetrics({
      ...args,
      type: "v1/insights/droplet/public_outbound_bandwidth"
    });
  }
  getDropletPrivateBandwidthInbound(args) {
    return this.getDropletMetrics({
      ...args,
      type: "v1/insights/droplet/private_inbound_bandwidth"
    });
  }
  getDropletPrivateBandwidthOutbound(args) {
    return this.getDropletMetrics({
      ...args,
      type: "v1/insights/droplet/private_outbound_bandwidth"
    });
  }
  getDropletDiskRead(args) {
    return this.getDropletMetrics({
      ...args,
      type: "v1/insights/droplet/disk_read"
    });
  }
  getDropletDiskWrite(args) {
    return this.getDropletMetrics({
      ...args,
      type: "v1/insights/droplet/disk_write"
    });
  }
  getDropletLoadAverage1(args) {
    return this.getDropletMetrics({
      ...args,
      type: "v1/insights/droplet/load_1"
    });
  }
  getDropletLoadAverage5(args) {
    return this.getDropletMetrics({
      ...args,
      type: "v1/insights/droplet/load_5"
    });
  }
  getDropletLoadAverage15(args) {
    return this.getDropletMetrics({
      ...args,
      type: "v1/insights/droplet/load_15"
    });
  }
  listDroplets(_args) {
    try {
      const response = this.makeRequest("GET", "/droplets");
      const droplets = response.droplets || [];
      if (droplets.length === 0) {
        cli.output("No droplets found in your account");
        return { droplets: [] };
      }
      cli.output(`Droplets (${droplets.length} total):
`);
      droplets.forEach((droplet, index) => {
        cli.output(`${index + 1}. ${droplet.name}
   ID: ${droplet.id}
   Status: ${droplet.status}
   Region: ${droplet.region?.name || droplet.region}
   Size: ${droplet.size_slug}
   IPv4: ${droplet.networks?.v4?.[0]?.ip_address || "N/A"}
   Tags: ${droplet.tags?.join(", ") || "None"}
   Created: ${droplet.created_at}
`);
      });
      return { droplets };
    } catch (error) {
      throw new Error(`Failed to list droplets: ${error.message}`);
    }
  }
  deleteAlertPolicy(args) {
    try {
      const policy_uuid = args.policy_uuid || this.state.uuid;
      if (!policy_uuid) {
        throw new Error("Policy UUID is required (use policy_uuid=YOUR-POLICY-UUID)");
      }
      this.makeRequest("DELETE", `/monitoring/alerts/${policy_uuid}`);
      cli.output(`Alert policy ${policy_uuid} deleted successfully`);
      return true;
    } catch (error) {
      throw new Error(`Failed to delete alert policy: ${error.message}`);
    }
  }
  listSinks(_args) {
    try {
      const response = this.makeRequest("GET", "/monitoring/sinks");
      const sinks = response.sinks || [];
      if (sinks.length === 0) {
        cli.output("No monitoring sinks found");
        return { sinks: [] };
      }
      cli.output(`Monitoring Sinks (${sinks.length} total):
`);
      sinks.forEach((sink, index) => {
        cli.output(`${index + 1}. ${sink.name}
   ID: ${sink.id}
   Type: ${sink.type}
   Endpoint: ${sink.endpoint || "N/A"}
   Status: ${sink.status || "active"}
   Created: ${sink.created_at || "N/A"}
`);
      });
      return { sinks };
    } catch (error) {
      throw new Error(`Failed to list monitoring sinks: ${error.message}`);
    }
  }
  getSink(args) {
    try {
      const sink_id = args.sink_id;
      if (!sink_id) {
        throw new Error("Sink ID is required (use sink_id=YOUR-SINK-ID)");
      }
      const response = this.makeRequest("GET", `/monitoring/sinks/${sink_id}`);
      const sink = response.sink || response;
      cli.output(`Monitoring Sink Details:
Name: ${sink.name}
ID: ${sink.id}
Type: ${sink.type}
Endpoint: ${sink.endpoint || "N/A"}
Status: ${sink.status || "active"}
Created: ${sink.created_at || "N/A"}`);
      return sink;
    } catch (error) {
      throw new Error(`Failed to get monitoring sink: ${error.message}`);
    }
  }
  getAllDropletMetrics(args) {
    try {
      const droplet_id = args.droplet_id;
      if (!droplet_id) {
        throw new Error("Droplet ID is required (use droplet_id=YOUR-DROPLET-ID)");
      }
      const metrics = [
        "v1/insights/droplet/cpu",
        "v1/insights/droplet/memory_utilization_percent",
        "v1/insights/droplet/disk_utilization_percent",
        "v1/insights/droplet/load_1",
        "v1/insights/droplet/load_5",
        "v1/insights/droplet/load_15"
      ];
      let output = `All Metrics for Droplet ${droplet_id}:

`;
      const results = {};
      let hasData = false;
      metrics.forEach((metric) => {
        try {
          const metricResult = this.getDropletMetricsInternal({ ...args, type: metric });
          if (metricResult && metricResult.data?.result?.length > 0) {
            results[metric] = metricResult;
            const values = metricResult.data.result[0]?.values;
            if (values && values.length > 0) {
              const latestValue = values[values.length - 1][1];
              output += `${metric}: ${latestValue} (${values.length} data points)
`;
              hasData = true;
            } else {
              output += `${metric}: No data available
`;
            }
          } else {
            output += `${metric}: No data available
`;
          }
        } catch (error) {
          output += `${metric}: Unavailable (${error.message.split(":")[0]})
`;
        }
      });
      if (!hasData) {
        cli.output(`No metrics data available for Droplet ${droplet_id}
Note: Make sure the monitoring agent is installed on your droplet:
curl -sSL https://repos.insights.digitalocean.com/install.sh | sudo bash`);
      } else {
        cli.output(output.trim());
      }
      return { droplet_id, all_metrics: results };
    } catch (error) {
      throw new Error(`Failed to get all droplet metrics: ${error.message}`);
    }
  }
  // Internal method that doesn't output to CLI
  getDropletMetricsInternal(args) {
    const droplet_id = args.droplet_id;
    const type = args.type || "v1/insights/droplet/cpu";
    let start_time = args.start_time;
    let end_time = args.end_time;
    if (!droplet_id) {
      throw new Error("Droplet ID is required");
    }
    validateAlertPolicyType(type);
    if (!end_time) {
      end_time = (/* @__PURE__ */ new Date()).toISOString();
    }
    if (!start_time) {
      const oneHourAgo = new Date(Date.now() - 60 * 60 * 1e3);
      start_time = oneHourAgo.toISOString();
    }
    let queryParams = `host_id=${droplet_id}&start=${start_time}&end=${end_time}`;
    const metricPath = type.replace("v1/insights/droplet/", "");
    const response = this.makeRequest("GET", `/monitoring/metrics/droplet/${metricPath}?${queryParams}`);
    return response;
  }
  findExistingPolicy() {
    if (this.definition.create_when_missing === false) {
      return null;
    }
    try {
      const response = this.makeRequest("GET", "/monitoring/alerts");
      const alerts = response.alerts || response.policies || [];
      if (!alerts) {
        return null;
      }
      const existingPolicy = alerts.find(
        (policy) => policy.description === this.definition.name || policy.description === `Alert policy for ${this.definition.name}`
      );
      return existingPolicy || null;
    } catch (error) {
      return null;
    }
  }
  buildPolicyData(emails) {
    const emailsToUse = emails || this.definition.emails || [];
    if (emailsToUse.length === 0 && (!this.definition.slack_channels || this.definition.slack_channels.length === 0)) {
      throw new Error("Alert policy must have at least one action (email or slack). Please provide emails or slack_channels.");
    }
    return {
      type: this.definition.metric_type,
      description: this.definition.alert_description || `Alert policy for ${this.definition.name}`,
      compare: this.definition.compare,
      value: this.definition.value,
      window: this.definition.window,
      entities: this.definition.entities || [],
      tags: this.definition.tags || [],
      alerts: {
        email: emailsToUse,
        slack: this.definition.slack_channels?.map((ch) => ({
          type: "slack",
          channel: ch.channel,
          url: ch.url
        })) || []
      },
      enabled: this.definition.enabled !== false
    };
  }
  updateStateFromPolicy(policy) {
    this.state.uuid = policy.uuid;
    this.state.name = this.definition.name;
    this.state.alert_description = policy.description;
    this.state.metric_type = policy.type;
    this.state.compare = policy.compare;
    this.state.value = policy.value;
    this.state.window = policy.window;
    this.state.entities = policy.entities;
    this.state.tags = policy.tags;
    this.state.emails = policy.alerts?.email;
    this.state.slack_channels = policy.alerts?.slack?.map((ch) => ({
      channel: ch.channel,
      url: ch.url
    }));
    this.state.enabled = policy.enabled;
  }
};
_init = __decoratorStart(_a);
__decorateElement(_init, 1, "createAlertPolicy", _createAlertPolicy_dec, _DigitalOceanMonitoring);
__decorateElement(_init, 1, "listAlertPolicies", _listAlertPolicies_dec, _DigitalOceanMonitoring);
__decorateElement(_init, 1, "getAlertPolicy", _getAlertPolicy_dec, _DigitalOceanMonitoring);
__decorateElement(_init, 1, "updateAlertPolicy", _updateAlertPolicy_dec, _DigitalOceanMonitoring);
__decorateElement(_init, 1, "getAccountInfo", _getAccountInfo_dec, _DigitalOceanMonitoring);
__decorateElement(_init, 1, "getDropletMetrics", _getDropletMetrics_dec, _DigitalOceanMonitoring);
__decorateElement(_init, 1, "getDropletCpuMetrics", _getDropletCpuMetrics_dec, _DigitalOceanMonitoring);
__decorateElement(_init, 1, "getDropletMemoryMetrics", _getDropletMemoryMetrics_dec, _DigitalOceanMonitoring);
__decorateElement(_init, 1, "getDropletDiskMetrics", _getDropletDiskMetrics_dec, _DigitalOceanMonitoring);
__decorateElement(_init, 1, "getDropletNetworkMetrics", _getDropletNetworkMetrics_dec, _DigitalOceanMonitoring);
__decorateElement(_init, 1, "getAppMetrics", _getAppMetrics_dec, _DigitalOceanMonitoring);
__decorateElement(_init, 1, "getLoadBalancerMetrics", _getLoadBalancerMetrics_dec, _DigitalOceanMonitoring);
__decorateElement(_init, 1, "getDatabaseMetrics", _getDatabaseMetrics_dec, _DigitalOceanMonitoring);
__decorateElement(_init, 1, "enableAlertPolicy", _enableAlertPolicy_dec, _DigitalOceanMonitoring);
__decorateElement(_init, 1, "disableAlertPolicy", _disableAlertPolicy_dec, _DigitalOceanMonitoring);
__decorateElement(_init, 1, "getVolumeMetrics", _getVolumeMetrics_dec, _DigitalOceanMonitoring);
__decorateElement(_init, 1, "getDropletBandwidthInbound", _getDropletBandwidthInbound_dec, _DigitalOceanMonitoring);
__decorateElement(_init, 1, "getDropletBandwidthOutbound", _getDropletBandwidthOutbound_dec, _DigitalOceanMonitoring);
__decorateElement(_init, 1, "getDropletPrivateBandwidthInbound", _getDropletPrivateBandwidthInbound_dec, _DigitalOceanMonitoring);
__decorateElement(_init, 1, "getDropletPrivateBandwidthOutbound", _getDropletPrivateBandwidthOutbound_dec, _DigitalOceanMonitoring);
__decorateElement(_init, 1, "getDropletDiskRead", _getDropletDiskRead_dec, _DigitalOceanMonitoring);
__decorateElement(_init, 1, "getDropletDiskWrite", _getDropletDiskWrite_dec, _DigitalOceanMonitoring);
__decorateElement(_init, 1, "getDropletLoadAverage1", _getDropletLoadAverage1_dec, _DigitalOceanMonitoring);
__decorateElement(_init, 1, "getDropletLoadAverage5", _getDropletLoadAverage5_dec, _DigitalOceanMonitoring);
__decorateElement(_init, 1, "getDropletLoadAverage15", _getDropletLoadAverage15_dec, _DigitalOceanMonitoring);
__decorateElement(_init, 1, "listDroplets", _listDroplets_dec, _DigitalOceanMonitoring);
__decorateElement(_init, 1, "deleteAlertPolicy", _deleteAlertPolicy_dec, _DigitalOceanMonitoring);
__decorateElement(_init, 1, "listSinks", _listSinks_dec, _DigitalOceanMonitoring);
__decorateElement(_init, 1, "getSink", _getSink_dec, _DigitalOceanMonitoring);
__decorateElement(_init, 1, "getAllDropletMetrics", _getAllDropletMetrics_dec, _DigitalOceanMonitoring);
__decoratorMetadata(_init, _DigitalOceanMonitoring);
__name(_DigitalOceanMonitoring, "DigitalOceanMonitoring");
__publicField(_DigitalOceanMonitoring, "readiness", { period: 15, initialDelay: 5, attempts: 40 });
var DigitalOceanMonitoring = _DigitalOceanMonitoring;
var alert_policy_default = DigitalOceanMonitoring;



function main(def, state, ctx) {
  const entity = new DigitalOceanMonitoring(def, state, ctx);
  return entity.main(ctx);
}
