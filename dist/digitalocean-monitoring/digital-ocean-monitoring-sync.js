
// Generated by MonkEC - targeting Goja runtime
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __knownSymbol = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __decoratorStart = (base) => [, , , __create(base?.[__knownSymbol("metadata")] ?? null)];
var __decoratorStrings = ["class", "method", "getter", "setter", "accessor", "field", "value", "get", "set"];
var __expectFn = (fn) => fn !== void 0 && typeof fn !== "function" ? __typeError("Function expected") : fn;
var __decoratorContext = (kind, name, done, metadata, fns) => ({ kind: __decoratorStrings[kind], name, metadata, addInitializer: (fn) => done._ ? __typeError("Already initialized") : fns.push(__expectFn(fn || null)) });
var __decoratorMetadata = (array, target) => __defNormalProp(target, __knownSymbol("metadata"), array[3]);
var __runInitializers = (array, flags, self, value) => {
  for (var i = 0, fns = array[flags >> 1], n = fns && fns.length; i < n; i++) flags & 1 ? fns[i].call(self) : value = fns[i].call(self, value);
  return value;
};
var __decorateElement = (array, flags, name, decorators, target, extra) => {
  var fn, it, done, ctx, access, k = flags & 7, s = !!(flags & 8), p = !!(flags & 16);
  var j = k > 3 ? array.length + 1 : k ? s ? 1 : 2 : 0, key = __decoratorStrings[k + 5];
  var initializers = k > 3 && (array[j - 1] = []), extraInitializers = array[j] || (array[j] = []);
  var desc = k && (!p && !s && (target = target.prototype), k < 5 && (k > 3 || !p) && __getOwnPropDesc(k < 4 ? target : { get [name]() {
    return __privateGet(this, extra);
  }, set [name](x) {
    return __privateSet(this, extra, x);
  } }, name));
  k ? p && k < 4 && __name(extra, (k > 2 ? "set " : k > 1 ? "get " : "") + name) : __name(target, name);
  for (var i = decorators.length - 1; i >= 0; i--) {
    ctx = __decoratorContext(k, name, done = {}, array[3], extraInitializers);
    if (k) {
      ctx.static = s, ctx.private = p, access = ctx.access = { has: p ? (x) => __privateIn(target, x) : (x) => name in x };
      if (k ^ 3) access.get = p ? (x) => (k ^ 1 ? __privateGet : __privateMethod)(x, target, k ^ 4 ? extra : desc.get) : (x) => x[name];
      if (k > 2) access.set = p ? (x, y) => __privateSet(x, target, y, k ^ 4 ? extra : desc.set) : (x, y) => x[name] = y;
    }
    it = (0, decorators[i])(k ? k < 4 ? p ? extra : desc[key] : k > 4 ? void 0 : { get: desc.get, set: desc.set } : target, ctx), done._ = 1;
    if (k ^ 4 || it === void 0) __expectFn(it) && (k > 4 ? initializers.unshift(it) : k ? p ? extra = it : desc[key] = it : target = it);
    else if (typeof it !== "object" || it === null) __typeError("Object expected");
    else __expectFn(fn = it.get) && (desc.get = fn), __expectFn(fn = it.set) && (desc.set = fn), __expectFn(fn = it.init) && initializers.unshift(fn);
  }
  return k || __decoratorMetadata(array, target), desc && __defProp(target, name, desc), p ? k ^ 4 ? extra : desc : target;
};
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateIn = (member, obj) => Object(obj) !== obj ? __typeError('Cannot use the "in" operator on this value') : member.has(obj);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);

// input/digitalocean-monitoring/digitalOceanMonitoring.ts
const base = require("monkec/base");
const action = base.action;
const doProviderBase = require("digitalocean-monitoring/do-provider-base");
const DOMonitoringEntity = doProviderBase.DOMonitoringEntity;
const common = require("digitalocean-monitoring/common");
const validateMetricType = common.validateMetricType;
const validateComparisonOperator = common.validateComparisonOperator;
const validateWindow = common.validateWindow;
const validateEmail = common.validateEmail;
const validateSlackUrl = common.validateSlackUrl;
const generateTimeRange = common.generateTimeRange;
const cli = require("cli");
var _getDatabaseMetrics_dec, _getLoadBalancerMetrics_dec, _getAppMetrics_dec, _getVolumeMetrics_dec, _getAllDropletMetrics_dec, _getDropletLoadAverage15_dec, _getDropletLoadAverage5_dec, _getDropletLoadAverage1_dec, _getDropletDiskWrite_dec, _getDropletDiskRead_dec, _getDropletPrivateBandwidthOutbound_dec, _getDropletPrivateBandwidthInbound_dec, _getDropletBandwidthOutbound_dec, _getDropletBandwidthInbound_dec, _getDropletNetworkMetrics_dec, _getDropletDiskMetrics_dec, _getDropletMemoryMetrics_dec, _getDropletCpuMetrics_dec, _getDropletMetrics_dec, _getAccountInfoAction_dec, _getSink_dec, _listSinks_dec, _disableAlertPolicy_dec, _enableAlertPolicy_dec, _getAlertPolicy_dec, _listAlertPolicies_dec, _a, _init;
var _DigitalOceanMonitoring = class _DigitalOceanMonitoring extends (_a = DOMonitoringEntity, _listAlertPolicies_dec = [action("list-alert-policies")], _getAlertPolicy_dec = [action("get-alert-policy")], _enableAlertPolicy_dec = [action("enable-alert-policy")], _disableAlertPolicy_dec = [action("disable-alert-policy")], _listSinks_dec = [action("list-sinks")], _getSink_dec = [action("get-sink")], _getAccountInfoAction_dec = [action("get-account-info")], _getDropletMetrics_dec = [action("get-droplet-metrics")], _getDropletCpuMetrics_dec = [action("get-droplet-cpu-metrics")], _getDropletMemoryMetrics_dec = [action("get-droplet-memory-metrics")], _getDropletDiskMetrics_dec = [action("get-droplet-disk-metrics")], _getDropletNetworkMetrics_dec = [action("get-droplet-network-metrics")], _getDropletBandwidthInbound_dec = [action("get-droplet-bandwidth-inbound")], _getDropletBandwidthOutbound_dec = [action("get-droplet-bandwidth-outbound")], _getDropletPrivateBandwidthInbound_dec = [action("get-droplet-private-bandwidth-inbound")], _getDropletPrivateBandwidthOutbound_dec = [action("get-droplet-private-bandwidth-outbound")], _getDropletDiskRead_dec = [action("get-droplet-disk-read")], _getDropletDiskWrite_dec = [action("get-droplet-disk-write")], _getDropletLoadAverage1_dec = [action("get-droplet-load-average-1")], _getDropletLoadAverage5_dec = [action("get-droplet-load-average-5")], _getDropletLoadAverage15_dec = [action("get-droplet-load-average-15")], _getAllDropletMetrics_dec = [action("get-all-droplet-metrics")], _getVolumeMetrics_dec = [action("get-volume-metrics")], _getAppMetrics_dec = [action("get-app-metrics")], _getLoadBalancerMetrics_dec = [action("get-load-balancer-metrics")], _getDatabaseMetrics_dec = [action("get-database-metrics")], _a) {
  constructor() {
    super(...arguments);
    __runInitializers(_init, 5, this);
  }
  getEntityName() {
    return `DigitalOcean Monitoring: ${this.definition.name}`;
  }
  create() {
    cli.output(`\u{1F680} Creating DigitalOcean monitoring alert policy: ${this.definition.name}`);
    if (!this.shouldCreateWhenMissing()) {
      cli.output(`\u{1F9EA} Test mode: create_when_missing is false, setting ready state without creating`);
      this.state.uuid = "test-mode-uuid";
      this.state.name = this.definition.name;
      this.state.type = this.definition.metric_type;
      this.state.enabled = true;
      return;
    }
    const validatedType = validateMetricType(this.definition.metric_type);
    const validatedCompare = validateComparisonOperator(this.definition.compare);
    const validatedWindow = validateWindow(this.definition.window);
    const existingPolicy = this.findExistingAlertPolicy();
    if (existingPolicy) {
      cli.output(`\u2705 Alert policy ${this.definition.name} already exists`);
      this.state.existing = true;
      this.updateStateFromPolicy(existingPolicy);
      return;
    }
    let notificationEmails = this.definition.emails || [];
    if (notificationEmails.length === 0) {
      const verifiedEmail = this.getVerifiedEmail();
      if (verifiedEmail) {
        notificationEmails = [verifiedEmail];
        cli.output(`\u{1F4E7} Auto-detected verified email: ${verifiedEmail}`);
      }
    }
    notificationEmails.forEach((email) => {
      if (!validateEmail(email)) {
        throw new Error(`Invalid email address: ${email}`);
      }
    });
    if (this.definition.slack_channels) {
      this.definition.slack_channels.forEach((slack) => {
        if (!validateSlackUrl(slack.url)) {
          throw new Error(`Invalid Slack webhook URL: ${slack.url}`);
        }
      });
    }
    const createRequest = {
      type: validatedType,
      description: this.definition.alert_description || `Alert for ${this.definition.name}: ${validatedType} ${validatedCompare} ${this.definition.value}`,
      compare: validatedCompare,
      value: this.definition.value,
      window: validatedWindow,
      entities: this.definition.entities || [],
      tags: this.definition.tags || [],
      alerts: {
        email: notificationEmails,
        slack: this.definition.slack_channels || []
      },
      enabled: this.definition.enabled !== false
    };
    try {
      const response = this.makeRequest("POST", "/monitoring/alerts", createRequest);
      if (response.policy) {
        this.updateStateFromPolicy(response.policy);
        cli.output(`\u2705 Alert policy created successfully: ${this.state.uuid}`);
      } else {
        throw new Error("Invalid response from DigitalOcean API - no policy object returned");
      }
    } catch (error) {
      throw new Error(`Failed to create alert policy: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  update() {
    if (!this.state.uuid) {
      throw new Error("Cannot update alert policy - no policy UUID in state");
    }
    if (!this.shouldCreateWhenMissing()) {
      cli.output(`\u{1F9EA} Test mode: create_when_missing is false, skipping update`);
      return;
    }
    cli.output(`\u{1F504} Updating DigitalOcean alert policy: ${this.state.uuid}`);
    const validatedType = validateMetricType(this.definition.metric_type);
    const validatedCompare = validateComparisonOperator(this.definition.compare);
    const validatedWindow = validateWindow(this.definition.window);
    let notificationEmails = this.definition.emails || [];
    if (notificationEmails.length === 0) {
      const verifiedEmail = this.getVerifiedEmail();
      if (verifiedEmail) {
        notificationEmails = [verifiedEmail];
      }
    }
    notificationEmails.forEach((email) => {
      if (!validateEmail(email)) {
        throw new Error(`Invalid email address: ${email}`);
      }
    });
    if (this.definition.slack_channels) {
      this.definition.slack_channels.forEach((slack) => {
        if (!validateSlackUrl(slack.url)) {
          throw new Error(`Invalid Slack webhook URL: ${slack.url}`);
        }
      });
    }
    const updateRequest = {
      type: validatedType,
      description: this.definition.alert_description || `Alert for ${this.definition.name}: ${validatedType} ${validatedCompare} ${this.definition.value}`,
      compare: validatedCompare,
      value: this.definition.value,
      window: validatedWindow,
      entities: this.definition.entities || [],
      tags: this.definition.tags || [],
      alerts: {
        email: notificationEmails,
        slack: this.definition.slack_channels || []
      },
      enabled: this.definition.enabled !== false
    };
    try {
      const response = this.makeRequest("PUT", `/monitoring/alerts/${this.state.uuid}`, updateRequest);
      if (response.policy) {
        this.updateStateFromPolicy(response.policy);
        cli.output(`\u2705 Alert policy updated successfully`);
      } else {
        cli.output(`\u2705 Alert policy updated (no response data)`);
      }
    } catch (error) {
      throw new Error(`Failed to update alert policy: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  delete() {
    if (!this.state.uuid) {
      cli.output("\u26AA No alert policy UUID in state, nothing to delete");
      return;
    }
    if (!this.shouldCreateWhenMissing()) {
      cli.output(`\u{1F9EA} Test mode: create_when_missing is false, clearing state without deleting`);
      this.state.uuid = void 0;
      this.state.name = void 0;
      this.state.enabled = void 0;
      return;
    }
    this.deleteResource(`/monitoring/alerts/${this.state.uuid}`, `alert policy ${this.state.name || this.state.uuid}`);
    this.state.uuid = void 0;
    this.state.name = void 0;
    this.state.type = void 0;
    this.state.description = void 0;
    this.state.enabled = void 0;
    this.state.alerts = void 0;
  }
  checkReadiness() {
    if (!this.state.uuid) {
      return false;
    }
    if (!this.shouldCreateWhenMissing()) {
      return true;
    }
    try {
      const response = this.makeRequest("GET", `/monitoring/alerts/${this.state.uuid}`);
      if (response.policy) {
        this.updateStateFromPolicy(response.policy);
        cli.output(`\u2705 Alert policy ${this.state.uuid} is ready`);
        return true;
      }
      return false;
    } catch (error) {
      cli.output(`\u274C Failed to check alert policy readiness: ${error instanceof Error ? error.message : "Unknown error"}`);
      return false;
    }
  }
  // === Alert Policy Management Actions (7 actions) ===
  /**
   * Create a new alert policy manually
   */
  createAlertPolicy(args) {
    const name = args.name;
    const type = args.type;
    const compare = args.compare;
    const value = args.value;
    const window = args.window;
    const emails = args.emails;
    if (!name || !type || !compare || !value || !window) {
      throw new Error("Required parameters: --name, --type, --compare, --value, --window");
    }
    const validatedType = validateMetricType(type);
    const validatedCompare = validateComparisonOperator(compare);
    const validatedWindow = validateWindow(window);
    let notificationEmails = [];
    if (emails) {
      notificationEmails = emails.split(",").map((email) => email.trim());
    } else {
      const verifiedEmail = this.getVerifiedEmail();
      if (verifiedEmail) {
        notificationEmails = [verifiedEmail];
      }
    }
    notificationEmails.forEach((email) => {
      if (!validateEmail(email)) {
        throw new Error(`Invalid email address: ${email}`);
      }
    });
    const createRequest = {
      type: validatedType,
      description: `Manual alert: ${name}`,
      compare: validatedCompare,
      value: parseFloat(value),
      window: validatedWindow,
      entities: args.entities ? args.entities.split(",") : [],
      tags: args.tags ? args.tags.split(",") : [],
      alerts: {
        email: notificationEmails,
        slack: []
      },
      enabled: true
    };
    try {
      const response = this.makeRequest("POST", "/monitoring/alerts", createRequest);
      if (response.policy) {
        cli.output(`\u2705 Successfully created alert policy: ${response.policy.uuid}
   Type: ${response.policy.type}
   Description: ${response.policy.description}
   Compare: ${response.policy.compare} ${response.policy.value}
   Window: ${response.policy.window}`);
      }
    } catch (error) {
      throw new Error(`Failed to create alert policy: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  listAlertPolicies(_args) {
    try {
      const response = this.makeRequest("GET", "/monitoring/alerts");
      const policies = response.policies || [];
      let output = `\u{1F4CB} Alert Policies (${policies.length} total):`;
      if (policies.length === 0) {
        output += "\n   No alert policies found";
      } else {
        policies.forEach((policy, index) => {
          const status = policy.enabled ? "\u2705 enabled" : "\u274C disabled";
          output += `
   ${index + 1}. ${policy.uuid} - ${policy.type} ${policy.compare} ${policy.value} (${status})`;
        });
      }
      cli.output(output);
    } catch (error) {
      throw new Error(`Failed to list alert policies: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  getAlertPolicy(args) {
    const policyUuid = args.policy_uuid || this.state.uuid;
    if (!policyUuid) {
      throw new Error("No alert policy UUID available (use --policy_uuid=UUID or ensure entity has a UUID)");
    }
    try {
      const response = this.makeRequest("GET", `/monitoring/alerts/${policyUuid}`);
      if (response.policy) {
        if (policyUuid === this.state.uuid) {
          this.updateStateFromPolicy(response.policy);
        }
        const policy = response.policy;
        let output = `\u{1F4CA} Alert Policy Information:
   UUID: ${policy.uuid}
   Type: ${policy.type}
   Description: ${policy.description}
   Compare: ${policy.compare}
   Value: ${policy.value}
   Window: ${policy.window}
   Enabled: ${policy.enabled}
   Created: ${policy.created_at}`;
        if (policy.entities && policy.entities.length > 0) {
          output += `
   Entities: ${policy.entities.join(", ")}`;
        }
        if (policy.tags && policy.tags.length > 0) {
          output += `
   Tags: ${policy.tags.join(", ")}`;
        }
        if (policy.alerts) {
          if (policy.alerts.email && policy.alerts.email.length > 0) {
            output += `
   Email notifications: ${policy.alerts.email.join(", ")}`;
          }
          if (policy.alerts.slack && policy.alerts.slack.length > 0) {
            output += `
   Slack channels: ${policy.alerts.slack.length} configured`;
          }
        }
        cli.output(output);
      } else {
        throw new Error("Alert policy not found");
      }
    } catch (error) {
      throw new Error(`Failed to get alert policy: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  /**
   * Update an alert policy
   */
  updateAlertPolicy(args) {
    const policyUuid = args.policy_uuid;
    if (!policyUuid) {
      throw new Error("Alert policy UUID is required (use --policy_uuid=UUID)");
    }
    const currentResponse = this.makeRequest("GET", `/monitoring/alerts/${policyUuid}`);
    if (!currentResponse.policy) {
      throw new Error("Alert policy not found");
    }
    const currentPolicy = currentResponse.policy;
    const updateRequest = {
      type: args.type || currentPolicy.type,
      description: args.description || currentPolicy.description,
      compare: args.compare || currentPolicy.compare,
      value: args.value ? parseFloat(args.value) : currentPolicy.value,
      window: args.window || currentPolicy.window,
      entities: args.entities ? args.entities.split(",") : currentPolicy.entities || [],
      tags: args.tags ? args.tags.split(",") : currentPolicy.tags || [],
      alerts: currentPolicy.alerts || { email: [], slack: [] },
      enabled: args.enabled !== void 0 ? args.enabled === "true" : currentPolicy.enabled
    };
    if (args.emails) {
      const notificationEmails = args.emails.split(",").map((email) => email.trim());
      notificationEmails.forEach((email) => {
        if (!validateEmail(email)) {
          throw new Error(`Invalid email address: ${email}`);
        }
      });
      updateRequest.alerts.email = notificationEmails;
    }
    try {
      const response = this.makeRequest("PUT", `/monitoring/alerts/${policyUuid}`, updateRequest);
      let output = `\u2705 Successfully updated alert policy: ${policyUuid}`;
      if (response.policy) {
        output += `
   Type: ${response.policy.type}
   Compare: ${response.policy.compare} ${response.policy.value}
   Enabled: ${response.policy.enabled}`;
      }
      cli.output(output);
    } catch (error) {
      throw new Error(`Failed to update alert policy: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  /**
   * Delete an alert policy
   */
  deleteAlertPolicy(args) {
    const policyUuid = args.policy_uuid;
    if (!policyUuid) {
      throw new Error("Alert policy UUID is required (use --policy_uuid=UUID)");
    }
    try {
      this.makeRequest("DELETE", `/monitoring/alerts/${policyUuid}`);
      cli.output(`\u2705 Successfully deleted alert policy: ${policyUuid}`);
    } catch (error) {
      throw new Error(`Failed to delete alert policy: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  enableAlertPolicy(args) {
    const policyUuid = args.policy_uuid;
    if (!policyUuid) {
      throw new Error("Alert policy UUID is required (use --policy_uuid=UUID)");
    }
    try {
      const currentResponse = this.makeRequest("GET", `/monitoring/alerts/${policyUuid}`);
      if (!currentResponse.policy) {
        throw new Error("Alert policy not found");
      }
      const updateRequest = {
        ...currentResponse.policy,
        enabled: true
      };
      this.makeRequest("PUT", `/monitoring/alerts/${policyUuid}`, updateRequest);
      cli.output(`\u2705 Successfully enabled alert policy: ${policyUuid}`);
    } catch (error) {
      throw new Error(`Failed to enable alert policy: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  disableAlertPolicy(args) {
    const policyUuid = args.policy_uuid;
    if (!policyUuid) {
      throw new Error("Alert policy UUID is required (use --policy_uuid=UUID)");
    }
    try {
      const currentResponse = this.makeRequest("GET", `/monitoring/alerts/${policyUuid}`);
      if (!currentResponse.policy) {
        throw new Error("Alert policy not found");
      }
      const updateRequest = {
        ...currentResponse.policy,
        enabled: false
      };
      this.makeRequest("PUT", `/monitoring/alerts/${policyUuid}`, updateRequest);
      cli.output(`\u2705 Successfully disabled alert policy: ${policyUuid}`);
    } catch (error) {
      throw new Error(`Failed to disable alert policy: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  listSinks(_args) {
    try {
      const response = this.makeRequest("GET", "/monitoring/sinks");
      const sinks = response.sinks || [];
      let output = `\u{1F4CB} Monitoring Sinks (${sinks.length} total):`;
      if (sinks.length === 0) {
        output += "\n   No monitoring sinks found";
      } else {
        sinks.forEach((sink, index) => {
          output += `
   ${index + 1}. ${sink.name} (${sink.type})`;
        });
      }
      cli.output(output);
    } catch (error) {
      throw new Error(`Failed to list monitoring sinks: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  getSink(args) {
    const sinkId = args.sink_id;
    if (!sinkId) {
      throw new Error("Sink ID is required (use --sink_id=SINK_ID)");
    }
    try {
      const response = this.makeRequest("GET", `/monitoring/sinks/${sinkId}`);
      if (response.sink) {
        const sink = response.sink;
        cli.output(`\u{1F4CA} Monitoring Sink Information:
   ID: ${sink.id}
   Name: ${sink.name}
   Type: ${sink.type}
   Configuration: ${JSON.stringify(sink.config, null, 2)}`);
      } else {
        throw new Error("Monitoring sink not found");
      }
    } catch (error) {
      throw new Error(`Failed to get monitoring sink: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  getAccountInfoAction(_args) {
    try {
      const response = this.getAccountInfo();
      if (response.account) {
        const account = response.account;
        let output = `\u{1F4CA} DigitalOcean Account Information:
   Email: ${account.email}
   Email Verified: ${account.email_verified ? "\u2705 Yes" : "\u274C No"}
   UUID: ${account.uuid}
   Status: ${account.status}
   Droplet Limit: ${account.droplet_limit}
   Floating IP Limit: ${account.floating_ip_limit}`;
        if (account.status_message) {
          output += `
   Status Message: ${account.status_message}`;
        }
        cli.output(output);
      } else {
        throw new Error("Account information not found");
      }
    } catch (error) {
      throw new Error(`Failed to get account info: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  getDropletMetrics(args) {
    const dropletId = args.droplet_id;
    const metricType = args.metric_type;
    if (!dropletId) {
      throw new Error("Droplet ID is required (use --droplet_id=DROPLET_ID)");
    }
    if (!metricType) {
      throw new Error("Metric type is required (use --metric_type=METRIC_TYPE)");
    }
    const validatedType = validateMetricType(metricType);
    let startTime = args.start_time;
    let endTime = args.end_time;
    if (!startTime || !endTime) {
      const timeRange = generateTimeRange();
      startTime = timeRange.start_time;
      endTime = timeRange.end_time;
      cli.output(`\u{1F4C5} Using auto time range: ${startTime} to ${endTime}`);
    }
    try {
      const queryParams = `type=${encodeURIComponent(validatedType)}&start=${encodeURIComponent(startTime)}&end=${encodeURIComponent(endTime)}`;
      const response = this.makeRequest("GET", `/monitoring/metrics/droplet/${dropletId}?${queryParams}`);
      cli.output(`\u{1F4CA} Droplet Metrics (${dropletId}):
   Metric Type: ${validatedType}
   Time Range: ${startTime} to ${endTime}`);
      if (response.data && response.data.result) {
        const results = response.data.result;
        let dataOutput = `   Data Points: ${results.length}`;
        results.forEach((result, index) => {
          if (result.values && result.values.length > 0) {
            const latestValue = result.values[result.values.length - 1];
            dataOutput += `
   ${index + 1}. Latest Value: ${latestValue[1]} at ${new Date(latestValue[0] * 1e3).toISOString()}`;
          }
        });
        cli.output(dataOutput);
      } else {
        cli.output("   No data available for this time range");
      }
    } catch (error) {
      throw new Error(`Failed to get droplet metrics: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  getDropletCpuMetrics(args) {
    const dropletId = args.droplet_id;
    if (!dropletId) {
      throw new Error("Droplet ID is required (use --droplet_id=DROPLET_ID)");
    }
    const timeRange = generateTimeRange();
    try {
      const queryParams = `type=${encodeURIComponent("v1/insights/droplet/cpu")}&start=${encodeURIComponent(timeRange.start_time)}&end=${encodeURIComponent(timeRange.end_time)}`;
      const response = this.makeRequest("GET", `/monitoring/metrics/droplet/${dropletId}?${queryParams}`);
      cli.output(`\u{1F5A5}\uFE0F Droplet CPU Metrics (${dropletId}):
   Time Range: Last 1 hour`);
      this.displayMetricsResponse(response, "CPU Utilization %");
    } catch (error) {
      throw new Error(`Failed to get droplet CPU metrics: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  getDropletMemoryMetrics(args) {
    const dropletId = args.droplet_id;
    if (!dropletId) {
      throw new Error("Droplet ID is required (use --droplet_id=DROPLET_ID)");
    }
    const timeRange = generateTimeRange();
    try {
      const queryParams = `type=${encodeURIComponent("v1/insights/droplet/memory_utilization_percent")}&start=${encodeURIComponent(timeRange.start_time)}&end=${encodeURIComponent(timeRange.end_time)}`;
      const response = this.makeRequest("GET", `/monitoring/metrics/droplet/${dropletId}?${queryParams}`);
      cli.output(`\u{1F4BE} Droplet Memory Metrics (${dropletId}):
   Time Range: Last 1 hour`);
      this.displayMetricsResponse(response, "Memory Utilization %");
    } catch (error) {
      throw new Error(`Failed to get droplet memory metrics: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  getDropletDiskMetrics(args) {
    const dropletId = args.droplet_id;
    if (!dropletId) {
      throw new Error("Droplet ID is required (use --droplet_id=DROPLET_ID)");
    }
    const timeRange = generateTimeRange();
    try {
      const queryParams = `type=${encodeURIComponent("v1/insights/droplet/disk_utilization_percent")}&start=${encodeURIComponent(timeRange.start_time)}&end=${encodeURIComponent(timeRange.end_time)}`;
      const response = this.makeRequest("GET", `/monitoring/metrics/droplet/${dropletId}?${queryParams}`);
      cli.output(`\u{1F4BD} Droplet Disk Metrics (${dropletId}):
   Time Range: Last 1 hour`);
      this.displayMetricsResponse(response, "Disk Utilization %");
    } catch (error) {
      throw new Error(`Failed to get droplet disk metrics: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  getDropletNetworkMetrics(args) {
    const dropletId = args.droplet_id;
    if (!dropletId) {
      throw new Error("Droplet ID is required (use --droplet_id=DROPLET_ID)");
    }
    const timeRange = generateTimeRange();
    const metrics = [
      { type: "v1/insights/droplet/public_inbound_bandwidth", name: "Public Inbound Bandwidth" },
      { type: "v1/insights/droplet/public_outbound_bandwidth", name: "Public Outbound Bandwidth" },
      { type: "v1/insights/droplet/private_inbound_bandwidth", name: "Private Inbound Bandwidth" },
      { type: "v1/insights/droplet/private_outbound_bandwidth", name: "Private Outbound Bandwidth" }
    ];
    cli.output(`\u{1F310} Droplet Network Metrics (${dropletId}):
   Time Range: Last 1 hour`);
    try {
      let output = "";
      for (const metric of metrics) {
        const queryParams = `type=${encodeURIComponent(metric.type)}&start=${encodeURIComponent(timeRange.start_time)}&end=${encodeURIComponent(timeRange.end_time)}`;
        const response = this.makeRequest("GET", `/monitoring/metrics/droplet/${dropletId}?${queryParams}`);
        output += `

\u{1F4CA} ${metric.name}:`;
        output += this.formatMetricsResponse(response, "Bytes");
      }
      if (output) {
        cli.output(output);
      }
    } catch (error) {
      throw new Error(`Failed to get droplet network metrics: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  getDropletBandwidthInbound(args) {
    const dropletId = args.droplet_id;
    if (!dropletId) {
      throw new Error("Droplet ID is required (use --droplet_id=DROPLET_ID)");
    }
    this.getSpecificDropletMetric(dropletId, "v1/insights/droplet/public_inbound_bandwidth", "\u{1F4E5} Public Inbound Bandwidth");
  }
  getDropletBandwidthOutbound(args) {
    const dropletId = args.droplet_id;
    if (!dropletId) {
      throw new Error("Droplet ID is required (use --droplet_id=DROPLET_ID)");
    }
    this.getSpecificDropletMetric(dropletId, "v1/insights/droplet/public_outbound_bandwidth", "\u{1F4E4} Public Outbound Bandwidth");
  }
  getDropletPrivateBandwidthInbound(args) {
    const dropletId = args.droplet_id;
    if (!dropletId) {
      throw new Error("Droplet ID is required (use --droplet_id=DROPLET_ID)");
    }
    this.getSpecificDropletMetric(dropletId, "v1/insights/droplet/private_inbound_bandwidth", "\u{1F4E5} Private Inbound Bandwidth");
  }
  getDropletPrivateBandwidthOutbound(args) {
    const dropletId = args.droplet_id;
    if (!dropletId) {
      throw new Error("Droplet ID is required (use --droplet_id=DROPLET_ID)");
    }
    this.getSpecificDropletMetric(dropletId, "v1/insights/droplet/private_outbound_bandwidth", "\u{1F4E4} Private Outbound Bandwidth");
  }
  getDropletDiskRead(args) {
    const dropletId = args.droplet_id;
    if (!dropletId) {
      throw new Error("Droplet ID is required (use --droplet_id=DROPLET_ID)");
    }
    this.getSpecificDropletMetric(dropletId, "v1/insights/droplet/disk_read", "\u{1F4D6} Disk Read Operations");
  }
  getDropletDiskWrite(args) {
    const dropletId = args.droplet_id;
    if (!dropletId) {
      throw new Error("Droplet ID is required (use --droplet_id=DROPLET_ID)");
    }
    this.getSpecificDropletMetric(dropletId, "v1/insights/droplet/disk_write", "\u{1F4DD} Disk Write Operations");
  }
  getDropletLoadAverage1(args) {
    const dropletId = args.droplet_id;
    if (!dropletId) {
      throw new Error("Droplet ID is required (use --droplet_id=DROPLET_ID)");
    }
    this.getSpecificDropletMetric(dropletId, "v1/insights/droplet/load_1", "\u2696\uFE0F 1-Minute Load Average");
  }
  getDropletLoadAverage5(args) {
    const dropletId = args.droplet_id;
    if (!dropletId) {
      throw new Error("Droplet ID is required (use --droplet_id=DROPLET_ID)");
    }
    this.getSpecificDropletMetric(dropletId, "v1/insights/droplet/load_5", "\u2696\uFE0F 5-Minute Load Average");
  }
  getDropletLoadAverage15(args) {
    const dropletId = args.droplet_id;
    if (!dropletId) {
      throw new Error("Droplet ID is required (use --droplet_id=DROPLET_ID)");
    }
    this.getSpecificDropletMetric(dropletId, "v1/insights/droplet/load_15", "\u2696\uFE0F 15-Minute Load Average");
  }
  getAllDropletMetrics(args) {
    const dropletId = args.droplet_id;
    if (!dropletId) {
      throw new Error("Droplet ID is required (use --droplet_id=DROPLET_ID)");
    }
    const timeRange = generateTimeRange();
    const metrics = [
      { type: "v1/insights/droplet/cpu", name: "\u{1F5A5}\uFE0F CPU Utilization" },
      { type: "v1/insights/droplet/memory_utilization_percent", name: "\u{1F4BE} Memory Utilization" },
      { type: "v1/insights/droplet/disk_utilization_percent", name: "\u{1F4BD} Disk Utilization" },
      { type: "v1/insights/droplet/load_1", name: "\u2696\uFE0F 1-Min Load Average" },
      { type: "v1/insights/droplet/load_5", name: "\u2696\uFE0F 5-Min Load Average" },
      { type: "v1/insights/droplet/load_15", name: "\u2696\uFE0F 15-Min Load Average" },
      { type: "v1/insights/droplet/public_inbound_bandwidth", name: "\u{1F4E5} Public Inbound Bandwidth" },
      { type: "v1/insights/droplet/public_outbound_bandwidth", name: "\u{1F4E4} Public Outbound Bandwidth" },
      { type: "v1/insights/droplet/disk_read", name: "\u{1F4D6} Disk Read" },
      { type: "v1/insights/droplet/disk_write", name: "\u{1F4DD} Disk Write" }
    ];
    let output = `\u{1F4CA} All Droplet Metrics (${dropletId}):
   Time Range: Last 1 hour`;
    try {
      for (const metric of metrics) {
        const queryParams = `type=${encodeURIComponent(metric.type)}&start=${encodeURIComponent(timeRange.start_time)}&end=${encodeURIComponent(timeRange.end_time)}`;
        const response = this.makeRequest("GET", `/monitoring/metrics/droplet/${dropletId}?${queryParams}`);
        output += `

${metric.name}:`;
        output += this.formatMetricsResponse(response);
      }
      cli.output(output);
    } catch (error) {
      throw new Error(`Failed to get all droplet metrics: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  getVolumeMetrics(args) {
    const volumeId = args.volume_id;
    if (!volumeId) {
      throw new Error("Volume ID is required (use --volume_id=VOLUME_ID)");
    }
    let startTime = args.start_time;
    let endTime = args.end_time;
    if (!startTime || !endTime) {
      const timeRange = generateTimeRange();
      startTime = timeRange.start_time;
      endTime = timeRange.end_time;
    }
    try {
      const queryParams = `start=${encodeURIComponent(startTime)}&end=${encodeURIComponent(endTime)}`;
      const response = this.makeRequest("GET", `/monitoring/metrics/volume/${volumeId}?${queryParams}`);
      cli.output(`\u{1F4BE} Volume Metrics (${volumeId}):
   Time Range: ${startTime} to ${endTime}`);
      this.displayMetricsResponse(response);
    } catch (error) {
      throw new Error(`Failed to get volume metrics: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  getAppMetrics(args) {
    const appId = args.app_id;
    const component = args.component || "web";
    if (!appId) {
      throw new Error("App ID is required (use --app_id=APP_ID)");
    }
    let startTime = args.start_time;
    let endTime = args.end_time;
    if (!startTime || !endTime) {
      const timeRange = generateTimeRange();
      startTime = timeRange.start_time;
      endTime = timeRange.end_time;
    }
    try {
      const queryParams = `component=${encodeURIComponent(component)}&start=${encodeURIComponent(startTime)}&end=${encodeURIComponent(endTime)}`;
      const response = this.makeRequest("GET", `/monitoring/metrics/app/${appId}?${queryParams}`);
      cli.output(`\u{1F4F1} App Metrics (${appId}):
   Component: ${component}
   Time Range: ${startTime} to ${endTime}`);
      this.displayMetricsResponse(response);
    } catch (error) {
      throw new Error(`Failed to get app metrics: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  getLoadBalancerMetrics(args) {
    const lbId = args.lb_id;
    if (!lbId) {
      throw new Error("Load Balancer ID is required (use --lb_id=LB_ID)");
    }
    let startTime = args.start_time;
    let endTime = args.end_time;
    if (!startTime || !endTime) {
      const timeRange = generateTimeRange();
      startTime = timeRange.start_time;
      endTime = timeRange.end_time;
    }
    try {
      const queryParams = `start=${encodeURIComponent(startTime)}&end=${encodeURIComponent(endTime)}`;
      const response = this.makeRequest("GET", `/monitoring/metrics/load_balancer/${lbId}?${queryParams}`);
      cli.output(`\u2696\uFE0F Load Balancer Metrics (${lbId}):
   Time Range: ${startTime} to ${endTime}`);
      this.displayMetricsResponse(response);
    } catch (error) {
      throw new Error(`Failed to get load balancer metrics: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  getDatabaseMetrics(args) {
    const dbId = args.db_id;
    if (!dbId) {
      throw new Error("Database ID is required (use --db_id=DB_ID)");
    }
    let startTime = args.start_time;
    let endTime = args.end_time;
    if (!startTime || !endTime) {
      const timeRange = generateTimeRange();
      startTime = timeRange.start_time;
      endTime = timeRange.end_time;
    }
    try {
      const queryParams = `start=${encodeURIComponent(startTime)}&end=${encodeURIComponent(endTime)}`;
      const response = this.makeRequest("GET", `/monitoring/metrics/database/${dbId}?${queryParams}`);
      cli.output(`\u{1F5C4}\uFE0F Database Metrics (${dbId}):
   Time Range: ${startTime} to ${endTime}`);
      this.displayMetricsResponse(response);
    } catch (error) {
      throw new Error(`Failed to get database metrics: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  // === Helper Methods ===
  /**
   * Get specific droplet metric
   */
  getSpecificDropletMetric(dropletId, metricType, metricName) {
    const timeRange = generateTimeRange();
    try {
      const queryParams = `type=${encodeURIComponent(metricType)}&start=${encodeURIComponent(timeRange.start_time)}&end=${encodeURIComponent(timeRange.end_time)}`;
      const response = this.makeRequest("GET", `/monitoring/metrics/droplet/${dropletId}?${queryParams}`);
      cli.output(`${metricName} (${dropletId}):
   Time Range: Last 1 hour`);
      this.displayMetricsResponse(response);
    } catch (error) {
      throw new Error(`Failed to get ${metricName.toLowerCase()}: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  /**
   * Display metrics response in a formatted way
   */
  displayMetricsResponse(response, unit) {
    cli.output(this.formatMetricsResponse(response, unit));
  }
  /**
   * Format metrics response as a string
   */
  formatMetricsResponse(response, unit) {
    if (response.data && response.data.result) {
      const results = response.data.result;
      if (results.length === 0) {
        return "\n   No data available for this time range";
      }
      let output = "";
      results.forEach((result, index) => {
        if (result.values && result.values.length > 0) {
          const latestValue = result.values[result.values.length - 1];
          const value = unit ? `${latestValue[1]} ${unit}` : latestValue[1];
          const timestamp = new Date(latestValue[0] * 1e3).toISOString();
          output += `
   ${index + 1}. Latest: ${value} at ${timestamp}
      Data points: ${result.values.length}`;
        } else {
          output += `
   ${index + 1}. No values available`;
        }
      });
      return output;
    } else {
      return "\n   No data available for this time range";
    }
  }
  /**
   * Find existing alert policy by checking description for name
   */
  findExistingAlertPolicy() {
    try {
      const response = this.makeRequest("GET", "/monitoring/alerts");
      if (response.policies && Array.isArray(response.policies)) {
        const byName = response.policies.find(
          (policy) => policy.description && policy.description.includes(this.definition.name)
        );
        if (byName) return byName;
        return response.policies.find(
          (policy) => policy.type === this.definition.metric_type && policy.compare === this.definition.compare && policy.value === this.definition.value && policy.window === this.definition.window
        );
      }
      return null;
    } catch (error) {
      return null;
    }
  }
  /**
   * Update internal state from policy object
   */
  updateStateFromPolicy(policy) {
    this.state.uuid = policy.uuid;
    this.state.name = this.definition.name;
    this.state.type = policy.type;
    this.state.description = policy.description;
    this.state.compare = policy.compare;
    this.state.value = policy.value;
    this.state.window = policy.window;
    this.state.entities = policy.entities;
    this.state.tags = policy.tags;
    this.state.alerts = policy.alerts;
    this.state.enabled = policy.enabled;
    this.state.created_at = policy.created_at;
  }
};
_init = __decoratorStart(_a);
__decorateElement(_init, 1, "listAlertPolicies", _listAlertPolicies_dec, _DigitalOceanMonitoring);
__decorateElement(_init, 1, "getAlertPolicy", _getAlertPolicy_dec, _DigitalOceanMonitoring);
__decorateElement(_init, 1, "enableAlertPolicy", _enableAlertPolicy_dec, _DigitalOceanMonitoring);
__decorateElement(_init, 1, "disableAlertPolicy", _disableAlertPolicy_dec, _DigitalOceanMonitoring);
__decorateElement(_init, 1, "listSinks", _listSinks_dec, _DigitalOceanMonitoring);
__decorateElement(_init, 1, "getSink", _getSink_dec, _DigitalOceanMonitoring);
__decorateElement(_init, 1, "getAccountInfoAction", _getAccountInfoAction_dec, _DigitalOceanMonitoring);
__decorateElement(_init, 1, "getDropletMetrics", _getDropletMetrics_dec, _DigitalOceanMonitoring);
__decorateElement(_init, 1, "getDropletCpuMetrics", _getDropletCpuMetrics_dec, _DigitalOceanMonitoring);
__decorateElement(_init, 1, "getDropletMemoryMetrics", _getDropletMemoryMetrics_dec, _DigitalOceanMonitoring);
__decorateElement(_init, 1, "getDropletDiskMetrics", _getDropletDiskMetrics_dec, _DigitalOceanMonitoring);
__decorateElement(_init, 1, "getDropletNetworkMetrics", _getDropletNetworkMetrics_dec, _DigitalOceanMonitoring);
__decorateElement(_init, 1, "getDropletBandwidthInbound", _getDropletBandwidthInbound_dec, _DigitalOceanMonitoring);
__decorateElement(_init, 1, "getDropletBandwidthOutbound", _getDropletBandwidthOutbound_dec, _DigitalOceanMonitoring);
__decorateElement(_init, 1, "getDropletPrivateBandwidthInbound", _getDropletPrivateBandwidthInbound_dec, _DigitalOceanMonitoring);
__decorateElement(_init, 1, "getDropletPrivateBandwidthOutbound", _getDropletPrivateBandwidthOutbound_dec, _DigitalOceanMonitoring);
__decorateElement(_init, 1, "getDropletDiskRead", _getDropletDiskRead_dec, _DigitalOceanMonitoring);
__decorateElement(_init, 1, "getDropletDiskWrite", _getDropletDiskWrite_dec, _DigitalOceanMonitoring);
__decorateElement(_init, 1, "getDropletLoadAverage1", _getDropletLoadAverage1_dec, _DigitalOceanMonitoring);
__decorateElement(_init, 1, "getDropletLoadAverage5", _getDropletLoadAverage5_dec, _DigitalOceanMonitoring);
__decorateElement(_init, 1, "getDropletLoadAverage15", _getDropletLoadAverage15_dec, _DigitalOceanMonitoring);
__decorateElement(_init, 1, "getAllDropletMetrics", _getAllDropletMetrics_dec, _DigitalOceanMonitoring);
__decorateElement(_init, 1, "getVolumeMetrics", _getVolumeMetrics_dec, _DigitalOceanMonitoring);
__decorateElement(_init, 1, "getAppMetrics", _getAppMetrics_dec, _DigitalOceanMonitoring);
__decorateElement(_init, 1, "getLoadBalancerMetrics", _getLoadBalancerMetrics_dec, _DigitalOceanMonitoring);
__decorateElement(_init, 1, "getDatabaseMetrics", _getDatabaseMetrics_dec, _DigitalOceanMonitoring);
__decoratorMetadata(_init, _DigitalOceanMonitoring);
__name(_DigitalOceanMonitoring, "DigitalOceanMonitoring");
var DigitalOceanMonitoring = _DigitalOceanMonitoring;



function main(def, state, ctx) {
  const entity = new DigitalOceanMonitoring(def, state, ctx);
  return entity.main(ctx);
}
