
// Generated by MonkEC - targeting Goja runtime
var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });

// input/aws-ec2/subnet.ts
const base = require("aws-ec2/base");
const AWSEC2Entity = base.AWSEC2Entity;
var _Subnet = class _Subnet extends AWSEC2Entity {
  getSubnetId() {
    return this.state.subnet_id;
  }
  create() {
    const createParams = {
      VpcId: this.definition.vpc_id,
      CidrBlock: this.definition.cidr_block
    };
    if (this.definition.availability_zone) {
      createParams.AvailabilityZone = this.definition.availability_zone;
    }
    const resp = this.makeEC2Request("CreateSubnet", createParams);
    const body = resp.body || "";
    const idMatch = /<subnetId>(subnet-[^<]+)<\/subnetId>/i.exec(body);
    if (!idMatch) {
      throw new Error("Failed to parse SubnetId from CreateSubnet response");
    }
    const subnetId = idMatch[1];
    if (this.definition.map_public_ip_on_launch !== void 0) {
      this.makeEC2Request("ModifySubnetAttribute", {
        SubnetId: subnetId,
        "MapPublicIpOnLaunch.Value": String(this.definition.map_public_ip_on_launch)
      });
    }
    if (this.definition.tags && Object.keys(this.definition.tags).length > 0) {
      let idx = 1;
      const tagParams = { "ResourceId.1": subnetId };
      for (const [k, v] of Object.entries(this.definition.tags)) {
        tagParams[`Tag.${idx}.Key`] = k;
        tagParams[`Tag.${idx}.Value`] = v;
        idx++;
      }
      this.makeEC2Request("CreateTags", tagParams);
    }
    this.state.existing = false;
    this.state.subnet_id = subnetId;
    this.state.cidr_block = this.definition.cidr_block;
    this.state.state = "available";
  }
  delete() {
    if (!this.state.subnet_id) return;
    if (this.state.existing) return;
    this.makeEC2Request("DeleteSubnet", { SubnetId: this.state.subnet_id });
    this.state.subnet_id = void 0;
  }
  checkReadiness() {
    if (!this.state.subnet_id) return false;
    const info = this.describeSubnetById(this.state.subnet_id);
    if (!info) return false;
    this.state.state = info.state;
    this.state.cidr_block = info.cidr;
    return info.state === "available";
  }
  describeSubnetById(subnetId) {
    const resp = this.makeEC2Request("DescribeSubnets", { "SubnetId.1": subnetId });
    const body = resp.body || "";
    const idMatch = /<subnetId>(subnet-[^<]+)<\/subnetId>/i.exec(body);
    if (!idMatch) return null;
    const stateMatch = /<state>(.*?)<\/state>/i.exec(body);
    const cidrMatch = /<cidrBlock>(.*?)<\/cidrBlock>/i.exec(body);
    return { subnetId: idMatch[1], state: stateMatch ? stateMatch[1] : "available", cidr: cidrMatch ? cidrMatch[1] : "" };
  }
};
__name(_Subnet, "Subnet");
var Subnet = _Subnet;



function main(def, state, ctx) {
  const entity = new Subnet(def, state, ctx);
  return entity.main(ctx);
}
