
// Generated by MonkEC - targeting Goja runtime
var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });

// input/aws-ec2/securityGroup.ts
const base = require("aws-ec2/base");
const AWSEC2Entity = base.AWSEC2Entity;
var _SecurityGroup = class _SecurityGroup extends AWSEC2Entity {
  create() {
    if (this.definition.group_id) {
      this.state.group_id = this.definition.group_id;
      this.state.group_name = this.definition.group_name;
      this.state.existing = true;
      return;
    }
    const resp = this.makeEC2Request("CreateSecurityGroup", {
      GroupName: this.definition.group_name,
      GroupDescription: this.definition.group_description,
      VpcId: this.definition.vpc_id
    });
    const body = resp.body || "";
    const idMatch = /<groupId>(sg-[a-z0-9]+)<\/groupId>|<groupId>(sg-[A-Za-z0-9]+)<\/groupId>|<groupId>(sg-[^<]+)<\/groupId>/.exec(body) || /<groupId>(sg-[^<]+)<\/groupId>/.exec(body) || /<GroupId>(sg-[^<]+)<\/GroupId>/.exec(body);
    const fallbackMatch = /<GroupId>(sg-[a-z0-9]+)<\/GroupId>/.exec(body);
    const groupId = idMatch?.[1] || fallbackMatch?.[1];
    if (!groupId) {
      throw new Error("Failed to parse GroupId from CreateSecurityGroup response");
    }
    if (this.definition.tags && Object.keys(this.definition.tags).length > 0) {
      let idx = 1;
      const tagParams = { "ResourceId.1": groupId };
      for (const [k, v] of Object.entries(this.definition.tags)) {
        tagParams[`Tag.${idx}.Key`] = k;
        tagParams[`Tag.${idx}.Value`] = v;
        idx++;
      }
      this.makeEC2Request("CreateTags", tagParams);
    }
    if (this.definition.ingress?.length) {
      const ingressRules = this.definition.ingress.map((r) => ({
        ip_protocol: r.ip_protocol,
        from_port: r.from_port,
        to_port: r.to_port,
        cidr_blocks: r.cidr_blocks ? [...r.cidr_blocks] : void 0,
        source_security_group_id: r.source_security_group_id
      }));
      this.authorizeRules("AuthorizeSecurityGroupIngress", groupId, ingressRules);
    }
    if (this.definition.egress?.length) {
      const egressRules = this.definition.egress.map((r) => ({
        ip_protocol: r.ip_protocol,
        from_port: r.from_port,
        to_port: r.to_port,
        cidr_blocks: r.cidr_blocks ? [...r.cidr_blocks] : void 0,
        source_security_group_id: r.source_security_group_id
      }));
      this.authorizeRules("AuthorizeSecurityGroupEgress", groupId, egressRules);
    }
    this.state.group_id = groupId;
    this.state.group_name = this.definition.group_name;
    this.state.existing = false;
  }
  delete() {
    if (!this.state.group_id) return;
    if (this.state.existing) return;
    this.makeEC2Request("DeleteSecurityGroup", { GroupId: this.state.group_id });
    this.state.group_id = void 0;
  }
  authorizeRules(action, groupId, rules) {
    let permIdx = 1;
    const params = { GroupId: groupId };
    for (const rule of rules) {
      params[`IpPermissions.member.${permIdx}.IpProtocol`] = rule.ip_protocol;
      if (rule.from_port !== void 0) params[`IpPermissions.member.${permIdx}.FromPort`] = String(rule.from_port);
      if (rule.to_port !== void 0) params[`IpPermissions.member.${permIdx}.ToPort`] = String(rule.to_port);
      if (rule.cidr_blocks?.length) {
        let rangeIdx = 1;
        for (const cidr of rule.cidr_blocks) {
          params[`IpPermissions.member.${permIdx}.IpRanges.member.${rangeIdx}.CidrIp`] = cidr;
          rangeIdx++;
        }
      }
      if (rule.source_security_group_id) {
        params[`IpPermissions.member.${permIdx}.UserIdGroupPairs.member.1.GroupId`] = rule.source_security_group_id;
      }
      permIdx++;
    }
    this.makeEC2Request(action, params);
  }
};
__name(_SecurityGroup, "SecurityGroup");
var SecurityGroup = _SecurityGroup;



function main(def, state, ctx) {
  const entity = new SecurityGroup(def, state, ctx);
  return entity.main(ctx);
}
