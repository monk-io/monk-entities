
// Generated by MonkEC - targeting Goja runtime
var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });

// input/aws-ec2/vpc.ts
const ec2Base = require("aws-ec2/ec2-base");
const AWSEC2Entity = ec2Base.AWSEC2Entity;
var _VPC = class _VPC extends AWSEC2Entity {
  getVpcId() {
    return this.definition.vpc_id || this.state.vpc_id;
  }
  create() {
    if (this.definition.vpc_id) {
      const info = this.describeVpcById(this.definition.vpc_id);
      if (!info) {
        throw new Error(`VPC ${this.definition.vpc_id} not found`);
      }
      this.state.existing = true;
      this.state.vpc_id = info.vpcId;
      this.state.state = info.state;
      this.state.cidr_block = info.cidr;
      return;
    }
    if (!this.definition.cidr_block) {
      throw new Error("cidr_block is required to create a VPC");
    }
    const resp = this.makeEC2Request("CreateVpc", {
      CidrBlock: this.definition.cidr_block
    });
    const body = resp.body || "";
    const idMatch = /<vpcId>(vpc-[^<]+)<\/vpcId>/i.exec(body);
    if (!idMatch) {
      throw new Error("Failed to parse VpcId from CreateVpc response");
    }
    const vpcId = idMatch[1];
    if (this.definition.enable_dns_support !== void 0) {
      this.makeEC2Request("ModifyVpcAttribute", {
        VpcId: vpcId,
        "EnableDnsSupport.Value": String(this.definition.enable_dns_support)
      });
    }
    if (this.definition.enable_dns_hostnames !== void 0) {
      this.makeEC2Request("ModifyVpcAttribute", {
        VpcId: vpcId,
        "EnableDnsHostnames.Value": String(this.definition.enable_dns_hostnames)
      });
    }
    if (this.definition.tags && Object.keys(this.definition.tags).length > 0) {
      const tagParams = {
        "ResourceId.1": vpcId
      };
      let idx = 1;
      for (const [k, v] of Object.entries(this.definition.tags)) {
        tagParams[`Tag.${idx}.Key`] = k;
        tagParams[`Tag.${idx}.Value`] = v;
        idx++;
      }
      this.makeEC2Request("CreateTags", tagParams);
    }
    this.state.existing = false;
    this.state.vpc_id = vpcId;
    this.state.cidr_block = this.definition.cidr_block;
    this.state.state = "available";
  }
  delete() {
    if (!this.state.vpc_id) return;
    if (this.state.existing) return;
    this.makeEC2Request("DeleteVpc", { VpcId: this.state.vpc_id });
    this.state.vpc_id = void 0;
    this.state.state = void 0;
  }
  checkReadiness() {
    const vpcId = this.getVpcId();
    if (!vpcId) return false;
    const info = this.describeVpcById(vpcId);
    if (!info) return false;
    this.state.vpc_id = info.vpcId;
    this.state.state = info.state;
    this.state.cidr_block = info.cidr;
    return info.state === "available";
  }
  checkLiveness() {
    const vpcId = this.getVpcId();
    if (!vpcId) {
      throw new Error("VPC ID is missing");
    }
    const info = this.describeVpcById(vpcId);
    if (!info) {
      throw new Error(`VPC ${vpcId} not found`);
    }
    if (info.state !== "available") {
      throw new Error(`VPC ${vpcId} is not available (state: ${info.state})`);
    }
    return true;
  }
  describeVpcById(vpcId) {
    const resp = this.makeEC2Request("DescribeVpcs", { "VpcId.1": vpcId });
    const body = resp.body || "";
    const idMatch = /<vpcId>(vpc-[^<]+)<\/vpcId>/i.exec(body);
    if (!idMatch) return null;
    const stateMatch = /<State>(.*?)<\/State>/.exec(body);
    const cidrMatch = /<CidrBlock>(.*?)<\/CidrBlock>/i.exec(body);
    return { vpcId: idMatch[1], state: stateMatch ? stateMatch[1] : "available", cidr: cidrMatch ? cidrMatch[1] : "" };
  }
};
__name(_VPC, "VPC");
var VPC = _VPC;



function main(def, state, ctx) {
  const entity = new VPC(def, state, ctx);
  return entity.main(ctx);
}
