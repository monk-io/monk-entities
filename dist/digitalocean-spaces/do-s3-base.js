// Generated by MonkEC - targeting Goja runtime
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);

// input/digitalocean-spaces/doS3Base.ts
var do_s3_base_exports = {};
__export(do_s3_base_exports, {
  DOSpacesS3Entity: () => DOSpacesS3Entity
});
module.exports = __toCommonJS(do_s3_base_exports);
var import_base = require("monkec/base");
var import_aws = __toESM(require("cloud/aws"));
var import_cli = __toESM(require("cli"));
var import_secret = __toESM(require("secret"));
function escapeXml(s) {
  return s.replace(/[<>&'\"]/g, function(c) {
    switch (c) {
      case "<":
        return "&lt;";
      case ">":
        return "&gt;";
      case "&":
        return "&amp;";
      case "'":
        return "&apos;";
      case '"':
        return "&quot;";
      default:
        return c;
    }
  });
}
function buildLifecycleConfigXml(rules) {
  const rulesXml = rules.map((rule) => {
    let ruleXml = `<Rule>
  <ID>${escapeXml(rule.id)}</ID>
  <Status>${rule.status}</Status>`;
    if (rule.filter) {
      ruleXml += "\n  <Filter>";
      if (rule.filter.prefix && rule.filter.tags) {
        ruleXml += "\n    <And>";
        ruleXml += `
      <Prefix>${escapeXml(rule.filter.prefix)}</Prefix>`;
        Object.entries(rule.filter.tags).forEach(([key, value]) => {
          ruleXml += `
      <Tag><Key>${escapeXml(key)}</Key><Value>${escapeXml(String(value))}</Value></Tag>`;
        });
        ruleXml += "\n    </And>";
      } else if (rule.filter.prefix) {
        ruleXml += `
    <Prefix>${escapeXml(rule.filter.prefix)}</Prefix>`;
      } else if (rule.filter.tags) {
        Object.entries(rule.filter.tags).forEach(([key, value]) => {
          ruleXml += `
    <Tag><Key>${escapeXml(key)}</Key><Value>${escapeXml(String(value))}</Value></Tag>`;
        });
      }
      ruleXml += "\n  </Filter>";
    }
    if (rule.expiration) {
      ruleXml += "\n  <Expiration>";
      if (rule.expiration.days) {
        ruleXml += `
    <Days>${rule.expiration.days}</Days>`;
      }
      if (rule.expiration.date) {
        ruleXml += `
    <Date>${rule.expiration.date}</Date>`;
      }
      ruleXml += "\n  </Expiration>";
    }
    if (rule.transitions) {
      rule.transitions.forEach((transition) => {
        ruleXml += "\n  <Transition>";
        if (transition.days) {
          ruleXml += `
    <Days>${transition.days}</Days>`;
        }
        if (transition.date) {
          ruleXml += `
    <Date>${transition.date}</Date>`;
        }
        ruleXml += `
    <StorageClass>${transition.storage_class}</StorageClass>`;
        ruleXml += "\n  </Transition>";
      });
    }
    ruleXml += "\n</Rule>";
    return ruleXml;
  }).join("");
  return `<LifecycleConfiguration xmlns="http://s3.amazonaws.com/doc/2006-03-01/">
${rulesXml}
</LifecycleConfiguration>`;
}
var DOSpacesS3Entity = class extends import_base.MonkEntity {
  constructor() {
    super(...arguments);
    __publicField(this, "region");
    __publicField(this, "accessKey");
    __publicField(this, "secretKey");
  }
  before() {
    this.region = this.definition.region;
    const accessRef = this.definition.access_key_secret_ref || "do-spaces-access-key";
    const secretRef = this.definition.secret_key_secret_ref || "do-spaces-secret-key";
    const ak = import_secret.default.get(accessRef);
    const sk = import_secret.default.get(secretRef);
    if (!ak || !sk) {
      throw new Error(`Missing DO Spaces credentials in secrets: access=${accessRef}, secret=${secretRef}`);
    }
    this.accessKey = ak;
    this.secretKey = sk;
  }
  getBucketUrl(bucketName, path) {
    const basePath = path ? path.startsWith("?") ? path : `/${path}` : "";
    return `https://${bucketName}.${this.region}.digitaloceanspaces.com${basePath}`;
  }
  getServiceUrl(path) {
    const basePath = path ? path.startsWith("?") ? path : `/${path}` : "";
    return `https://${this.region}.digitaloceanspaces.com${basePath}`;
  }
  getBucketLocation(bucketName) {
    const url = this.getBucketUrl(bucketName, "?location");
    const response = import_aws.default.get(url, {
      service: "s3",
      region: this.region,
      access: this.accessKey,
      secret: this.secretKey
    });
    if (response.statusCode !== 200) {
      throw new Error(`Failed to get bucket location: ${response.statusCode} ${response.status} - ${response.body || ""}`);
    }
    const match = response.body?.match(/<LocationConstraint>(.*?)<\/LocationConstraint>/);
    return { LocationConstraint: match ? match[1] : void 0 };
  }
  headBucket(bucketName) {
    const url = this.getBucketUrl(bucketName);
    const response = import_aws.default.do(url, {
      method: "HEAD",
      service: "s3",
      region: this.region,
      access: this.accessKey,
      secret: this.secretKey
    });
    if (response.statusCode !== 200 && response.statusCode !== 404) {
      throw new Error(`Failed to check bucket existence: ${response.statusCode} ${response.status}`);
    }
    return response;
  }
  bucketExists(bucketName) {
    try {
      const response = this.headBucket(bucketName);
      return response.statusCode === 200;
    } catch (_e) {
      return false;
    }
  }
  createBucket(bucketName) {
    const url = this.getServiceUrl(`${encodeURIComponent(bucketName)}`);
    const response = import_aws.default.put(url, {
      service: "s3",
      region: "us-east-1",
      access: this.accessKey,
      secret: this.secretKey
    });
    if (response.statusCode !== 200 && response.statusCode !== 201) {
      throw new Error(`Failed to create Space: ${response.statusCode} ${response.status} - ${response.body || ""}`);
    }
    return response;
  }
  deleteBucket(bucketName) {
    const url = this.getBucketUrl(bucketName);
    const response = import_aws.default.delete(url, {
      service: "s3",
      region: this.region,
      access: this.accessKey,
      secret: this.secretKey
    });
    if (response.statusCode !== 204 && response.statusCode !== 200 && response.statusCode !== 404) {
      throw new Error(`Failed to delete Space: ${response.statusCode} ${response.status} - ${response.body || ""}`);
    }
    return response;
  }
  setBucketVersioning(bucketName, enabled) {
    const url = this.getBucketUrl(bucketName, "?versioning");
    const versioningConfig = `<VersioningConfiguration xmlns="http://s3.amazonaws.com/doc/2006-03-01/">
  <Status>${enabled ? "Enabled" : "Suspended"}</Status>
</VersioningConfiguration>`;
    const response = import_aws.default.put(url, {
      service: "s3",
      region: this.region,
      access: this.accessKey,
      secret: this.secretKey,
      headers: { "Content-Type": "application/xml" },
      body: versioningConfig
    });
    if (response.statusCode !== 200) {
      throw new Error(`Failed to set versioning: ${response.statusCode} ${response.status} - ${response.body || ""}`);
    }
    return response;
  }
  setBucketCors(bucketName, corsRules) {
    const url = this.getBucketUrl(bucketName, "?cors");
    const corsRulesXml = corsRules.map((rule) => `
  <CORSRule>
    ${rule.allowed_methods.map((m) => `<AllowedMethod>${m}</AllowedMethod>`).join("")}
    ${rule.allowed_origins.map((o) => `<AllowedOrigin>${o}</AllowedOrigin>`).join("")}
    ${rule.allowed_headers ? rule.allowed_headers.map((h) => `<AllowedHeader>${h}</AllowedHeader>`).join("") : ""}
    ${rule.expose_headers ? rule.expose_headers.map((h) => `<ExposeHeader>${h}</ExposeHeader>`).join("") : ""}
    ${rule.max_age_seconds ? `<MaxAgeSeconds>${rule.max_age_seconds}</MaxAgeSeconds>` : ""}
  </CORSRule>`).join("");
    const corsConfig = `<CORSConfiguration xmlns="http://s3.amazonaws.com/doc/2006-03-01/">${corsRulesXml}
</CORSConfiguration>`;
    const response = import_aws.default.put(url, {
      service: "s3",
      region: this.region,
      access: this.accessKey,
      secret: this.secretKey,
      headers: { "Content-Type": "application/xml" },
      body: corsConfig
    });
    if (response.statusCode !== 200) {
      throw new Error(`Failed to set CORS: ${response.statusCode} ${response.status} - ${response.body || ""}`);
    }
    return response;
  }
  setBucketTags(bucketName, tags) {
    const url = this.getBucketUrl(bucketName, "?tagging");
    const tagsXml = Object.entries(tags).map(([k, v]) => `
    <Tag><Key>${k}</Key><Value>${v}</Value></Tag>`).join("");
    const taggingConfig = `<Tagging xmlns="http://s3.amazonaws.com/doc/2006-03-01/">
  <TagSet>${tagsXml}
  </TagSet>
</Tagging>`;
    const response = import_aws.default.put(url, {
      service: "s3",
      region: this.region,
      access: this.accessKey,
      secret: this.secretKey,
      headers: { "Content-Type": "application/xml" },
      body: taggingConfig
    });
    if (response.statusCode !== 200) {
      throw new Error(`Failed to set tags: ${response.statusCode} ${response.status} - ${response.body || ""}`);
    }
    return response;
  }
  setBucketLifecycle(bucketName, rules) {
    const url = this.getBucketUrl(bucketName, "?lifecycle");
    const lifecycleConfig = buildLifecycleConfigXml(rules);
    const response = import_aws.default.put(url, {
      service: "s3",
      region: this.region,
      access: this.accessKey,
      secret: this.secretKey,
      headers: { "Content-Type": "application/xml" },
      body: lifecycleConfig
    });
    if (response.statusCode !== 200) {
      throw new Error(`Failed to set lifecycle: ${response.statusCode} ${response.status} - ${response.body || ""}`);
    }
    return response;
  }
  // DigitalOcean Spaces does not support AWS PublicAccessBlock; warn only
  setBucketPublicAccessBlock(_bucketName, publicReadAccess, publicWriteAccess) {
    import_cli.default.output(`Warning: Public Access Block is not supported on DigitalOcean Spaces. Requested public_read_access=${publicReadAccess}, public_write_access=${publicWriteAccess}. Skipping.`);
  }
  // Helpers used by derived entity actions (mirroring aws-s3/bucket.ts)
  listBucketObjects(url) {
    const response = import_aws.default.get(url, {
      service: "s3",
      region: this.region,
      access: this.accessKey,
      secret: this.secretKey
    });
    if (response.statusCode !== 200) {
      throw new Error(`Failed to list bucket objects: ${response.statusCode} ${response.status} - ${response.body || ""}`);
    }
    return response;
  }
  generatePresignedUrlForObject(url, method, expires) {
    try {
      const presignedResult = import_aws.default.presign(url, {
        method,
        service: "s3",
        region: this.region,
        expire: expires,
        access: this.accessKey,
        secret: this.secretKey
      });
      return presignedResult;
    } catch (error) {
      throw new Error(`Failed to generate presigned URL: ${error.message}`);
    }
  }
  parseObjectKeysFromResponse(xmlResponse) {
    const objectKeys = [];
    const keyMatches = xmlResponse.match(/<Key>(.*?)<\/Key>/g);
    if (keyMatches) {
      for (const match of keyMatches) {
        const keyMatch = match.match(/<Key>(.*?)<\/Key>/);
        if (keyMatch && keyMatch[1]) {
          objectKeys.push(keyMatch[1]);
        }
      }
    }
    return objectKeys;
  }
  parseObjectInfoFromResponse(xmlResponse) {
    const objects = [];
    const contentMatches = xmlResponse.match(/<Contents>[\s\S]*?<\/Contents>/g);
    if (contentMatches) {
      for (const match of contentMatches) {
        const keyMatch = match.match(/<Key>(.*?)<\/Key>/);
        const sizeMatch = match.match(/<Size>(.*?)<\/Size>/);
        const lastModifiedMatch = match.match(/<LastModified>(.*?)<\/LastModified>/);
        if (keyMatch && sizeMatch && lastModifiedMatch) {
          objects.push({ key: keyMatch[1], size: sizeMatch[1], lastModified: lastModifiedMatch[1] });
        }
      }
    }
    return objects;
  }
  deleteObjectsBatch(bucketName, objectKeys) {
    if (objectKeys.length === 0) return 0;
    const deleteObjectsXml = objectKeys.map((key) => `<Object><Key>${this.escapeXml(key)}</Key></Object>`).join("");
    const deleteRequestXml = `<?xml version="1.0" encoding="UTF-8"?>
<Delete xmlns="http://s3.amazonaws.com/doc/2006-03-01/">
    ${deleteObjectsXml}
</Delete>`;
    const url = this.getBucketUrl(bucketName, "?delete");
    const response = import_aws.default.post(url, {
      service: "s3",
      region: this.region,
      access: this.accessKey,
      secret: this.secretKey,
      headers: { "Content-Type": "application/xml" },
      body: deleteRequestXml
    });
    if (response.statusCode !== 200) {
      import_cli.default.output(`Bulk delete failed (status ${response.statusCode}), falling back to individual deletes`);
      return this.deleteObjectsIndividually(bucketName, objectKeys);
    }
    return objectKeys.length;
  }
  deleteObjectsIndividually(bucketName, objectKeys) {
    let deletedCount = 0;
    for (const key of objectKeys) {
      try {
        const url = this.getBucketUrl(bucketName, encodeURIComponent(key));
        const response = import_aws.default.delete(url, {
          service: "s3",
          region: this.region,
          access: this.accessKey,
          secret: this.secretKey
        });
        if (response.statusCode === 204 || response.statusCode === 200) {
          deletedCount++;
        } else {
          import_cli.default.output(`Warning: failed to delete object ${key}: status ${response.statusCode}`);
        }
      } catch (e) {
        import_cli.default.output(`Warning: failed to delete object ${key}: ${e.message}`);
      }
    }
    return deletedCount;
  }
  escapeXml(unsafe) {
    return unsafe.replace(/[<>&'\"]/g, function(c) {
      switch (c) {
        case "<":
          return "&lt;";
        case ">":
          return "&gt;";
        case "&":
          return "&amp;";
        case "'":
          return "&apos;";
        case '"':
          return "&quot;";
        default:
          return c;
      }
    });
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  DOSpacesS3Entity
});
