
// Generated by MonkEC - targeting Goja runtime
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined") return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);

// input/digitalocean-spaces/spacesKeys.ts
const base = require("monkec/base");
const MonkEntity = base.MonkEntity;
const secret = require("secret");
const cli = require("cli");
var digitalocean = __require("cloud/digitalocean");
var _SpacesKeys = class _SpacesKeys extends MonkEntity {
  getEntityName() {
    return "spaces-keys";
  }
  create() {
    const keyName = this.definition.name || `monk-spaces-full-access-${Date.now()}`;
    const body = JSON.stringify({
      name: keyName,
      grants: [
        {
          bucket: "",
          permission: "fullaccess"
        }
      ]
    });
    const resp = digitalocean.post("/v2/spaces/keys", {
      headers: {
        "Accept": "application/json",
        "Content-Type": "application/json"
      },
      body
    });
    if (resp.statusCode < 200 || resp.statusCode >= 300) {
      throw new Error(`DO API error: ${resp.statusCode} ${resp.status} - ${resp.body || ""}`);
    }
    const data = resp.body ? JSON.parse(resp.body) : {};
    const key = data.key || data.spaces_key || data.spaces_access_key || data;
    const accessKey = key?.access_key;
    const secretKey = key?.secret_key || key?.secret;
    if (!accessKey || !secretKey) {
      throw new Error(`Unexpected DO response for Spaces key creation: ${resp.body || ""}`);
    }
    this.state.id = key.id || accessKey;
    this.state.access_key = accessKey;
    this.state.existing = true;
    secret.set("do-spaces-access-key", accessKey);
    secret.set("do-spaces-secret-key", secretKey);
    cli.output(`Created Spaces key and stored into secrets (do-spaces-access-key / do-spaces-secret-key)`);
  }
  delete() {
    if (!this.state.id) {
      cli.output("No Spaces key id in state; nothing to delete.");
      return;
    }
    const resp = digitalocean.delete(`/v2/spaces/keys/${this.state.id}`, { headers: { "Accept": "application/json" } });
    if (resp.statusCode >= 400 && resp.statusCode !== 404) {
      throw new Error(`Failed to delete key: ${resp.statusCode} ${resp.status} - ${resp.body || ""}`);
    }
    this.state.id = void 0;
    this.state.access_key = void 0;
    this.state.existing = false;
    cli.output(`Deleted Spaces key`);
  }
  checkReadiness() {
    return !!this.state.id;
  }
};
__name(_SpacesKeys, "SpacesKeys");
__publicField(_SpacesKeys, "readiness", { period: 5, initialDelay: 1, attempts: 10 });
var SpacesKeys = _SpacesKeys;



function main(def, state, ctx) {
  const entity = new SpacesKeys(def, state, ctx);
  return entity.main(ctx);
}
