
// Generated by MonkEC - targeting Goja runtime
var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });

// input/stripe/webhookEndpoint.ts
const stripeBase = require("stripe/stripe-base");
const StripeEntity = stripeBase.StripeEntity;
const cli = require("cli");
const secret = require("secret");
var _WebhookEndpoint = class _WebhookEndpoint extends StripeEntity {
  getEntityName() {
    return "stripe-webhook";
  }
  create() {
    let existing = null;
    try {
      const list = this.makeRequest("GET", "/webhook_endpoints");
      const data = Array.isArray(list?.data) ? list.data : [];
      existing = data.find((w) => w.url === this.definition.destination_url);
    } catch {
    }
    const signingSecretRef = this.definition.signing_secret_ref || "stripe-webhook-secret";
    if (existing) {
      this.state = {
        webhook_endpoint_id: existing.id,
        webhook_url: existing.url,
        webhook_signing_secret_secret: signingSecretRef,
        existing: true
      };
      cli.output(`\u2139\uFE0F Reusing existing Stripe webhook endpoint ${existing.id}`);
      return;
    }
    const flatParams = { url: this.definition.destination_url };
    if (this.definition.endpoint_description) {
      flatParams["description"] = this.definition.endpoint_description;
    }
    if (Array.isArray(this.definition.event_types) && this.definition.event_types.length > 0) {
      this.definition.event_types.forEach((eventType, index) => {
        flatParams[`enabled_events[${index}]`] = eventType;
      });
    } else {
      flatParams["enabled_events[0]"] = "*";
    }
    const created = this.makeRequest("POST", "/webhook_endpoints", flatParams);
    if (created?.secret) {
      secret.set(signingSecretRef, created.secret);
    }
    this.state = {
      webhook_endpoint_id: created?.id,
      webhook_url: created?.url,
      webhook_signing_secret_secret: signingSecretRef,
      existing: false
    };
    cli.output(`\u2705 Created Stripe webhook endpoint ${created?.id}`);
  }
  update() {
    if (!this.state?.webhook_endpoint_id) {
      this.create();
      return;
    }
    const id = this.state.webhook_endpoint_id;
    const flatParams = {};
    if (this.definition.destination_url && this.definition.destination_url !== this.state.webhook_url) {
      flatParams["url"] = this.definition.destination_url;
    }
    if (Array.isArray(this.definition.event_types) && this.definition.event_types.length > 0) {
      this.definition.event_types.forEach((e, i) => {
        flatParams[`enabled_events[${i}]`] = e;
      });
    }
    if (this.definition.endpoint_description) {
      flatParams["description"] = this.definition.endpoint_description;
    }
    if (Object.keys(flatParams).length > 0) {
      const updated = this.makeRequest("POST", `/webhook_endpoints/${id}`, flatParams);
      this.state = {
        ...this.state,
        webhook_url: updated?.url || this.state.webhook_url
      };
      cli.output(`\u{1F504} Updated Stripe webhook endpoint ${id}`);
    }
  }
  delete() {
    if (!this.state?.webhook_endpoint_id) return;
    const id = this.state.webhook_endpoint_id;
    try {
      this.makeRequest("DELETE", `/webhook_endpoints/${id}`);
      cli.output(`\u{1F5D1}\uFE0F Deleted Stripe webhook endpoint ${id}`);
    } catch (e) {
      cli.output(`\u26A0\uFE0F Failed to delete webhook endpoint ${id}: ${e instanceof Error ? e.message : String(e)}`);
    }
  }
  checkReadiness() {
    return Boolean(this.state?.webhook_endpoint_id && this.state?.webhook_url);
  }
};
__name(_WebhookEndpoint, "WebhookEndpoint");
var WebhookEndpoint = _WebhookEndpoint;



function main(def, state, ctx) {
  const entity = new WebhookEndpoint(def, state, ctx);
  return entity.main(ctx);
}
