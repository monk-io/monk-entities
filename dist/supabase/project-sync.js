
// Generated by MonkEC - targeting Goja runtime
var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });

// input/supabase/project.ts
const supabaseBase = require("supabase/supabase-base");
const SupabaseEntity = supabaseBase.SupabaseEntity;
const cli = require("cli");
const secret = require("secret");
var _Project = class _Project extends SupabaseEntity {
  getEntityName() {
    return this.definition.name;
  }
  /** Create a new Supabase project */
  create() {
    const existingProject = this.findExistingProject();
    if (existingProject) {
      this.state = {
        id: existingProject.id,
        existing: true
      };
      cli.output(`\u2705 Project ${this.definition.name} already exists (id: ${existingProject.id})`);
      this.fetchAndSaveApiKeys();
      return;
    }
    const dbPassword = this.getOrCreateDatabasePassword();
    const body = {
      name: this.definition.name,
      db_pass: dbPassword,
      organization_id: this.definition.organization_id,
      region_selection: this.definition.region_selection || {
        type: "specific",
        code: "us-east-1"
      }
    };
    if (this.definition.desired_instance_size) {
      body.desired_instance_size = this.definition.desired_instance_size;
    }
    let createObj;
    try {
      createObj = this.makeRequest("POST", "/v1/projects", body);
    } catch (error) {
      let errorMessage = "Unknown error";
      if (error instanceof Error) {
        errorMessage = error.message;
      } else if (typeof error === "string") {
        errorMessage = error;
      }
      cli.output(`\u274C Project creation failed: ${errorMessage}`);
      if (errorMessage.includes("409") || errorMessage.includes("already exists")) {
        cli.output(`\u{1F504} Project creation failed with 409 (project already exists), trying to find existing project...`);
        const retryProject = this.findExistingProject();
        if (retryProject) {
          this.state = {
            id: retryProject.id,
            existing: true
          };
          cli.output(`\u2705 Project ${this.definition.name} already exists after 409 (id: ${retryProject.id})`);
          return;
        }
      }
      throw new Error(`Failed to create project: ${errorMessage}`);
    }
    this.state = {
      id: createObj.id,
      existing: false
    };
    cli.output(`\u2705 Created Supabase project: ${createObj.name} (id: ${createObj.id})`);
    this.fetchAndSaveApiKeys();
  }
  update() {
    if (!this.state.id) {
      this.create();
      return;
    }
    const body = {};
    let hasChanges = false;
    if (this.definition.name) {
      body.name = this.definition.name;
      hasChanges = true;
    }
    if (!hasChanges) {
      cli.output(`\u2139\uFE0F  No changes detected for project: ${this.definition.name}`);
      this.fetchAndSaveApiKeys();
      return;
    }
    const updatedProject = this.makeRequest("PATCH", `/v1/projects/${this.state.id}`, body);
    cli.output(`\u2705 Updated Supabase project: ${updatedProject.name}`);
    this.fetchAndSaveApiKeys();
  }
  delete() {
    if (!this.state.id) {
      cli.output("Project does not exist, nothing to delete");
      return;
    }
    this.deleteResource(`/v1/projects/${this.state.id}`, "Project");
  }
  checkReadiness() {
    if (!this.state.id) {
      return false;
    }
    try {
      const project = this.makeRequest("GET", `/v1/projects/${this.state.id}`);
      const isReady = project && (project.status === "ACTIVE_HEALTHY" || project.status === "ACTIVE" || project.status === "RUNNING");
      if (isReady) {
        cli.output(`\u2705 Project ${this.definition.name} is ready (status: ${project.status})`);
      } else {
        cli.output(`\u23F3 Project ${this.definition.name} not ready yet (status: ${project.status || "unknown"})`);
      }
      return isReady;
    } catch (error) {
      cli.output(`\u26A0\uFE0F  Failed to check project readiness: ${error instanceof Error ? error.message : "Unknown error"}`);
      return false;
    }
  }
  checkLiveness() {
    return this.checkReadiness();
  }
  /**
   * Find existing project by name
   */
  findExistingProject() {
    try {
      const allProjects = this.makeRequest("GET", "/v1/projects");
      if (allProjects && Array.isArray(allProjects)) {
        return allProjects.find((p) => p.name === this.definition.name) || null;
      }
    } catch (error) {
      cli.output(`\u26A0\uFE0F  Could not check for existing projects: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
    return null;
  }
  /**
   * Get or create database password from secret
   * If password is provided in definition, use that
   * Otherwise, try to get from secret, or generate and save new one
   */
  getOrCreateDatabasePassword() {
    if (this.definition.db_pass) {
      return this.definition.db_pass;
    }
    const secretRef = this.definition.db_pass_secret_ref || `${this.definition.name}-db-password`;
    try {
      const storedPassword = secret.get(secretRef);
      if (storedPassword) {
        cli.output(`\u{1F511} Using existing database password from secret: ${secretRef}`);
        return storedPassword;
      }
    } catch (_error) {
    }
    const password = secret.randString(16) + "A1!";
    secret.set(secretRef, password);
    cli.output(`\u{1F511} Generated new database password and saved to secret: ${secretRef}`);
    return password;
  }
  /**
   * Fetch and save API keys to secrets if secret references are provided
   */
  fetchAndSaveApiKeys() {
    if (!this.state.id) {
      return;
    }
    if (!this.definition.anon_api_key_secret_ref && !this.definition.service_role_api_key_secret_ref) {
      return;
    }
    try {
      const apiKeys = this.makeRequest("GET", `/v1/projects/${this.state.id}/api-keys`);
      if (!Array.isArray(apiKeys)) {
        cli.output(`\u26A0\uFE0F  API keys response is not an array`);
        return;
      }
      if (this.definition.anon_api_key_secret_ref) {
        const anonKey = apiKeys.find((key) => key.name === "anon");
        if (anonKey && typeof anonKey.api_key === "string") {
          secret.set(this.definition.anon_api_key_secret_ref, anonKey.api_key);
          cli.output(`\u{1F511} Saved anon API key to secret: ${this.definition.anon_api_key_secret_ref}`);
        } else {
          cli.output(`\u26A0\uFE0F  Anon API key not found in response`);
        }
      }
      if (this.definition.service_role_api_key_secret_ref) {
        const serviceRoleKey = apiKeys.find((key) => key.name === "service_role");
        if (serviceRoleKey && typeof serviceRoleKey.api_key === "string") {
          secret.set(this.definition.service_role_api_key_secret_ref, serviceRoleKey.api_key);
          cli.output(`\u{1F511} Saved service_role API key to secret: ${this.definition.service_role_api_key_secret_ref}`);
        } else {
          cli.output(`\u26A0\uFE0F  Service_role API key not found in response`);
        }
      }
    } catch (error) {
      cli.output(`\u26A0\uFE0F  Failed to fetch API keys: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
};
__name(_Project, "Project");
var Project = _Project;



function main(def, state, ctx) {
  const entity = new Project(def, state, ctx);
  return entity.main(ctx);
}
