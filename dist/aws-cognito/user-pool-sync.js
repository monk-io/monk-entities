
// Generated by MonkEC - targeting Goja runtime
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __knownSymbol = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __decoratorStart = (base) => [, , , __create(base?.[__knownSymbol("metadata")] ?? null)];
var __decoratorStrings = ["class", "method", "getter", "setter", "accessor", "field", "value", "get", "set"];
var __expectFn = (fn) => fn !== void 0 && typeof fn !== "function" ? __typeError("Function expected") : fn;
var __decoratorContext = (kind, name, done, metadata, fns) => ({ kind: __decoratorStrings[kind], name, metadata, addInitializer: (fn) => done._ ? __typeError("Already initialized") : fns.push(__expectFn(fn || null)) });
var __decoratorMetadata = (array, target) => __defNormalProp(target, __knownSymbol("metadata"), array[3]);
var __runInitializers = (array, flags, self, value) => {
  for (var i = 0, fns = array[flags >> 1], n = fns && fns.length; i < n; i++) flags & 1 ? fns[i].call(self) : value = fns[i].call(self, value);
  return value;
};
var __decorateElement = (array, flags, name, decorators, target, extra) => {
  var fn, it, done, ctx, access, k = flags & 7, s = !!(flags & 8), p = !!(flags & 16);
  var j = k > 3 ? array.length + 1 : k ? s ? 1 : 2 : 0, key = __decoratorStrings[k + 5];
  var initializers = k > 3 && (array[j - 1] = []), extraInitializers = array[j] || (array[j] = []);
  var desc = k && (!p && !s && (target = target.prototype), k < 5 && (k > 3 || !p) && __getOwnPropDesc(k < 4 ? target : { get [name]() {
    return __privateGet(this, extra);
  }, set [name](x) {
    return __privateSet(this, extra, x);
  } }, name));
  k ? p && k < 4 && __name(extra, (k > 2 ? "set " : k > 1 ? "get " : "") + name) : __name(target, name);
  for (var i = decorators.length - 1; i >= 0; i--) {
    ctx = __decoratorContext(k, name, done = {}, array[3], extraInitializers);
    if (k) {
      ctx.static = s, ctx.private = p, access = ctx.access = { has: p ? (x) => __privateIn(target, x) : (x) => name in x };
      if (k ^ 3) access.get = p ? (x) => (k ^ 1 ? __privateGet : __privateMethod)(x, target, k ^ 4 ? extra : desc.get) : (x) => x[name];
      if (k > 2) access.set = p ? (x, y) => __privateSet(x, target, y, k ^ 4 ? extra : desc.set) : (x, y) => x[name] = y;
    }
    it = (0, decorators[i])(k ? k < 4 ? p ? extra : desc[key] : k > 4 ? void 0 : { get: desc.get, set: desc.set } : target, ctx), done._ = 1;
    if (k ^ 4 || it === void 0) __expectFn(it) && (k > 4 ? initializers.unshift(it) : k ? p ? extra = it : desc[key] = it : target = it);
    else if (typeof it !== "object" || it === null) __typeError("Object expected");
    else __expectFn(fn = it.get) && (desc.get = fn), __expectFn(fn = it.set) && (desc.set = fn), __expectFn(fn = it.init) && initializers.unshift(fn);
  }
  return k || __decoratorMetadata(array, target), desc && __defProp(target, name, desc), p ? k ^ 4 ? extra : desc : target;
};
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateIn = (member, obj) => Object(obj) !== obj ? __typeError('Cannot use the "in" operator on this value') : member.has(obj);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);

// input/aws-cognito/userPool.ts
const base = require("monkec/base");
const action = base.action;
const cli = require("cli");
const cognitoBase = require("aws-cognito/cognito-base");
const AWSCognitoEntity = cognitoBase.AWSCognitoEntity;
var _createUser_dec, _listUsers_dec, _getPoolInfo_dec, _a, _init;
var _UserPool = class _UserPool extends (_a = AWSCognitoEntity, _getPoolInfo_dec = [action("get-pool-info")], _listUsers_dec = [action("list-users")], _createUser_dec = [action("create-user")], _a) {
  constructor() {
    super(...arguments);
    __runInitializers(_init, 5, this);
  }
  getUserPoolName() {
    return this.definition.pool_name;
  }
  create() {
    console.log(`Creating User Pool: ${this.definition.pool_name}`);
    if (!this.definition.pool_name || this.definition.pool_name.length < 1 || this.definition.pool_name.length > 128) {
      throw new Error("User Pool name must be between 1 and 128 characters");
    }
    const existingPool = this.checkUserPoolExists(this.definition.pool_name);
    if (existingPool && existingPool.UserPool) {
      console.log(`User Pool ${this.definition.pool_name} already exists, adopting it`);
      const state = this.formatUserPoolState(existingPool.UserPool, true);
      Object.assign(this.state, state);
      return;
    }
    const params = {
      PoolName: this.definition.pool_name
    };
    if (this.definition.mfa_configuration) {
      params.MfaConfiguration = this.definition.mfa_configuration;
    }
    if (this.definition.password_policy) {
      params.Policies = {
        PasswordPolicy: {
          MinimumLength: this.definition.password_policy.MinimumLength || 8,
          RequireUppercase: this.definition.password_policy.RequireUppercase !== false,
          RequireLowercase: this.definition.password_policy.RequireLowercase !== false,
          RequireNumbers: this.definition.password_policy.RequireNumbers !== false,
          RequireSymbols: this.definition.password_policy.RequireSymbols || false,
          TemporaryPasswordValidityDays: this.definition.password_policy.TemporaryPasswordValidityDays || 7
        }
      };
    }
    if (this.definition.admin_create_user_config) {
      const adminConfig = {
        AllowAdminCreateUserOnly: this.definition.admin_create_user_config.AllowAdminCreateUserOnly || false,
        InviteMessageAction: this.definition.admin_create_user_config.InviteMessageAction || "EMAIL"
      };
      if (this.definition.admin_create_user_config.TemporaryPasswordValidityDays !== void 0) {
        adminConfig.TemporaryPasswordValidityDays = this.definition.admin_create_user_config.TemporaryPasswordValidityDays;
      }
      params.AdminCreateUserConfig = adminConfig;
    }
    if (this.definition.device_configuration) {
      params.DeviceConfiguration = {
        ChallengeRequiredOnNewDevice: this.definition.device_configuration.ChallengeRequiredOnNewDevice || false,
        DeviceOnlyRememberedOnUserPrompt: this.definition.device_configuration.DeviceOnlyRememberedOnUserPrompt || false
      };
    }
    if (this.definition.email_configuration) {
      const emailConfig = {
        EmailSendingAccount: this.definition.email_configuration.EmailSendingAccount || "COGNITO_DEFAULT"
      };
      if (this.definition.email_configuration.SourceArn) {
        emailConfig.SourceArn = this.definition.email_configuration.SourceArn;
      }
      if (this.definition.email_configuration.ReplyToEmailAddress) {
        emailConfig.ReplyToEmailAddress = this.definition.email_configuration.ReplyToEmailAddress;
      }
      if (this.definition.email_configuration.ConfigurationSet) {
        emailConfig.ConfigurationSet = this.definition.email_configuration.ConfigurationSet;
      }
      if (this.definition.email_configuration.From) {
        emailConfig.From = this.definition.email_configuration.From;
      }
      params.EmailConfiguration = emailConfig;
    }
    if (this.definition.sms_configuration) {
      const smsConfig = {
        SnsCallerArn: this.definition.sms_configuration.SnsCallerArn
      };
      if (this.definition.sms_configuration.ExternalId) {
        smsConfig.ExternalId = this.definition.sms_configuration.ExternalId;
      }
      if (this.definition.sms_configuration.SnsRegion) {
        smsConfig.SnsRegion = this.definition.sms_configuration.SnsRegion;
      }
      params.SmsConfiguration = smsConfig;
    }
    if (this.definition.auto_verified_attributes && this.definition.auto_verified_attributes.length > 0) {
      params.AutoVerifiedAttributes = this.definition.auto_verified_attributes;
    }
    if (this.definition.alias_attributes && this.definition.alias_attributes.length > 0) {
      params.AliasAttributes = this.definition.alias_attributes;
    }
    if (this.definition.username_attributes && this.definition.username_attributes.length > 0) {
      params.UsernameAttributes = this.definition.username_attributes;
    }
    if (this.definition.verification_message_template) {
      const messageTemplate = {};
      if (this.definition.verification_message_template.SmsMessage) {
        messageTemplate.SmsMessage = this.definition.verification_message_template.SmsMessage;
      }
      if (this.definition.verification_message_template.EmailMessage) {
        messageTemplate.EmailMessage = this.definition.verification_message_template.EmailMessage;
      }
      if (this.definition.verification_message_template.EmailSubject) {
        messageTemplate.EmailSubject = this.definition.verification_message_template.EmailSubject;
      }
      if (this.definition.verification_message_template.DefaultEmailOption) {
        messageTemplate.DefaultEmailOption = this.definition.verification_message_template.DefaultEmailOption;
      }
      params.VerificationMessageTemplate = messageTemplate;
    }
    if (this.definition.account_recovery_setting) {
      params.AccountRecoverySetting = this.definition.account_recovery_setting;
    }
    if (this.definition.username_configuration) {
      params.UsernameConfiguration = {
        CaseSensitive: this.definition.username_configuration.CaseSensitive !== void 0 ? this.definition.username_configuration.CaseSensitive : false
      };
    }
    if (this.definition.user_pool_add_ons) {
      params.UserPoolAddOns = {
        AdvancedSecurityMode: this.definition.user_pool_add_ons.AdvancedSecurityMode || "OFF"
      };
    }
    if (this.definition.user_attribute_update_settings) {
      params.UserAttributeUpdateSettings = this.definition.user_attribute_update_settings;
    }
    if (this.definition.tags) {
      params.UserPoolTags = this.definition.tags;
    }
    try {
      const response = this.makeCognitoIdpRequest("CreateUserPool", params);
      const userPool = response.UserPool;
      if (userPool) {
        console.log(`User Pool created successfully: ${userPool.Id}`);
        const state = this.formatUserPoolState(userPool, false);
        Object.assign(this.state, state);
      } else {
        throw new Error("No UserPool data in response");
      }
    } catch (error) {
      throw new Error(`Failed to create User Pool ${this.definition.pool_name}: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  update() {
    if (!this.state.user_pool_id) {
      throw new Error("Cannot update User Pool: not found in state");
    }
    console.log(`Updating User Pool: ${this.state.user_pool_id}`);
    const params = {
      UserPoolId: this.state.user_pool_id
    };
    if (this.definition.mfa_configuration) {
      params.MfaConfiguration = this.definition.mfa_configuration;
    }
    if (this.definition.tags) {
      params.UserPoolTags = this.definition.tags;
    }
    try {
      const response = this.makeCognitoIdpRequest("UpdateUserPool", params);
      console.log(`User Pool updated successfully: ${this.state.user_pool_id}`);
      const userPool = response.UserPool;
      if (userPool) {
        const state = this.formatUserPoolState(userPool, this.state.existing || false);
        Object.assign(this.state, state);
      }
    } catch (error) {
      throw new Error(`Failed to update User Pool ${this.state.user_pool_id}: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  delete() {
    if (this.state.user_pool_id && !this.state.existing) {
      console.log(`Deleting User Pool: ${this.state.user_pool_id}`);
      this.deleteUserPool(this.state.user_pool_id);
      this.state.user_pool_id = void 0;
      this.state.user_pool_arn = void 0;
      this.state.user_pool_name = void 0;
      this.state.user_pool_status = void 0;
    } else if (this.state.existing) {
      console.log(`User Pool ${this.state.user_pool_id} was pre-existing, not deleting`);
      this.state.user_pool_id = void 0;
      this.state.user_pool_arn = void 0;
      this.state.user_pool_name = void 0;
      this.state.user_pool_status = void 0;
    }
  }
  checkReadiness() {
    if (!this.state.user_pool_id) {
      return false;
    }
    if (this.state.user_pool_status === "Ready") {
      return true;
    }
    console.log(`Checking readiness for User Pool: ${this.state.user_pool_id}`);
    try {
      const response = this.checkUserPoolExistsById(this.state.user_pool_id);
      if (!response || !response.UserPool) {
        return false;
      }
      const updatedState = this.formatUserPoolState(response.UserPool, this.state.existing || false);
      Object.assign(this.state, updatedState);
      const status = response.UserPool.Status;
      return status !== "Creating" && status !== "Deleting";
    } catch (error) {
      console.log(`Readiness check failed: ${error instanceof Error ? error.message : "Unknown error"}`);
      return false;
    }
  }
  getPoolInfo() {
    try {
      if (!this.state.user_pool_id) {
        cli.output(`User Pool not found in entity state`);
        throw new Error(`User Pool not found`);
      }
      const response = this.checkUserPoolExistsById(this.state.user_pool_id);
      if (!response || !response.UserPool) {
        cli.output(`User Pool ${this.state.user_pool_id} not found in AWS`);
        throw new Error(`User Pool ${this.state.user_pool_id} not found`);
      }
      const pool = response.UserPool;
      cli.output("=== User Pool Information ===");
      cli.output(`Pool ID: ${pool.Id || "N/A"}`);
      cli.output(`Pool Name: ${pool.Name || "N/A"}`);
      cli.output(`Pool ARN: ${pool.Arn || "N/A"}`);
      cli.output(`Status: ${pool.Status || "N/A"}`);
      cli.output(`Creation Date: ${pool.CreationDate ? new Date(pool.CreationDate * 1e3).toISOString() : "N/A"}`);
      cli.output(`Last Modified: ${pool.LastModifiedDate ? new Date(pool.LastModifiedDate * 1e3).toISOString() : "N/A"}`);
      cli.output(`MFA Configuration: ${pool.MfaConfiguration || "N/A"}`);
      cli.output(`Estimated Users: ${pool.EstimatedNumberOfUsers || 0}`);
    } catch (error) {
      const errorMsg = `Failed to get User Pool info: ${error instanceof Error ? error.message : "Unknown error"}`;
      cli.output(errorMsg);
      throw new Error(errorMsg);
    }
  }
  listUsers(args) {
    const limit = args?.limit ? parseInt(args.limit) : 10;
    try {
      if (!this.state.user_pool_id) {
        cli.output(`User Pool not found in entity state`);
        throw new Error(`User Pool not found`);
      }
      const params = {
        UserPoolId: this.state.user_pool_id,
        Limit: Math.min(limit, 60)
        // AWS maximum is 60
      };
      if (args?.pagination_token) {
        params.PaginationToken = args.pagination_token;
      }
      const response = this.makeCognitoIdpRequest("ListUsers", params);
      cli.output("=== User Pool Users ===");
      cli.output(`User Pool: ${this.state.user_pool_id}`);
      const users = response.Users;
      if (users && users.length > 0) {
        cli.output(`
Found ${users.length} users:`);
        for (const user of users) {
          cli.output(`
--- User: ${user.Username || "N/A"} ---`);
          cli.output(`Status: ${user.UserStatus || "N/A"}`);
          cli.output(`Enabled: ${user.Enabled !== false}`);
          const createDate = user.UserCreateDate;
          cli.output(`Created: ${createDate ? new Date(createDate * 1e3).toISOString() : "N/A"}`);
        }
        const paginationToken = response.PaginationToken;
        if (paginationToken) {
          cli.output(`
Pagination Token (for next page): ${paginationToken}`);
        }
      } else {
        cli.output("\nNo users found in the User Pool");
      }
    } catch (error) {
      const errorMsg = `Failed to list users: ${error instanceof Error ? error.message : "Unknown error"}`;
      cli.output(errorMsg);
      throw new Error(errorMsg);
    }
  }
  createUser(args) {
    try {
      if (!this.state.user_pool_id) {
        cli.output(`User Pool not found in entity state`);
        throw new Error(`User Pool not found`);
      }
      if (!args?.username) {
        cli.output("Username is required");
        throw new Error("Username is required");
      }
      const params = {
        UserPoolId: this.state.user_pool_id,
        Username: args.username,
        MessageAction: args.message_action || "EMAIL",
        // Default to EMAIL
        TemporaryPassword: args.temporary_password || void 0
      };
      if (args.user_attributes) {
        try {
          const attributes = typeof args.user_attributes === "string" ? JSON.parse(args.user_attributes) : args.user_attributes;
          params.UserAttributes = Object.entries(attributes).map(([name, value]) => ({
            Name: name,
            Value: String(value)
          }));
        } catch (_error) {
          cli.output("Invalid user_attributes format. Expected JSON object.");
          throw new Error("Invalid user_attributes format");
        }
      }
      const response = this.makeCognitoIdpRequest("AdminCreateUser", params);
      const user = response.User;
      if (user) {
        cli.output("=== User Created Successfully ===");
        cli.output(`Username: ${user.Username || "N/A"}`);
        cli.output(`Status: ${user.UserStatus || "N/A"}`);
        cli.output(`Enabled: ${user.Enabled !== false}`);
        const createDate = user.UserCreateDate;
        cli.output(`Created: ${createDate ? new Date(createDate * 1e3).toISOString() : "N/A"}`);
      }
    } catch (error) {
      const errorMsg = `Failed to create user: ${error instanceof Error ? error.message : "Unknown error"}`;
      cli.output(errorMsg);
      throw new Error(errorMsg);
    }
  }
  formatUserPoolState(userPool, wasPreExisting = false) {
    return {
      existing: wasPreExisting,
      // true = don't delete (pre-existing), false = we created it (can delete)
      user_pool_id: userPool.Id,
      user_pool_arn: userPool.Arn,
      user_pool_name: userPool.Name,
      user_pool_status: userPool.Status,
      creation_date: userPool.CreationDate ? new Date(userPool.CreationDate * 1e3).toISOString() : void 0,
      last_modified_date: userPool.LastModifiedDate ? new Date(userPool.LastModifiedDate * 1e3).toISOString() : void 0,
      mfa_configuration: userPool.MfaConfiguration,
      estimated_number_of_users: userPool.EstimatedNumberOfUsers
    };
  }
};
_init = __decoratorStart(_a);
__decorateElement(_init, 1, "getPoolInfo", _getPoolInfo_dec, _UserPool);
__decorateElement(_init, 1, "listUsers", _listUsers_dec, _UserPool);
__decorateElement(_init, 1, "createUser", _createUser_dec, _UserPool);
__decoratorMetadata(_init, _UserPool);
__name(_UserPool, "UserPool");
var UserPool = _UserPool;



function main(def, state, ctx) {
  const entity = new UserPool(def, state, ctx);
  return entity.main(ctx);
}
