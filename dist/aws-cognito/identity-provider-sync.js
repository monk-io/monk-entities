
// Generated by MonkEC - targeting Goja runtime
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __knownSymbol = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __decoratorStart = (base) => [, , , __create(base?.[__knownSymbol("metadata")] ?? null)];
var __decoratorStrings = ["class", "method", "getter", "setter", "accessor", "field", "value", "get", "set"];
var __expectFn = (fn) => fn !== void 0 && typeof fn !== "function" ? __typeError("Function expected") : fn;
var __decoratorContext = (kind, name, done, metadata, fns) => ({ kind: __decoratorStrings[kind], name, metadata, addInitializer: (fn) => done._ ? __typeError("Already initialized") : fns.push(__expectFn(fn || null)) });
var __decoratorMetadata = (array, target) => __defNormalProp(target, __knownSymbol("metadata"), array[3]);
var __runInitializers = (array, flags, self, value) => {
  for (var i = 0, fns = array[flags >> 1], n = fns && fns.length; i < n; i++) flags & 1 ? fns[i].call(self) : value = fns[i].call(self, value);
  return value;
};
var __decorateElement = (array, flags, name, decorators, target, extra) => {
  var fn, it, done, ctx, access, k = flags & 7, s = !!(flags & 8), p = !!(flags & 16);
  var j = k > 3 ? array.length + 1 : k ? s ? 1 : 2 : 0, key = __decoratorStrings[k + 5];
  var initializers = k > 3 && (array[j - 1] = []), extraInitializers = array[j] || (array[j] = []);
  var desc = k && (!p && !s && (target = target.prototype), k < 5 && (k > 3 || !p) && __getOwnPropDesc(k < 4 ? target : { get [name]() {
    return __privateGet(this, extra);
  }, set [name](x) {
    return __privateSet(this, extra, x);
  } }, name));
  k ? p && k < 4 && __name(extra, (k > 2 ? "set " : k > 1 ? "get " : "") + name) : __name(target, name);
  for (var i = decorators.length - 1; i >= 0; i--) {
    ctx = __decoratorContext(k, name, done = {}, array[3], extraInitializers);
    if (k) {
      ctx.static = s, ctx.private = p, access = ctx.access = { has: p ? (x) => __privateIn(target, x) : (x) => name in x };
      if (k ^ 3) access.get = p ? (x) => (k ^ 1 ? __privateGet : __privateMethod)(x, target, k ^ 4 ? extra : desc.get) : (x) => x[name];
      if (k > 2) access.set = p ? (x, y) => __privateSet(x, target, y, k ^ 4 ? extra : desc.set) : (x, y) => x[name] = y;
    }
    it = (0, decorators[i])(k ? k < 4 ? p ? extra : desc[key] : k > 4 ? void 0 : { get: desc.get, set: desc.set } : target, ctx), done._ = 1;
    if (k ^ 4 || it === void 0) __expectFn(it) && (k > 4 ? initializers.unshift(it) : k ? p ? extra = it : desc[key] = it : target = it);
    else if (typeof it !== "object" || it === null) __typeError("Object expected");
    else __expectFn(fn = it.get) && (desc.get = fn), __expectFn(fn = it.set) && (desc.set = fn), __expectFn(fn = it.init) && initializers.unshift(fn);
  }
  return k || __decoratorMetadata(array, target), desc && __defProp(target, name, desc), p ? k ^ 4 ? extra : desc : target;
};
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateIn = (member, obj) => Object(obj) !== obj ? __typeError('Cannot use the "in" operator on this value') : member.has(obj);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);

// input/aws-cognito/identityProvider.ts
const cognitoBase = require("aws-cognito/cognito-base");
const AWSCognitoEntity = cognitoBase.AWSCognitoEntity;
const base = require("monkec/base");
const action = base.action;
const cli = require("cli");
function formatIdentityProviderState(providerData, wasPreExisting = false) {
  return {
    existing: wasPreExisting,
    provider_name: providerData.ProviderName,
    provider_type: providerData.ProviderType,
    creation_date: providerData.CreationDate,
    last_modified_date: providerData.LastModifiedDate
  };
}
__name(formatIdentityProviderState, "formatIdentityProviderState");
var _listProviders_dec, _testProviderConfig_dec, _getProviderInfo_dec, _a, _init;
var _IdentityProvider = class _IdentityProvider extends (_a = AWSCognitoEntity, _getProviderInfo_dec = [action("get-provider-info")], _testProviderConfig_dec = [action("test-provider-config")], _listProviders_dec = [action("list-providers")], _a) {
  constructor() {
    super(...arguments);
    __runInitializers(_init, 5, this);
  }
  /**
   * Get the User Pool ID for this provider
   */
  getUserPoolId() {
    return this.definition.user_pool_id;
  }
  /**
   * Get the provider name
   */
  getProviderName() {
    return this.definition.provider_name;
  }
  /**
   * Get the provider type
   */
  getProviderType() {
    return this.definition.provider_type;
  }
  /**
   * Check if an Identity Provider exists in AWS
   */
  checkIdentityProviderExists(userPoolId, providerName) {
    try {
      const response = this.makeCognitoIdpRequest("DescribeIdentityProvider", {
        UserPoolId: userPoolId,
        ProviderName: providerName
      });
      if (response.IdentityProvider) {
        return response;
      }
      return null;
    } catch (error) {
      if (error instanceof Error && error.message.includes("ResourceNotFoundException")) {
        return null;
      }
      throw error;
    }
  }
  /**
   * Build parameters for CreateIdentityProvider API call
   */
  buildCreateIdentityProviderParams() {
    const params = {
      UserPoolId: this.getUserPoolId(),
      ProviderName: this.getProviderName(),
      ProviderType: this.getProviderType(),
      ProviderDetails: this.definition.provider_details
    };
    if (this.definition.attribute_mapping && Object.keys(this.definition.attribute_mapping).length > 0) {
      params.AttributeMapping = this.definition.attribute_mapping;
    }
    if (this.definition.idp_identifiers && this.definition.idp_identifiers.length > 0) {
      params.IdpIdentifiers = this.definition.idp_identifiers;
    }
    return params;
  }
  /**
   * Validate provider configuration based on type
   */
  validateProviderConfiguration() {
    const providerType = this.getProviderType();
    const details = this.definition.provider_details;
    switch (providerType) {
      case "SAML": {
        if (!details.MetadataURL && !details.MetadataFile) {
          throw new Error("SAML provider requires either MetadataURL or MetadataFile in provider_details");
        }
        break;
      }
      case "OIDC": {
        const requiredOidcFields = ["client_id", "client_secret", "attributes_request_method", "oidc_issuer"];
        for (const field of requiredOidcFields) {
          if (!details[field]) {
            throw new Error(`OIDC provider requires ${field} in provider_details`);
          }
        }
        break;
      }
      case "Facebook": {
        if (!details.client_id || !details.client_secret) {
          throw new Error("Facebook provider requires client_id and client_secret in provider_details");
        }
        break;
      }
      case "Google": {
        if (!details.client_id || !details.client_secret) {
          throw new Error("Google provider requires client_id and client_secret in provider_details");
        }
        break;
      }
      case "LoginWithAmazon": {
        if (!details.client_id || !details.client_secret) {
          throw new Error("Amazon provider requires client_id and client_secret in provider_details");
        }
        break;
      }
      case "SignInWithApple": {
        const requiredAppleFields = ["client_id", "team_id", "key_id", "private_key"];
        for (const field of requiredAppleFields) {
          if (!details[field]) {
            throw new Error(`Apple provider requires ${field} in provider_details`);
          }
        }
        break;
      }
      default: {
        throw new Error(`Unsupported provider type: ${providerType}`);
      }
    }
  }
  /**
   * Create the Identity Provider
   */
  create() {
    const userPoolId = this.getUserPoolId();
    const providerName = this.getProviderName();
    try {
      this.validateProviderConfiguration();
      const existingProvider = this.checkIdentityProviderExists(userPoolId, providerName);
      if (existingProvider && existingProvider.IdentityProvider) {
        console.log(`Found existing Identity Provider: ${providerName}`);
        const state = formatIdentityProviderState(existingProvider.IdentityProvider, true);
        Object.assign(this.state, state);
        return;
      }
      console.log(`Creating Identity Provider: ${providerName} of type ${this.getProviderType()} in User Pool: ${userPoolId}`);
      const params = this.buildCreateIdentityProviderParams();
      const response = this.makeCognitoIdpRequest("CreateIdentityProvider", params);
      if (response.IdentityProvider) {
        const state = formatIdentityProviderState(response.IdentityProvider, false);
        Object.assign(this.state, state);
        console.log(`Successfully created Identity Provider: ${providerName}`);
      } else {
        throw new Error("Identity Provider creation response missing IdentityProvider data");
      }
    } catch (error) {
      throw new Error(`Failed to create Identity Provider ${providerName}: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  /**
   * Update the Identity Provider
   */
  update() {
    const userPoolId = this.getUserPoolId();
    const providerName = this.getProviderName();
    try {
      this.validateProviderConfiguration();
      console.log(`Updating Identity Provider: ${providerName}`);
      const params = {
        UserPoolId: userPoolId,
        ProviderName: providerName,
        ProviderDetails: this.definition.provider_details
      };
      if (this.definition.attribute_mapping && Object.keys(this.definition.attribute_mapping).length > 0) {
        params.AttributeMapping = this.definition.attribute_mapping;
      }
      if (this.definition.idp_identifiers && this.definition.idp_identifiers.length > 0) {
        params.IdpIdentifiers = this.definition.idp_identifiers;
      }
      const response = this.makeCognitoIdpRequest("UpdateIdentityProvider", params);
      if (response.IdentityProvider) {
        const state = formatIdentityProviderState(response.IdentityProvider, this.state.existing);
        Object.assign(this.state, state);
        console.log(`Successfully updated Identity Provider: ${providerName}`);
      } else {
        throw new Error("Identity Provider update response missing IdentityProvider data");
      }
    } catch (error) {
      throw new Error(`Failed to update Identity Provider ${providerName}: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  /**
   * Delete the Identity Provider
   */
  delete() {
    const userPoolId = this.getUserPoolId();
    const providerName = this.state.provider_name || this.getProviderName();
    if (providerName && !this.state.existing) {
      try {
        console.log(`Deleting Identity Provider: ${providerName}`);
        this.makeCognitoIdpRequest("DeleteIdentityProvider", {
          UserPoolId: userPoolId,
          ProviderName: providerName
        });
        console.log(`Successfully deleted Identity Provider: ${providerName}`);
      } catch (error) {
        console.log(`Error deleting Identity Provider ${providerName}: ${error instanceof Error ? error.message : "Unknown error"}`);
      }
    } else if (this.state.existing) {
      console.log(`Skipping deletion of pre-existing Identity Provider: ${providerName}`);
    }
    this.state.provider_name = void 0;
    this.state.provider_type = void 0;
    this.state.creation_date = void 0;
    this.state.last_modified_date = void 0;
  }
  /**
   * Check if the Identity Provider is ready
   */
  checkReadiness() {
    const userPoolId = this.getUserPoolId();
    const providerName = this.state.provider_name || this.getProviderName();
    if (!providerName) {
      console.log(`Identity Provider not ready: missing provider name`);
      return false;
    }
    try {
      const response = this.checkIdentityProviderExists(userPoolId, providerName);
      const isReady = response !== null;
      if (!isReady) {
        console.log(`Identity Provider ${providerName} not found in AWS`);
      }
      return isReady;
    } catch (error) {
      console.log(`Error checking Identity Provider readiness: ${error instanceof Error ? error.message : "Unknown error"}`);
      return false;
    }
  }
  getProviderInfo() {
    const userPoolId = this.getUserPoolId();
    const providerName = this.state.provider_name || this.getProviderName();
    try {
      if (!this.state.provider_name) {
        cli.output(`Identity Provider ${providerName} not found in entity state`);
        throw new Error(`Identity Provider ${providerName} not found`);
      }
      const response = this.makeCognitoIdpRequest("DescribeIdentityProvider", {
        UserPoolId: userPoolId,
        ProviderName: providerName
      });
      if (!response.IdentityProvider) {
        cli.output(`Identity Provider ${providerName} not found in AWS`);
        throw new Error(`Identity Provider ${providerName} not found`);
      }
      const provider = response.IdentityProvider;
      cli.output("=== Identity Provider Information ===");
      cli.output(`Provider Name: ${provider.ProviderName || "N/A"}`);
      cli.output(`Provider Type: ${provider.ProviderType || "N/A"}`);
      cli.output(`User Pool ID: ${provider.UserPoolId || "N/A"}`);
      cli.output(`Creation Date: ${provider.CreationDate || "N/A"}`);
      cli.output(`Last Modified: ${provider.LastModifiedDate || "N/A"}`);
      if (provider.ProviderDetails && typeof provider.ProviderDetails === "object") {
        cli.output(`Provider Details:`);
        const details = provider.ProviderDetails;
        for (const [key, value] of Object.entries(details)) {
          if (key.toLowerCase().includes("secret") || key.toLowerCase().includes("key")) {
            cli.output(`  - ${key}: [HIDDEN]`);
          } else {
            cli.output(`  - ${key}: ${value}`);
          }
        }
      }
      if (provider.AttributeMapping && typeof provider.AttributeMapping === "object") {
        cli.output(`Attribute Mapping:`);
        const mapping = provider.AttributeMapping;
        for (const [cognitoAttr, providerAttr] of Object.entries(mapping)) {
          cli.output(`  - ${cognitoAttr} \u2190 ${providerAttr}`);
        }
      }
      if (provider.IdpIdentifiers && Array.isArray(provider.IdpIdentifiers)) {
        cli.output(`IdP Identifiers: ${provider.IdpIdentifiers.join(", ")}`);
      }
    } catch (error) {
      const errorMsg = `Failed to get Identity Provider info: ${error instanceof Error ? error.message : "Unknown error"}`;
      cli.output(errorMsg);
      throw new Error(errorMsg);
    }
  }
  testProviderConfig() {
    const userPoolId = this.getUserPoolId();
    const providerName = this.state.provider_name || this.getProviderName();
    try {
      if (!this.state.provider_name) {
        cli.output(`Identity Provider ${providerName} not found in entity state`);
        throw new Error(`Identity Provider ${providerName} not found`);
      }
      const response = this.makeCognitoIdpRequest("DescribeIdentityProvider", {
        UserPoolId: userPoolId,
        ProviderName: providerName
      });
      if (!response.IdentityProvider) {
        cli.output(`Identity Provider ${providerName} not found in AWS`);
        throw new Error(`Identity Provider ${providerName} not found`);
      }
      const provider = response.IdentityProvider;
      cli.output("=== Identity Provider Configuration Test ===");
      cli.output(`Provider: ${provider.ProviderName} (${provider.ProviderType})`);
      cli.output(`User Pool: ${userPoolId}`);
      const providerType = provider.ProviderType;
      const details = provider.ProviderDetails || {};
      cli.output(`Configuration Validation:`);
      switch (providerType) {
        case "SAML": {
          cli.output(`  - SAML Metadata: ${details.MetadataURL || details.MetadataFile ? "\u2705 Configured" : "\u274C Missing"}`);
          cli.output(`  - Provider Type: \u2705 SAML 2.0`);
          break;
        }
        case "OIDC": {
          cli.output(`  - Client ID: ${details.client_id ? "\u2705 Configured" : "\u274C Missing"}`);
          cli.output(`  - Client Secret: ${details.client_secret ? "\u2705 Configured" : "\u274C Missing"}`);
          cli.output(`  - OIDC Issuer: ${details.oidc_issuer ? "\u2705 Configured" : "\u274C Missing"}`);
          cli.output(`  - Request Method: ${details.attributes_request_method || "GET"}`);
          break;
        }
        case "Facebook":
        case "Google":
        case "LoginWithAmazon": {
          cli.output(`  - Client ID: ${details.client_id ? "\u2705 Configured" : "\u274C Missing"}`);
          cli.output(`  - Client Secret: ${details.client_secret ? "\u2705 Configured" : "\u274C Missing"}`);
          cli.output(`  - Provider Type: \u2705 Social Login (${providerType})`);
          break;
        }
        case "SignInWithApple": {
          cli.output(`  - Client ID: ${details.client_id ? "\u2705 Configured" : "\u274C Missing"}`);
          cli.output(`  - Team ID: ${details.team_id ? "\u2705 Configured" : "\u274C Missing"}`);
          cli.output(`  - Key ID: ${details.key_id ? "\u2705 Configured" : "\u274C Missing"}`);
          cli.output(`  - Private Key: ${details.private_key ? "\u2705 Configured" : "\u274C Missing"}`);
          break;
        }
      }
      const hasMapping = provider.AttributeMapping && Object.keys(provider.AttributeMapping).length > 0;
      cli.output(`  - Attribute Mapping: ${hasMapping ? "\u2705 Configured" : "\u26A0\uFE0F No mapping"}`);
      const hasIdentifiers = provider.IdpIdentifiers && provider.IdpIdentifiers.length > 0;
      cli.output(`  - IdP Identifiers: ${hasIdentifiers ? "\u2705 Configured" : "\u26A0\uFE0F None set"}`);
      cli.output(`Integration Status: \u2705 Ready for authentication`);
    } catch (error) {
      const errorMsg = `Failed to test provider config: ${error instanceof Error ? error.message : "Unknown error"}`;
      cli.output(errorMsg);
      throw new Error(errorMsg);
    }
  }
  listProviders() {
    const userPoolId = this.getUserPoolId();
    try {
      const response = this.makeCognitoIdpRequest("ListIdentityProviders", {
        UserPoolId: userPoolId
      });
      cli.output("=== Identity Providers in User Pool ===");
      cli.output(`User Pool ID: ${userPoolId}`);
      if (response.Providers && Array.isArray(response.Providers)) {
        cli.output(`Found ${response.Providers.length} providers:`);
        response.Providers.forEach((provider, index) => {
          const p = provider;
          cli.output(`${index + 1}. ${p.ProviderName} (${p.ProviderType})`);
          cli.output(`   Created: ${p.CreationDate || "N/A"}`);
          cli.output(`   Modified: ${p.LastModifiedDate || "N/A"}`);
        });
      } else {
        cli.output(`No Identity Providers found in this User Pool`);
      }
    } catch (error) {
      const errorMsg = `Failed to list providers: ${error instanceof Error ? error.message : "Unknown error"}`;
      cli.output(errorMsg);
      throw new Error(errorMsg);
    }
  }
};
_init = __decoratorStart(_a);
__decorateElement(_init, 1, "getProviderInfo", _getProviderInfo_dec, _IdentityProvider);
__decorateElement(_init, 1, "testProviderConfig", _testProviderConfig_dec, _IdentityProvider);
__decorateElement(_init, 1, "listProviders", _listProviders_dec, _IdentityProvider);
__decoratorMetadata(_init, _IdentityProvider);
__name(_IdentityProvider, "IdentityProvider");
var IdentityProvider = _IdentityProvider;



function main(def, state, ctx) {
  const entity = new IdentityProvider(def, state, ctx);
  return entity.main(ctx);
}
