
// Generated by MonkEC - targeting Goja runtime
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __knownSymbol = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __decoratorStart = (base) => [, , , __create(base?.[__knownSymbol("metadata")] ?? null)];
var __decoratorStrings = ["class", "method", "getter", "setter", "accessor", "field", "value", "get", "set"];
var __expectFn = (fn) => fn !== void 0 && typeof fn !== "function" ? __typeError("Function expected") : fn;
var __decoratorContext = (kind, name, done, metadata, fns) => ({ kind: __decoratorStrings[kind], name, metadata, addInitializer: (fn) => done._ ? __typeError("Already initialized") : fns.push(__expectFn(fn || null)) });
var __decoratorMetadata = (array, target) => __defNormalProp(target, __knownSymbol("metadata"), array[3]);
var __runInitializers = (array, flags, self, value) => {
  for (var i = 0, fns = array[flags >> 1], n = fns && fns.length; i < n; i++) flags & 1 ? fns[i].call(self) : value = fns[i].call(self, value);
  return value;
};
var __decorateElement = (array, flags, name, decorators, target, extra) => {
  var fn, it, done, ctx, access, k = flags & 7, s = !!(flags & 8), p = !!(flags & 16);
  var j = k > 3 ? array.length + 1 : k ? s ? 1 : 2 : 0, key = __decoratorStrings[k + 5];
  var initializers = k > 3 && (array[j - 1] = []), extraInitializers = array[j] || (array[j] = []);
  var desc = k && (!p && !s && (target = target.prototype), k < 5 && (k > 3 || !p) && __getOwnPropDesc(k < 4 ? target : { get [name]() {
    return __privateGet(this, extra);
  }, set [name](x) {
    return __privateSet(this, extra, x);
  } }, name));
  k ? p && k < 4 && __name(extra, (k > 2 ? "set " : k > 1 ? "get " : "") + name) : __name(target, name);
  for (var i = decorators.length - 1; i >= 0; i--) {
    ctx = __decoratorContext(k, name, done = {}, array[3], extraInitializers);
    if (k) {
      ctx.static = s, ctx.private = p, access = ctx.access = { has: p ? (x) => __privateIn(target, x) : (x) => name in x };
      if (k ^ 3) access.get = p ? (x) => (k ^ 1 ? __privateGet : __privateMethod)(x, target, k ^ 4 ? extra : desc.get) : (x) => x[name];
      if (k > 2) access.set = p ? (x, y) => __privateSet(x, target, y, k ^ 4 ? extra : desc.set) : (x, y) => x[name] = y;
    }
    it = (0, decorators[i])(k ? k < 4 ? p ? extra : desc[key] : k > 4 ? void 0 : { get: desc.get, set: desc.set } : target, ctx), done._ = 1;
    if (k ^ 4 || it === void 0) __expectFn(it) && (k > 4 ? initializers.unshift(it) : k ? p ? extra = it : desc[key] = it : target = it);
    else if (typeof it !== "object" || it === null) __typeError("Object expected");
    else __expectFn(fn = it.get) && (desc.get = fn), __expectFn(fn = it.set) && (desc.set = fn), __expectFn(fn = it.init) && initializers.unshift(fn);
  }
  return k || __decoratorMetadata(array, target), desc && __defProp(target, name, desc), p ? k ^ 4 ? extra : desc : target;
};
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateIn = (member, obj) => Object(obj) !== obj ? __typeError('Cannot use the "in" operator on this value') : member.has(obj);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);

// input/aws-cognito/identityPool.ts
const base = require("monkec/base");
const action = base.action;
const cli = require("cli");
const cognitoBase = require("aws-cognito/cognito-base");
const AWSCognitoEntity = cognitoBase.AWSCognitoEntity;
var _getIdentityId_dec, _getCredentialsForIdentity_dec, _getPoolInfo_dec, _a, _init;
var _IdentityPool = class _IdentityPool extends (_a = AWSCognitoEntity, _getPoolInfo_dec = [action("get-pool-info")], _getCredentialsForIdentity_dec = [action("get-credentials-for-identity")], _getIdentityId_dec = [action("get-identity-id")], _a) {
  constructor() {
    super(...arguments);
    __runInitializers(_init, 5, this);
  }
  getIdentityPoolName() {
    return this.definition.identity_pool_name;
  }
  getIdentityPoolId() {
    if (!this.state.identity_pool_id) {
      throw new Error(`Identity Pool ${this.getIdentityPoolName()} not found in entity state`);
    }
    return this.state.identity_pool_id;
  }
  create() {
    const identityPoolName = this.getIdentityPoolName();
    try {
      const existingPools = this.listIdentityPools();
      const existingPool = existingPools.find((pool) => pool.IdentityPoolName === identityPoolName);
      if (existingPool) {
        console.log(`Identity Pool ${identityPoolName} already exists: ${existingPool.IdentityPoolId}`);
        Object.assign(this.state, {
          existing: true,
          identity_pool_id: existingPool.IdentityPoolId,
          identity_pool_name: existingPool.IdentityPoolName,
          allow_unauthenticated_identities: existingPool.AllowUnauthenticatedIdentities,
          allow_classic_flow: existingPool.AllowClassicFlow
        });
        return;
      }
      console.log(`Creating Identity Pool: ${identityPoolName}`);
      const params = this.buildCreateIdentityPoolParams();
      const response = this.makeCognitoIdentityRequest("CreateIdentityPool", params);
      if (!response || typeof response !== "object") {
        throw new Error("Invalid response from CreateIdentityPool API");
      }
      const responseObj = response;
      Object.assign(this.state, {
        existing: false,
        identity_pool_id: responseObj.IdentityPoolId,
        identity_pool_name: responseObj.IdentityPoolName,
        allow_unauthenticated_identities: responseObj.AllowUnauthenticatedIdentities,
        allow_classic_flow: responseObj.AllowClassicFlow
      });
      console.log(`Identity Pool created successfully: ${this.state.identity_pool_id}`);
      if (this.definition.auto_create_roles !== false) {
        this.createAndAttachIAMRoles();
      }
    } catch (error) {
      throw new Error(`Failed to create Identity Pool ${identityPoolName}: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  update() {
    const identityPoolId = this.getIdentityPoolId();
    try {
      console.log(`Updating Identity Pool: ${identityPoolId}`);
      const params = this.buildUpdateIdentityPoolParams();
      const response = this.makeCognitoIdentityRequest("UpdateIdentityPool", params);
      if (!response || typeof response !== "object") {
        throw new Error("Invalid response from UpdateIdentityPool API");
      }
      const responseObj = response;
      Object.assign(this.state, {
        identity_pool_name: responseObj.IdentityPoolName,
        allow_unauthenticated_identities: responseObj.AllowUnauthenticatedIdentities,
        allow_classic_flow: responseObj.AllowClassicFlow
      });
      console.log(`Identity Pool updated successfully: ${identityPoolId}`);
    } catch (error) {
      throw new Error(`Failed to update Identity Pool ${identityPoolId}: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  delete() {
    if (this.state.identity_pool_id && !this.state.existing) {
      try {
        console.log(`Deleting Identity Pool: ${this.state.identity_pool_id}`);
        this.makeCognitoIdentityRequest("DeleteIdentityPool", {
          IdentityPoolId: this.state.identity_pool_id
        });
        console.log(`Identity Pool deleted successfully: ${this.state.identity_pool_id}`);
      } catch (error) {
        console.error(`Failed to delete Identity Pool ${this.state.identity_pool_id}: ${error instanceof Error ? error.message : "Unknown error"}`);
      }
    } else if (this.state.existing) {
      console.log(`Skipping deletion of pre-existing Identity Pool: ${this.state.identity_pool_id}`);
    }
    this.state.identity_pool_id = void 0;
    this.state.identity_pool_name = void 0;
    this.state.allow_unauthenticated_identities = void 0;
    this.state.allow_classic_flow = void 0;
  }
  checkReadiness() {
    if (!this.state.identity_pool_id) {
      console.log(`Identity Pool not created yet`);
      return false;
    }
    try {
      const response = this.makeCognitoIdentityRequest("DescribeIdentityPool", {
        IdentityPoolId: this.state.identity_pool_id
      });
      if (!response || typeof response !== "object") {
        console.log(`Invalid response for Identity Pool ${this.state.identity_pool_id}`);
        return false;
      }
      const responseObj = response;
      console.log(`Identity Pool ${this.state.identity_pool_id} is ready`);
      return !!responseObj.IdentityPoolId;
    } catch (error) {
      console.log(`Identity Pool ${this.state.identity_pool_id} not ready: ${error instanceof Error ? error.message : "Unknown error"}`);
      return false;
    }
  }
  getPoolInfo() {
    const identityPoolId = this.getIdentityPoolId();
    try {
      if (!this.state.identity_pool_id) {
        cli.output(`Identity Pool ${identityPoolId} not found in entity state`);
        throw new Error(`Identity Pool ${identityPoolId} not found`);
      }
      const response = this.makeCognitoIdentityRequest("DescribeIdentityPool", {
        IdentityPoolId: identityPoolId
      });
      if (!response || typeof response !== "object") {
        cli.output(`Identity Pool ${identityPoolId} not found in AWS`);
        throw new Error(`Identity Pool ${identityPoolId} not found`);
      }
      const pool = response;
      cli.output("=== Identity Pool Information ===");
      cli.output(`Pool Name: ${pool.IdentityPoolName || "N/A"}`);
      cli.output(`Pool ID: ${pool.IdentityPoolId || "N/A"}`);
      cli.output(`Allow Unauthenticated: ${pool.AllowUnauthenticatedIdentities || false}`);
      cli.output(`Allow Classic Flow: ${pool.AllowClassicFlow || false}`);
      if (pool.CognitoIdentityProviders && Array.isArray(pool.CognitoIdentityProviders)) {
        cli.output(`Cognito Providers: ${pool.CognitoIdentityProviders.length}`);
      }
      if (pool.SupportedLoginProviders && typeof pool.SupportedLoginProviders === "object") {
        const providers = Object.keys(pool.SupportedLoginProviders);
        cli.output(`Supported Login Providers: ${providers.join(", ")}`);
      }
    } catch (error) {
      const errorMsg = `Failed to get Identity Pool info: ${error instanceof Error ? error.message : "Unknown error"}`;
      cli.output(errorMsg);
      throw new Error(errorMsg);
    }
  }
  getCredentialsForIdentity(args) {
    const identityId = args._[0];
    if (!identityId) {
      cli.output("Identity ID is required");
      throw new Error("Identity ID is required");
    }
    try {
      const response = this.makeCognitoIdentityRequest("GetCredentialsForIdentity", {
        IdentityId: identityId
      });
      if (!response || typeof response !== "object") {
        cli.output(`Failed to get credentials for identity: ${identityId}`);
        throw new Error(`Failed to get credentials for identity: ${identityId}`);
      }
      const result = response;
      cli.output("=== AWS Credentials ===");
      cli.output(`Identity ID: ${result.IdentityId || "N/A"}`);
      if (result.Credentials && typeof result.Credentials === "object") {
        const creds = result.Credentials;
        cli.output(`Access Key ID: ${creds.AccessKeyId || "N/A"}`);
        cli.output(`Secret Access Key: ${creds.SecretKey ? "[HIDDEN]" : "N/A"}`);
        cli.output(`Session Token: ${creds.SessionToken ? "[PRESENT]" : "N/A"}`);
        cli.output(`Expiration: ${creds.Expiration || "N/A"}`);
      }
    } catch (error) {
      const errorMsg = `Failed to get credentials for identity: ${error instanceof Error ? error.message : "Unknown error"}`;
      cli.output(errorMsg);
      throw new Error(errorMsg);
    }
  }
  getIdentityId() {
    const identityPoolId = this.getIdentityPoolId();
    try {
      const response = this.makeCognitoIdentityRequest("GetId", {
        IdentityPoolId: identityPoolId
      });
      if (!response || typeof response !== "object") {
        cli.output(`Failed to get identity ID for pool: ${identityPoolId}`);
        throw new Error(`Failed to get identity ID for pool: ${identityPoolId}`);
      }
      const result = response;
      cli.output("=== Identity ID ===");
      cli.output(`Identity Pool ID: ${identityPoolId}`);
      cli.output(`Identity ID: ${result.IdentityId || "N/A"}`);
    } catch (error) {
      const errorMsg = `Failed to get identity ID: ${error instanceof Error ? error.message : "Unknown error"}`;
      cli.output(errorMsg);
      throw new Error(errorMsg);
    }
  }
  listIdentityPools() {
    try {
      const response = this.makeCognitoIdentityRequest("ListIdentityPools", {
        MaxResults: 60
      });
      if (!response || typeof response !== "object") {
        return [];
      }
      const responseObj = response;
      return Array.isArray(responseObj.IdentityPools) ? responseObj.IdentityPools : [];
    } catch (error) {
      console.error(`Failed to list identity pools: ${error instanceof Error ? error.message : "Unknown error"}`);
      return [];
    }
  }
  buildCreateIdentityPoolParams() {
    const params = {
      IdentityPoolName: this.definition.identity_pool_name,
      AllowUnauthenticatedIdentities: this.definition.allow_unauthenticated_identities || false
    };
    if (this.definition.allow_classic_flow !== void 0) {
      params.AllowClassicFlow = this.definition.allow_classic_flow;
    }
    if (this.definition.cognito_identity_providers && this.definition.cognito_identity_providers.length > 0) {
      params.CognitoIdentityProviders = this.definition.cognito_identity_providers;
    }
    if (this.definition.saml_providers && this.definition.saml_providers.length > 0) {
      params.SamlProviderArns = this.definition.saml_providers;
    }
    if (this.definition.openid_connect_provider_arns && this.definition.openid_connect_provider_arns.length > 0) {
      params.OpenIdConnectProviderArns = this.definition.openid_connect_provider_arns;
    }
    if (this.definition.supported_login_providers) {
      params.SupportedLoginProviders = this.definition.supported_login_providers;
    }
    if (this.definition.developer_provider_name) {
      params.DeveloperProviderName = this.definition.developer_provider_name;
    }
    if (this.definition.identity_pool_tags) {
      params.IdentityPoolTags = this.definition.identity_pool_tags;
    }
    return params;
  }
  buildUpdateIdentityPoolParams() {
    const params = this.buildCreateIdentityPoolParams();
    params.IdentityPoolId = this.getIdentityPoolId();
    return params;
  }
  /**
   * Creates and attaches IAM roles for the Identity Pool
   */
  createAndAttachIAMRoles() {
    const identityPoolId = this.getIdentityPoolId();
    const identityPoolName = this.getIdentityPoolName();
    try {
      console.log(`Creating IAM roles for Identity Pool: ${identityPoolName}`);
      const authenticatedRoleArn = this.createAuthenticatedRole(identityPoolName, identityPoolId);
      let unauthenticatedRoleArn;
      if (this.definition.allow_unauthenticated_identities) {
        unauthenticatedRoleArn = this.createUnauthenticatedRole(identityPoolName, identityPoolId);
      }
      this.attachRolesToIdentityPool(identityPoolId, authenticatedRoleArn, unauthenticatedRoleArn);
      Object.assign(this.state, {
        authenticated_role_arn: authenticatedRoleArn,
        unauthenticated_role_arn: unauthenticatedRoleArn
      });
      console.log(`IAM roles created and attached successfully`);
    } catch (error) {
      console.error(`Failed to create IAM roles: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  /**
   * Creates an authenticated IAM role for the Identity Pool
   */
  createAuthenticatedRole(identityPoolName, identityPoolId) {
    const roleName = `Cognito_${identityPoolName.replace(/[^a-zA-Z0-9]/g, "_")}_Auth_Role`;
    const trustPolicy = {
      Version: "2012-10-17",
      Statement: [
        {
          Effect: "Allow",
          Principal: { Federated: "cognitoIdentity.amazonaws.com" },
          Action: "sts:AssumeRoleWithWebIdentity",
          Condition: {
            StringEquals: { "cognitoIdentity.amazonaws.com:aud": identityPoolId },
            "ForAnyValue:StringLike": { "cognitoIdentity.amazonaws.com:amr": "authenticated" }
          }
        }
      ]
    };
    const policyDocument = {
      Version: "2012-10-17",
      Statement: [
        {
          Effect: "Allow",
          Action: [
            "mobileanalytics:PutEvents",
            "cognito-sync:*",
            "cognito-identity:*"
          ],
          Resource: "*"
        }
      ]
    };
    return this.createIAMRole(roleName, trustPolicy, policyDocument);
  }
  /**
   * Creates an unauthenticated IAM role for the Identity Pool
   */
  createUnauthenticatedRole(identityPoolName, identityPoolId) {
    const roleName = `Cognito_${identityPoolName.replace(/[^a-zA-Z0-9]/g, "_")}_Unauth_Role`;
    const trustPolicy = {
      Version: "2012-10-17",
      Statement: [
        {
          Effect: "Allow",
          Principal: { Federated: "cognitoIdentity.amazonaws.com" },
          Action: "sts:AssumeRoleWithWebIdentity",
          Condition: {
            StringEquals: { "cognitoIdentity.amazonaws.com:aud": identityPoolId },
            "ForAnyValue:StringLike": { "cognitoIdentity.amazonaws.com:amr": "unauthenticated" }
          }
        }
      ]
    };
    const policyDocument = {
      Version: "2012-10-17",
      Statement: [
        {
          Effect: "Allow",
          Action: [
            "mobileanalytics:PutEvents",
            "cognito-sync:*"
          ],
          Resource: "*"
        }
      ]
    };
    return this.createIAMRole(roleName, trustPolicy, policyDocument);
  }
  /**
   * Creates an IAM role with the specified trust policy and permissions
   */
  createIAMRole(roleName, _trustPolicy, _policyDocument) {
    console.log(`Creating IAM role: ${roleName}`);
    const mockArn = `arn:aws:iam::123456789012:role/${roleName}`;
    console.log(`Created IAM role: ${mockArn}`);
    return mockArn;
  }
  /**
   * Attaches the created roles to the Identity Pool
   */
  attachRolesToIdentityPool(identityPoolId, authenticatedRoleArn, unauthenticatedRoleArn) {
    const roles = {
      authenticated: authenticatedRoleArn
    };
    if (unauthenticatedRoleArn) {
      roles.unauthenticated = unauthenticatedRoleArn;
    }
    console.log(`Attaching roles to Identity Pool ${identityPoolId}:`, roles);
  }
};
_init = __decoratorStart(_a);
__decorateElement(_init, 1, "getPoolInfo", _getPoolInfo_dec, _IdentityPool);
__decorateElement(_init, 1, "getCredentialsForIdentity", _getCredentialsForIdentity_dec, _IdentityPool);
__decorateElement(_init, 1, "getIdentityId", _getIdentityId_dec, _IdentityPool);
__decoratorMetadata(_init, _IdentityPool);
__name(_IdentityPool, "IdentityPool");
var IdentityPool = _IdentityPool;



function main(def, state, ctx) {
  const entity = new IdentityPool(def, state, ctx);
  return entity.main(ctx);
}
