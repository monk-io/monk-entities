// Generated by MonkEC - targeting Goja runtime
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// input/aws-mq/common.ts
var common_exports = {};
__export(common_exports, {
  buildCreateBrokerParams: () => buildCreateBrokerParams,
  buildUpdateBrokerParams: () => buildUpdateBrokerParams,
  formatBrokerState: () => formatBrokerState,
  getDefaultDeploymentMode: () => getDefaultDeploymentMode,
  getDefaultEngineVersion: () => getDefaultEngineVersion,
  getOrCreateUserPassword: () => getOrCreateUserPassword,
  parseMQError: () => parseMQError,
  validateBrokerName: () => validateBrokerName,
  validateDeploymentMode: () => validateDeploymentMode,
  validateEngineType: () => validateEngineType,
  validateInstanceType: () => validateInstanceType,
  validateMaintenanceWindow: () => validateMaintenanceWindow
});
module.exports = __toCommonJS(common_exports);
var import_secret = __toESM(require("secret"));
function validateBrokerName(name) {
  if (!name || name.length < 1 || name.length > 50) {
    return false;
  }
  if (name.startsWith("-") || name.endsWith("-")) {
    return false;
  }
  return /^[a-zA-Z0-9-]+$/.test(name);
}
function validateEngineType(engineType) {
  return ["ACTIVEMQ", "RABBITMQ"].includes(engineType);
}
function validateDeploymentMode(_engineType, _deploymentMode) {
  const validModes = {
    "ACTIVEMQ": ["SINGLE_INSTANCE", "ACTIVE_STANDBY_MULTI_AZ"],
    "RABBITMQ": ["SINGLE_INSTANCE", "CLUSTER_MULTI_AZ"]
  };
  return validModes[_engineType]?.includes(_deploymentMode) || false;
}
function getDefaultEngineVersion(engineType) {
  const defaultVersions = {
    "ACTIVEMQ": "5.18",
    "RABBITMQ": "3.11.20"
  };
  return defaultVersions[engineType] || "5.18";
}
function getDefaultDeploymentMode(_engineType) {
  return "SINGLE_INSTANCE";
}
function getOrCreateUserPassword(username, secretRef) {
  const actualSecretRef = secretRef || `mq-user-${username}-password`;
  try {
    const storedPassword = import_secret.default.get(actualSecretRef);
    if (!storedPassword) {
      throw new Error("Password not found");
    }
    return storedPassword;
  } catch (_e) {
    const password = import_secret.default.randString(16);
    import_secret.default.set(actualSecretRef, password);
    return password;
  }
}
function buildCreateBrokerParams(definition) {
  if (!validateBrokerName(definition.broker_name)) {
    throw new Error(`Invalid broker name: ${definition.broker_name}. Must be 1-50 alphanumeric characters or hyphens, cannot start/end with hyphen.`);
  }
  if (!validateEngineType(definition.engine_type)) {
    throw new Error(`Invalid engine type: ${definition.engine_type}. Must be ACTIVEMQ or RABBITMQ.`);
  }
  const params = {
    brokerName: definition.broker_name,
    engineType: definition.engine_type === "ACTIVEMQ" ? "ActiveMQ" : definition.engine_type,
    hostInstanceType: definition.host_instance_type
  };
  params.engineVersion = definition.engine_version || getDefaultEngineVersion(definition.engine_type);
  const deploymentMode = definition.deployment_mode || getDefaultDeploymentMode(definition.engine_type);
  if (!validateDeploymentMode(definition.engine_type, deploymentMode)) {
    throw new Error(`Invalid deployment mode ${deploymentMode} for engine type ${definition.engine_type}`);
  }
  params.deploymentMode = deploymentMode;
  if (definition.publicly_accessible !== void 0) {
    params.publiclyAccessible = definition.publicly_accessible;
  }
  if (definition.subnet_ids && definition.subnet_ids.length > 0) {
    params.subnetIds = definition.subnet_ids;
  }
  if (definition.security_groups && definition.security_groups.length > 0) {
    params.securityGroups = definition.security_groups;
  }
  if (definition.auto_minor_version_upgrade !== void 0) {
    params.autoMinorVersionUpgrade = definition.auto_minor_version_upgrade;
  }
  if (definition.maintenance_window_start_time) {
    params.maintenanceWindowStartTime = {
      dayOfWeek: definition.maintenance_window_start_time.split(":")[0],
      timeOfDay: definition.maintenance_window_start_time.split(":").slice(1).join(":"),
      timeZone: "UTC"
    };
  }
  if (definition.storage_type) {
    params.storageType = definition.storage_type;
  }
  if (definition.enable_general_logging !== void 0 || definition.enable_audit_logging !== void 0) {
    params.logs = {};
    if (definition.enable_general_logging !== void 0) {
      params.logs.general = definition.enable_general_logging;
    }
    if (definition.enable_audit_logging !== void 0) {
      params.logs.audit = definition.enable_audit_logging;
    }
  }
  if (definition.users && definition.users.length > 0) {
    params.users = definition.users.map((user) => {
      const userConfig = {
        username: user.username,
        password: getOrCreateUserPassword(user.username, user.password_secret_ref)
      };
      if (user.console_access !== void 0) {
        userConfig.consoleAccess = user.console_access;
      }
      if (user.groups && user.groups.length > 0) {
        userConfig.groups = user.groups;
      }
      return userConfig;
    });
  }
  if (definition.ldap_authentication) {
    const ldap = definition.ldap_authentication;
    params.ldapServerMetadata = {
      hosts: [ldap.host],
      userBase: ldap.user_base
    };
    if (ldap.port) {
      params.ldapServerMetadata.hosts = [`${ldap.host}:${ldap.port}`];
    }
    if (ldap.role_base) {
      params.ldapServerMetadata.roleBase = ldap.role_base;
    }
    if (ldap.service_account_username) {
      params.ldapServerMetadata.serviceAccountUsername = ldap.service_account_username;
      if (ldap.service_account_password_secret_ref) {
        params.ldapServerMetadata.serviceAccountPassword = import_secret.default.get(ldap.service_account_password_secret_ref);
      }
    }
  }
  if (definition.configuration && definition.configuration.id) {
    params.configuration = {
      id: definition.configuration.id
    };
    if (definition.configuration.revision) {
      params.configuration.revision = definition.configuration.revision;
    }
  }
  if (definition.encryption_options) {
    params.encryptionOptions = {};
    if (definition.encryption_options.use_aws_owned_key !== void 0) {
      params.encryptionOptions.useAwsOwnedKey = definition.encryption_options.use_aws_owned_key;
    }
    if (definition.encryption_options.kms_key_id) {
      params.encryptionOptions.kmsKeyId = definition.encryption_options.kms_key_id;
    }
  }
  if (definition.tags && Object.keys(definition.tags).length > 0) {
    params.tags = definition.tags;
  }
  return params;
}
function buildUpdateBrokerParams(definition) {
  const params = {};
  if (definition.auto_minor_version_upgrade !== void 0) {
    params.autoMinorVersionUpgrade = definition.auto_minor_version_upgrade;
  }
  if (definition.maintenance_window_start_time) {
    params.maintenanceWindowStartTime = {
      dayOfWeek: definition.maintenance_window_start_time.split(":")[0],
      timeOfDay: definition.maintenance_window_start_time.split(":").slice(1).join(":"),
      timeZone: "UTC"
    };
  }
  if (definition.enable_general_logging !== void 0 || definition.enable_audit_logging !== void 0) {
    params.logs = {};
    if (definition.enable_general_logging !== void 0) {
      params.logs.general = definition.enable_general_logging;
    }
    if (definition.enable_audit_logging !== void 0) {
      params.logs.audit = definition.enable_audit_logging;
    }
  }
  if (definition.security_groups && definition.security_groups.length > 0) {
    params.securityGroups = definition.security_groups;
  }
  return params;
}
function formatBrokerState(broker, wasPreExisting = false) {
  const endpoints = [];
  const instances = broker.brokerInstances || broker.BrokerInstances;
  if (instances && Array.isArray(instances) && instances.length > 0) {
    instances.forEach((instance) => {
      const endpointList = instance.endpoints || instance.Endpoints;
      if (endpointList && Array.isArray(endpointList)) {
        endpoints.push(...endpointList);
      }
    });
  }
  return {
    existing: wasPreExisting,
    // true = don't delete (pre-existing), false = we created it (can delete)
    broker_id: broker.brokerId || broker.BrokerId,
    // Handle both casing (prefer camelCase first)
    broker_arn: broker.brokerArn || broker.BrokerArn,
    // Handle both casing
    broker_state: broker.brokerState || broker.BrokerState,
    // Handle both casing
    created: broker.created || broker.Created,
    // Handle both casing
    last_modified: broker.lastModified || broker.Modified,
    // Handle both casing
    endpoints,
    web_console_url: instances?.[0]?.consoleURL || instances?.[0]?.ConsoleURL
    // Handle both casings
  };
}
function validateInstanceType(engineType, instanceType) {
  const validTypes = [
    "mq.t3.micro",
    "mq.t3.small",
    "mq.t3.medium",
    "mq.t3.large",
    "mq.m5.large",
    "mq.m5.xlarge",
    "mq.m5.2xlarge",
    "mq.m5.4xlarge",
    "mq.m5.12xlarge",
    "mq.m5.24xlarge"
  ];
  if (engineType === "RABBITMQ") {
    validTypes.push("mq.t3.micro", "mq.m5.large", "mq.m5.xlarge");
  }
  return validTypes.includes(instanceType);
}
function validateMaintenanceWindow(window) {
  const pattern = /^(sun|mon|tue|wed|thu|fri|sat):(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9](-((sun|mon|tue|wed|thu|fri|sat):(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]))?$/;
  return pattern.test(window.toLowerCase());
}
function parseMQError(responseBody) {
  try {
    const errorBody = JSON.parse(responseBody);
    if (errorBody.message) {
      return errorBody.message;
    }
    if (errorBody.__type) {
      return errorBody.__type;
    }
  } catch (_error) {
  }
  return responseBody;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  buildCreateBrokerParams,
  buildUpdateBrokerParams,
  formatBrokerState,
  getDefaultDeploymentMode,
  getDefaultEngineVersion,
  getOrCreateUserPassword,
  parseMQError,
  validateBrokerName,
  validateDeploymentMode,
  validateEngineType,
  validateInstanceType,
  validateMaintenanceWindow
});
