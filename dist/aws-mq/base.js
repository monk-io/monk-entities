// Generated by MonkEC - targeting Goja runtime
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);

// input/aws-mq/base.ts
var base_exports = {};
__export(base_exports, {
  AWSMQEntity: () => AWSMQEntity
});
module.exports = __toCommonJS(base_exports);
var import_base = require("monkec/base");
var import_aws = __toESM(require("cloud/aws"));
var AWSMQEntity = class extends import_base.MonkEntity {
  constructor() {
    super(...arguments);
    __publicField(this, "region");
  }
  before() {
    this.region = this.definition.region;
  }
  makeMQRequest(method, path, body) {
    const url = `https://mq.${this.region}.amazonaws.com${path}`;
    const requestOptions = {
      method,
      url,
      service: "mq",
      region: this.region,
      headers: {
        "Content-Type": "application/json"
      }
    };
    if (body) {
      requestOptions.body = JSON.stringify(body);
    }
    const response = method === "GET" ? import_aws.default.get(url, { service: "mq", region: this.region, headers: { "Content-Type": "application/json" } }) : import_aws.default.post(url, { service: "mq", region: this.region, headers: { "Content-Type": "application/json" }, body: requestOptions.body });
    if (response.statusCode >= 400) {
      let errorMessage = `AWS MQ API error: ${response.statusCode} ${response.status}`;
      try {
        const errorBody = JSON.parse(response.body);
        if (errorBody.message) {
          errorMessage += ` - ${errorBody.message}`;
        }
        if (errorBody.__type) {
          errorMessage += ` (${errorBody.__type})`;
        }
        if (response.statusCode === 403) {
          errorMessage += `

Required AWS IAM permissions for MQ operations:
{
    "Version": "2012-10-17",
    "Statement": [
        {
            "Effect": "Allow",
            "Action": [
                "mq:CreateBroker",
                "mq:DeleteBroker",
                "mq:DescribeBroker",
                "mq:ListBrokers",
                "mq:ModifyBroker",
                "mq:RebootBroker",
                "mq:CreateTags",
                "mq:DeleteTags",
                "mq:ListTags"
            ],
            "Resource": "*"
        },
        {
            "Effect": "Allow",
            "Action": [
                "ec2:DescribeVpcs",
                "ec2:DescribeSubnets",
                "ec2:DescribeSecurityGroups"
            ],
            "Resource": "*"
        }
    ]
}`;
        }
      } catch (_parseError) {
        errorMessage += ` - Raw: ${response.body}`;
      }
      throw new Error(errorMessage);
    }
    try {
      return response.body ? JSON.parse(response.body) : {};
    } catch (parseError) {
      throw new Error(`Failed to parse MQ API response: ${parseError instanceof Error ? parseError.message : "Unknown error"}`);
    }
  }
  checkBrokerExists(brokerId) {
    try {
      return this.makeMQRequest("GET", `/v1/brokers/${encodeURIComponent(brokerId)}`);
    } catch (error) {
      if (error instanceof Error && (error.message.includes("NotFoundException") || error.message.includes("404"))) {
        return null;
      }
      throw error;
    }
  }
  createBroker(params) {
    return this.makeMQRequest("POST", "/v1/brokers", params);
  }
  updateBroker(brokerId, params) {
    return this.makeMQRequest("PUT", `/v1/brokers/${encodeURIComponent(brokerId)}`, params);
  }
  deleteBroker(brokerId) {
    this.makeMQRequest("DELETE", `/v1/brokers/${encodeURIComponent(brokerId)}`);
  }
  rebootBroker(brokerId) {
    this.makeMQRequest("POST", `/v1/brokers/${encodeURIComponent(brokerId)}/reboot`);
  }
  listBrokers() {
    return this.makeMQRequest("GET", "/v1/brokers");
  }
  findBrokerByName(brokerName) {
    try {
      const response = this.listBrokers();
      if (response && response.brokerSummaries) {
        const broker = response.brokerSummaries.find((b) => b.brokerName === brokerName);
        if (broker && broker.brokerId) {
          return this.checkBrokerExists(broker.brokerId);
        }
      }
      return null;
    } catch (error) {
      return null;
    }
  }
  waitForBrokerState(brokerId, targetState, maxAttempts = 60) {
    for (let attempt = 0; attempt < maxAttempts; attempt++) {
      try {
        const response = this.checkBrokerExists(brokerId);
        if (response?.BrokerState === targetState) {
          return true;
        }
        if (response?.BrokerState === "DELETION_FAILED" || response?.BrokerState === "CREATION_FAILED") {
          throw new Error(`Broker ${brokerId} is in failed state: ${response.BrokerState}`);
        }
        const start = Date.now();
        while (Date.now() - start < 3e4) {
        }
      } catch (error) {
        if (attempt === maxAttempts - 1) {
          throw error;
        }
      }
    }
    return false;
  }
  waitForBrokerDeletion(brokerId, maxAttempts = 40) {
    for (let attempt = 0; attempt < maxAttempts; attempt++) {
      try {
        const response = this.checkBrokerExists(brokerId);
        if (!response) {
          console.log(`MQ broker ${brokerId} has been successfully deleted`);
          return true;
        }
        const state = response.BrokerState;
        if (state === "DELETION_IN_PROGRESS") {
          const start = Date.now();
          while (Date.now() - start < 3e4) {
          }
          continue;
        }
        throw new Error(`MQ broker ${brokerId} is in unexpected state: ${state}`);
      } catch (error) {
        if (error instanceof Error && (error.message.includes("NotFoundException") || error.message.includes("404"))) {
          return true;
        }
        if (attempt === maxAttempts - 1) {
          throw new Error(`Failed to confirm MQ broker deletion: ${error instanceof Error ? error.message : "Unknown error"}`);
        }
        const start = Date.now();
        while (Date.now() - start < 3e4) {
        }
      }
    }
    return false;
  }
  getDefaultEngineVersion(_engineType) {
    const defaultVersions = {
      "ACTIVEMQ": "5.17.6",
      "RABBITMQ": "3.11.20"
    };
    return defaultVersions[_engineType] || "5.17.6";
  }
  getDefaultDeploymentMode(_engineType) {
    return "SINGLE_INSTANCE";
  }
  validateBrokerName(name) {
    if (!name || name.length < 1 || name.length > 50) {
      return false;
    }
    if (name.startsWith("-") || name.endsWith("-")) {
      return false;
    }
    return /^[a-zA-Z0-9-]+$/.test(name);
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  AWSMQEntity
});
