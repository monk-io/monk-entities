// Generated by MonkEC - targeting Goja runtime
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);

// input/aws-iam/base.ts
var base_exports = {};
__export(base_exports, {
  AWSIAMEntity: () => AWSIAMEntity
});
module.exports = __toCommonJS(base_exports);
var import_base = require("monkec/base");
var import_aws = __toESM(require("cloud/aws"));
var AWSIAMEntity = class extends import_base.MonkEntity {
  constructor() {
    super(...arguments);
    __publicField(this, "region");
  }
  before() {
    this.region = this.definition.region;
  }
  makeAWSRequest(method, action, body) {
    const url = "https://iam.amazonaws.com/";
    const options = {
      service: "iam",
      region: this.region,
      headers: {
        "Content-Type": "application/x-www-form-urlencoded"
      },
      timeout: 3e4
    };
    let formData = "Action=" + encodeURIComponent(action) + "&Version=2010-05-08";
    if (body) {
      for (const [key, value] of Object.entries(body)) {
        if (value !== void 0 && value !== null) {
          if (typeof value === "object") {
            formData += "&" + encodeURIComponent(key) + "=" + encodeURIComponent(JSON.stringify(value));
          } else {
            formData += "&" + encodeURIComponent(key) + "=" + encodeURIComponent(String(value));
          }
        }
      }
    }
    options.body = formData;
    try {
      let response;
      if (method === "GET") {
        response = import_aws.default.get(url, options);
      } else if (method === "POST") {
        response = import_aws.default.post(url, options);
      } else if (method === "PUT") {
        response = import_aws.default.put(url, options);
      } else if (method === "DELETE") {
        response = import_aws.default.delete(url, options);
      } else {
        throw new Error("Unsupported HTTP method: " + method);
      }
      if (response.statusCode >= 400) {
        let errorMessage = "AWS IAM API error: " + response.statusCode + " " + response.status;
        try {
          const errorBody = this.parseXMLError(response.body);
          if (errorBody.Error?.Message) {
            errorMessage += ` - ${errorBody.Error.Message}`;
          }
          if (errorBody.Error?.Code) {
            errorMessage += ` - Code: ${errorBody.Error.Code}`;
          }
        } catch (parseError) {
          errorMessage += ` - Raw: ${response.body}`;
        }
        throw new Error(errorMessage);
      }
      if (response.body) {
        try {
          return this.parseXMLResponse(response.body);
        } catch (error) {
          throw new Error(`Failed to parse AWS IAM API response: ${error instanceof Error ? error.message : "Unknown error"}`);
        }
      }
      return response;
    } catch (error) {
      throw new Error(`AWS IAM API request failed: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  parseXMLError(xmlBody) {
    const errorMatch = xmlBody.match(/<Error>(.*?)<\/Error>/s);
    if (!errorMatch) {
      return {};
    }
    const errorContent = errorMatch[1];
    const codeMatch = errorContent.match(/<Code>(.*?)<\/Code>/);
    const messageMatch = errorContent.match(/<Message>(.*?)<\/Message>/);
    const typeMatch = errorContent.match(/<Type>(.*?)<\/Type>/);
    return {
      Error: {
        Code: codeMatch ? codeMatch[1] : void 0,
        Message: messageMatch ? messageMatch[1] : void 0,
        Type: typeMatch ? typeMatch[1] : void 0
      }
    };
  }
  parseXMLResponse(xmlBody) {
    if (xmlBody.indexOf("<CreatePolicyResponse") !== -1) {
      return this.parseCreatePolicyResponse(xmlBody);
    } else if (xmlBody.indexOf("<CreatePolicyVersionResponse") !== -1) {
      return this.parseCreatePolicyVersionResponse(xmlBody);
    } else if (xmlBody.indexOf("<GetPolicyResponse") !== -1) {
      return this.parseGetPolicyResponse(xmlBody);
    } else if (xmlBody.indexOf("<CreateRoleResponse") !== -1) {
      return this.parseCreateRoleResponse(xmlBody);
    } else if (xmlBody.indexOf("<GetRoleResponse") !== -1) {
      return this.parseGetRoleResponse(xmlBody);
    } else if (xmlBody.indexOf("<ListAttachedRolePoliciesResponse") !== -1) {
      return this.parseListAttachedRolePoliciesResponse(xmlBody);
    } else if (xmlBody.indexOf("<ListRolePoliciesResponse") !== -1) {
      return this.parseListRolePoliciesResponse(xmlBody);
    } else if (xmlBody.indexOf("<ListPoliciesResponse") !== -1) {
      return this.parseListPoliciesResponse(xmlBody);
    } else if (xmlBody.indexOf("<GetPolicyVersionResponse") !== -1) {
      return this.parseGetPolicyVersionResponse(xmlBody);
    }
    return { rawBody: xmlBody };
  }
  parseCreatePolicyResponse(xmlBody) {
    let policyMatch = xmlBody.match(/<Policy>(.*?)<\/Policy>/s);
    if (!policyMatch) {
      const resultMatch = xmlBody.match(/<CreatePolicyResult>(.*?)<\/CreatePolicyResult>/s);
      if (resultMatch) {
        policyMatch = resultMatch[1].match(/<Policy>(.*?)<\/Policy>/s);
      }
    }
    if (!policyMatch) {
      return {};
    }
    const policyContent = policyMatch[1];
    return {
      Policy: {
        PolicyName: this.extractXMLValue(policyContent, "PolicyName"),
        PolicyId: this.extractXMLValue(policyContent, "PolicyId"),
        Arn: this.extractXMLValue(policyContent, "Arn"),
        Path: this.extractXMLValue(policyContent, "Path"),
        DefaultVersionId: this.extractXMLValue(policyContent, "DefaultVersionId"),
        CreateDate: this.extractXMLValue(policyContent, "CreateDate"),
        UpdateDate: this.extractXMLValue(policyContent, "UpdateDate")
      }
    };
  }
  parseCreatePolicyVersionResponse(xmlBody) {
    let versionMatch = xmlBody.match(/<PolicyVersion>(.*?)<\/PolicyVersion>/s);
    if (!versionMatch) {
      const resultMatch = xmlBody.match(/<CreatePolicyVersionResult>(.*?)<\/CreatePolicyVersionResult>/s);
      if (resultMatch) {
        versionMatch = resultMatch[1].match(/<PolicyVersion>(.*?)<\/PolicyVersion>/s);
      }
    }
    if (!versionMatch) {
      return {};
    }
    const versionContent = versionMatch[1];
    return {
      PolicyVersion: {
        VersionId: this.extractXMLValue(versionContent, "VersionId"),
        IsDefaultVersion: this.extractXMLValue(versionContent, "IsDefaultVersion") === "true",
        CreateDate: this.extractXMLValue(versionContent, "CreateDate")
      }
    };
  }
  parseCreateRoleResponse(xmlBody) {
    let roleMatch = xmlBody.match(/<Role>(.*?)<\/Role>/s);
    if (!roleMatch) {
      const resultMatch = xmlBody.match(/<CreateRoleResult>(.*?)<\/CreateRoleResult>/s);
      if (resultMatch) {
        roleMatch = resultMatch[1].match(/<Role>(.*?)<\/Role>/s);
      }
    }
    if (!roleMatch) {
      return {};
    }
    const roleContent = roleMatch[1];
    return {
      Role: {
        RoleName: this.extractXMLValue(roleContent, "RoleName"),
        RoleId: this.extractXMLValue(roleContent, "RoleId"),
        Arn: this.extractXMLValue(roleContent, "Arn"),
        Path: this.extractXMLValue(roleContent, "Path"),
        AssumeRolePolicyDocument: this.extractXMLValue(roleContent, "AssumeRolePolicyDocument"),
        Description: this.extractXMLValue(roleContent, "Description"),
        MaxSessionDuration: parseInt(this.extractXMLValue(roleContent, "MaxSessionDuration") || "3600"),
        CreateDate: this.extractXMLValue(roleContent, "CreateDate")
      }
    };
  }
  parseGetRoleResponse(xmlBody) {
    let roleMatch = xmlBody.match(/<Role>(.*?)<\/Role>/s);
    if (!roleMatch) {
      const resultMatch = xmlBody.match(/<GetRoleResult>(.*?)<\/GetRoleResult>/s);
      if (resultMatch) {
        roleMatch = resultMatch[1].match(/<Role>(.*?)<\/Role>/s);
      }
    }
    if (!roleMatch) {
      return {};
    }
    const roleContent = roleMatch[1];
    return {
      Role: {
        RoleName: this.extractXMLValue(roleContent, "RoleName"),
        RoleId: this.extractXMLValue(roleContent, "RoleId"),
        Arn: this.extractXMLValue(roleContent, "Arn"),
        Path: this.extractXMLValue(roleContent, "Path"),
        AssumeRolePolicyDocument: this.extractXMLValue(roleContent, "AssumeRolePolicyDocument"),
        Description: this.extractXMLValue(roleContent, "Description"),
        MaxSessionDuration: parseInt(this.extractXMLValue(roleContent, "MaxSessionDuration") || "3600"),
        CreateDate: this.extractXMLValue(roleContent, "CreateDate")
      }
    };
  }
  parseListAttachedRolePoliciesResponse(xmlBody) {
    const resultMatch = xmlBody.match(/<ListAttachedRolePoliciesResult>(.*?)<\/ListAttachedRolePoliciesResult>/s);
    if (!resultMatch) {
      return { AttachedPolicies: [] };
    }
    const resultContent = resultMatch[1];
    const attachedPolicies = [];
    const attachedPoliciesMatch = resultContent.match(/<AttachedPolicies>(.*?)<\/AttachedPolicies>/s);
    if (attachedPoliciesMatch) {
      const memberMatches = attachedPoliciesMatch[1].match(/<member>(.*?)<\/member>/gs);
      if (memberMatches) {
        for (const memberMatch of memberMatches) {
          const memberContent = memberMatch.replace(/<\/?member>/g, "");
          attachedPolicies.push({
            PolicyName: this.extractXMLValue(memberContent, "PolicyName"),
            PolicyArn: this.extractXMLValue(memberContent, "PolicyArn")
          });
        }
      }
    }
    return { AttachedPolicies: attachedPolicies };
  }
  parseListRolePoliciesResponse(xmlBody) {
    const resultMatch = xmlBody.match(/<ListRolePoliciesResult>(.*?)<\/ListRolePoliciesResult>/s);
    if (!resultMatch) {
      return { PolicyNames: [] };
    }
    const resultContent = resultMatch[1];
    const policyNames = [];
    const policyNamesMatch = resultContent.match(/<PolicyNames>(.*?)<\/PolicyNames>/s);
    if (policyNamesMatch) {
      const memberMatches = policyNamesMatch[1].match(/<member>(.*?)<\/member>/gs);
      if (memberMatches) {
        for (const memberMatch of memberMatches) {
          const memberContent = memberMatch.replace(/<\/?member>/g, "").trim();
          if (memberContent) {
            policyNames.push(memberContent);
          }
        }
      }
    }
    return { PolicyNames: policyNames };
  }
  parseGetPolicyResponse(xmlBody) {
    let policyMatch = xmlBody.match(/<Policy>(.*?)<\/Policy>/s);
    if (!policyMatch) {
      const resultMatch = xmlBody.match(/<GetPolicyResult>(.*?)<\/GetPolicyResult>/s);
      if (resultMatch) {
        policyMatch = resultMatch[1].match(/<Policy>(.*?)<\/Policy>/s);
      }
    }
    if (!policyMatch) {
      return {};
    }
    const policyContent = policyMatch[1];
    return {
      Policy: {
        PolicyName: this.extractXMLValue(policyContent, "PolicyName"),
        PolicyId: this.extractXMLValue(policyContent, "PolicyId"),
        Arn: this.extractXMLValue(policyContent, "Arn"),
        Path: this.extractXMLValue(policyContent, "Path"),
        DefaultVersionId: this.extractXMLValue(policyContent, "DefaultVersionId"),
        AttachmentCount: parseInt(this.extractXMLValue(policyContent, "AttachmentCount") || "0"),
        CreateDate: this.extractXMLValue(policyContent, "CreateDate"),
        UpdateDate: this.extractXMLValue(policyContent, "UpdateDate")
      }
    };
  }
  parseListPoliciesResponse(_xmlBody) {
    return { Policies: [] };
  }
  parseGetPolicyVersionResponse(xmlBody) {
    const versionMatch = xmlBody.match(/<PolicyVersion>(.*?)<\/PolicyVersion>/s);
    if (!versionMatch) return {};
    const versionContent = versionMatch[1];
    return {
      PolicyVersion: {
        Document: this.extractXMLValue(versionContent, "Document"),
        VersionId: this.extractXMLValue(versionContent, "VersionId"),
        IsDefaultVersion: this.extractXMLValue(versionContent, "IsDefaultVersion") === "true",
        CreateDate: this.extractXMLValue(versionContent, "CreateDate")
      }
    };
  }
  extractXMLValue(content, tagName) {
    const match = content.match(new RegExp("<" + tagName + ">(.*?)</" + tagName + ">", "s"));
    return match ? decodeURIComponent(match[1]) : void 0;
  }
  checkPolicyExists(policyName) {
    try {
      const definition = this.definition;
      const path = definition.path || "/";
      const policyArn = `arn:aws:iam::${this.getAccountId()}:policy${path}${policyName}`;
      const result = this.makeAWSRequest("POST", "GetPolicy", {
        PolicyArn: policyArn
      });
      return result;
    } catch (error) {
      return null;
    }
  }
  deletePolicy(policyArn, policyName) {
    if (this.state.existing) {
      return;
    }
    try {
      this.makeAWSRequest("POST", "DeletePolicy", {
        PolicyArn: policyArn
      });
    } catch (error) {
      throw new Error(`Failed to delete IAM Policy ${policyName}: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  // Helper method to get AWS account ID using STS GetCallerIdentity
  getAccountId() {
    try {
      const response = this.makeSTSRequest("POST", "GetCallerIdentity", {});
      if (response.Account) {
        return response.Account;
      }
    } catch (error) {
    }
    return "123456789012";
  }
  // Helper method to make STS API requests
  makeSTSRequest(method, action, body) {
    const url = "https://sts.amazonaws.com/";
    const options = {
      service: "sts",
      region: "us-east-1",
      headers: {
        "Content-Type": "application/x-www-form-urlencoded"
      },
      timeout: 3e4
    };
    let formData = `Action=${action}&Version=2011-06-15`;
    if (body) {
      for (const [key, value] of Object.entries(body)) {
        if (value !== void 0 && value !== null) {
          formData += `&${encodeURIComponent(key)}=${encodeURIComponent(String(value))}`;
        }
      }
    }
    options.body = formData;
    try {
      let response;
      if (method === "POST") {
        response = import_aws.default.post(url, options);
      } else if (method === "GET") {
        response = import_aws.default.get(url, options);
      } else {
        throw new Error("Unsupported HTTP method for STS: " + method);
      }
      if (response.statusCode >= 400) {
        throw new Error(`STS API error: ${response.statusCode} ${response.status}`);
      }
      if (response.body) {
        return this.parseSTSResponse(response.body);
      }
      return response;
    } catch (error) {
      throw new Error(`STS API request failed: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  // Simple XML parser for STS GetCallerIdentity response
  parseSTSResponse(xmlBody) {
    const accountMatch = xmlBody.match(/<Account>([^<]+)<\/Account>/);
    if (accountMatch && accountMatch[1]) {
      return { Account: accountMatch[1] };
    }
    return { rawBody: xmlBody };
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  AWSIAMEntity
});
