
// Generated by MonkEC - targeting Goja runtime
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __knownSymbol = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __decoratorStart = (base) => [, , , __create(base?.[__knownSymbol("metadata")] ?? null)];
var __decoratorStrings = ["class", "method", "getter", "setter", "accessor", "field", "value", "get", "set"];
var __expectFn = (fn) => fn !== void 0 && typeof fn !== "function" ? __typeError("Function expected") : fn;
var __decoratorContext = (kind, name, done, metadata, fns) => ({ kind: __decoratorStrings[kind], name, metadata, addInitializer: (fn) => done._ ? __typeError("Already initialized") : fns.push(__expectFn(fn || null)) });
var __decoratorMetadata = (array, target) => __defNormalProp(target, __knownSymbol("metadata"), array[3]);
var __runInitializers = (array, flags, self, value) => {
  for (var i = 0, fns = array[flags >> 1], n = fns && fns.length; i < n; i++) flags & 1 ? fns[i].call(self) : value = fns[i].call(self, value);
  return value;
};
var __decorateElement = (array, flags, name, decorators, target, extra) => {
  var fn, it, done, ctx, access, k = flags & 7, s = !!(flags & 8), p = !!(flags & 16);
  var j = k > 3 ? array.length + 1 : k ? s ? 1 : 2 : 0, key = __decoratorStrings[k + 5];
  var initializers = k > 3 && (array[j - 1] = []), extraInitializers = array[j] || (array[j] = []);
  var desc = k && (!p && !s && (target = target.prototype), k < 5 && (k > 3 || !p) && __getOwnPropDesc(k < 4 ? target : { get [name]() {
    return __privateGet(this, extra);
  }, set [name](x) {
    return __privateSet(this, extra, x);
  } }, name));
  k ? p && k < 4 && __name(extra, (k > 2 ? "set " : k > 1 ? "get " : "") + name) : __name(target, name);
  for (var i = decorators.length - 1; i >= 0; i--) {
    ctx = __decoratorContext(k, name, done = {}, array[3], extraInitializers);
    if (k) {
      ctx.static = s, ctx.private = p, access = ctx.access = { has: p ? (x) => __privateIn(target, x) : (x) => name in x };
      if (k ^ 3) access.get = p ? (x) => (k ^ 1 ? __privateGet : __privateMethod)(x, target, k ^ 4 ? extra : desc.get) : (x) => x[name];
      if (k > 2) access.set = p ? (x, y) => __privateSet(x, target, y, k ^ 4 ? extra : desc.set) : (x, y) => x[name] = y;
    }
    it = (0, decorators[i])(k ? k < 4 ? p ? extra : desc[key] : k > 4 ? void 0 : { get: desc.get, set: desc.set } : target, ctx), done._ = 1;
    if (k ^ 4 || it === void 0) __expectFn(it) && (k > 4 ? initializers.unshift(it) : k ? p ? extra = it : desc[key] = it : target = it);
    else if (typeof it !== "object" || it === null) __typeError("Object expected");
    else __expectFn(fn = it.get) && (desc.get = fn), __expectFn(fn = it.set) && (desc.set = fn), __expectFn(fn = it.init) && initializers.unshift(fn);
  }
  return k || __decoratorMetadata(array, target), desc && __defProp(target, name, desc), p ? k ^ 4 ? extra : desc : target;
};
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateIn = (member, obj) => Object(obj) !== obj ? __typeError('Cannot use the "in" operator on this value') : member.has(obj);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);

// input/aws-iam/user.ts
const iamBase = require("aws-iam/iam-base");
const AWSIAMEntity = iamBase.AWSIAMEntity;
const common = require("aws-iam/common");
const IAM_ACTIONS = common.IAM_ACTIONS;
const formatIAMResourceName = common.formatIAMResourceName;
const base = require("monkec/base");
const action = base.action;
const cli = require("cli");
const secret = require("secret");
var _regenerateAccessKeys_dec, _createAccessKeysAction_dec, _getCredentials_dec, _listAccessKeys_dec, _getUserInfo_dec, _a, _init;
var _IAMUser = class _IAMUser extends (_a = AWSIAMEntity, _getUserInfo_dec = [action("get-user-info")], _listAccessKeys_dec = [action("list-access-keys")], _getCredentials_dec = [action("get-credentials")], _createAccessKeysAction_dec = [action("create-access-keys")], _regenerateAccessKeys_dec = [action("regenerate-access-keys")], _a) {
  constructor() {
    super(...arguments);
    __runInitializers(_init, 5, this);
  }
  checkReadiness() {
    const userName = formatIAMResourceName(this.definition.user_name);
    try {
      if (this.state.existing) {
        console.log(`IAM User ${userName} is existing user - checking configuration readiness`);
        if (this.definition.create_access_keys && !this.state.access_key_id) {
          console.log(`IAM User ${userName} not ready - access keys not created for existing user`);
          return false;
        }
        console.log(`IAM User ${userName} (existing) is ready`);
        return true;
      }
      const userExists = this.checkUserExists(userName);
      if (!userExists) {
        console.log(`IAM User ${userName} not ready - user doesn't exist`);
        return false;
      }
      if (this.definition.create_access_keys && !this.state.access_key_id) {
        console.log(`IAM User ${userName} not ready - access keys not created`);
        return false;
      }
      console.log(`IAM User ${userName} is ready`);
      return true;
    } catch (error) {
      console.log(`IAM User ${userName} readiness check failed: ${error instanceof Error ? error.message : "Unknown error"}`);
      return false;
    }
  }
  checkLiveness() {
    return this.checkReadiness();
  }
  create() {
    const userName = formatIAMResourceName(this.definition.user_name);
    const existingUser = this.checkUserExists(userName);
    if (existingUser) {
      this.state.existing = true;
      const userObj = existingUser.User;
      this.state.user_arn = userObj?.Arn;
      this.state.user_id = userObj?.UserId;
      this.state.create_date = userObj?.CreateDate;
      cli.output(`IAM User ${userName} already exists, managing existing user`);
      this.attachPolicies();
      this.createAccessKeysIfRequested();
      return;
    }
    const params = {
      UserName: userName
    };
    if (this.definition.path) {
      params.Path = this.definition.path;
    }
    if (this.definition.permissions_boundary) {
      params.PermissionsBoundary = this.definition.permissions_boundary;
    }
    if (this.definition.tags) {
      let tagIndex = 1;
      for (const [key, value] of Object.entries(this.definition.tags)) {
        params[`Tags.member.${tagIndex}.Key`] = key;
        params[`Tags.member.${tagIndex}.Value`] = value;
        tagIndex++;
      }
    }
    try {
      const response = this.makeAWSRequest("POST", IAM_ACTIONS.CREATE_USER, params);
      if (response?.User) {
        this.state.existing = false;
        this.state.user_arn = response.User.Arn;
        this.state.user_id = response.User.UserId;
        this.state.create_date = response.User.CreateDate;
        cli.output(`Created IAM User: ${userName} (ARN: ${this.state.user_arn})`);
        this.attachPolicies();
        this.createAccessKeysIfRequested();
      } else {
        throw new Error("User creation response missing User object");
      }
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : "Unknown error";
      if (errorMessage.includes("EntityAlreadyExists") || errorMessage.includes("already exists")) {
        cli.output(`IAM User ${userName} already exists, attempting to manage existing user`);
        const existingUser2 = this.checkUserExists(userName);
        if (existingUser2) {
          this.state.existing = true;
          const userObj = existingUser2.User;
          this.state.user_arn = userObj?.Arn;
          this.state.user_id = userObj?.UserId;
          this.state.create_date = userObj?.CreateDate;
          cli.output(`Managing existing IAM User: ${userName} (ARN: ${this.state.user_arn})`);
        } else {
          this.state.existing = true;
          this.state.user_arn = `arn:aws:iam::*:user/${userName}`;
          cli.output(`Managing existing IAM User: ${userName} (limited permissions - using basic ARN)`);
        }
        try {
          this.attachPolicies();
          this.createAccessKeysIfRequested();
        } catch (policyError) {
          const policyErrorMsg = policyError instanceof Error ? policyError.message : "Unknown error";
          cli.output(`Note: Could not fully configure existing user: ${policyErrorMsg}`);
        }
        return;
      }
      throw new Error(`Failed to create IAM User ${userName}: ${errorMessage}`);
    }
  }
  delete() {
    const userName = formatIAMResourceName(this.definition.user_name);
    if (this.state.existing) {
      cli.output(`Not deleting pre-existing IAM User ${userName}`);
      if (this.state.access_keys_created && this.state.access_key_id) {
        this.deleteAllAccessKeys();
      }
      this.detachPolicies();
      this.state.user_arn = void 0;
      this.state.user_id = void 0;
      this.state.access_key_id = void 0;
      this.state.access_keys_created = void 0;
      this.state.attached_policies = void 0;
      return;
    }
    if (!this.state.user_arn) {
      cli.output(`IAM User ${userName} not found in state, nothing to delete`);
      return;
    }
    try {
      this.deleteAllAccessKeys();
      this.detachPolicies();
      this.makeAWSRequest("POST", IAM_ACTIONS.DELETE_USER, {
        UserName: userName
      });
      cli.output(`Deleted IAM User: ${userName}`);
      this.state.user_arn = void 0;
      this.state.user_id = void 0;
      this.state.create_date = void 0;
      this.state.access_key_id = void 0;
      this.state.access_keys_created = void 0;
      this.state.attached_policies = void 0;
    } catch (error) {
      throw new Error(`Failed to delete IAM User ${userName}: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  update() {
    const userName = formatIAMResourceName(this.definition.user_name);
    this.attachPolicies();
    this.createAccessKeysIfRequested();
    cli.output(`Updated IAM User ${userName}`);
  }
  getPolicyName() {
    return formatIAMResourceName(this.definition.user_name);
  }
  checkUserExists(userName) {
    try {
      const response = this.makeAWSRequest("POST", IAM_ACTIONS.GET_USER, {
        UserName: userName
      });
      return response;
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : "Unknown error";
      if (errorMessage.includes("NoSuchEntity") || errorMessage.includes("does not exist") || errorMessage.includes("404")) {
        return null;
      }
      console.log(`Warning: Error checking if user ${userName} exists: ${errorMessage}`);
      return null;
    }
  }
  attachPolicies() {
    if (!this.definition.attached_policy_arns || this.definition.attached_policy_arns.length === 0) {
      return;
    }
    const userName = formatIAMResourceName(this.definition.user_name);
    const attachedPolicies = [];
    for (const policyArn of this.definition.attached_policy_arns) {
      try {
        this.makeAWSRequest("POST", IAM_ACTIONS.ATTACH_USER_POLICY, {
          UserName: userName,
          PolicyArn: policyArn
        });
        attachedPolicies.push(policyArn);
        cli.output(`Attached policy ${policyArn} to user ${userName}`);
      } catch (error) {
        if (error instanceof Error && error.message.includes("already attached")) {
          attachedPolicies.push(policyArn);
          cli.output(`Policy ${policyArn} already attached to user ${userName}`);
        } else {
          cli.output(`Failed to attach policy ${policyArn}: ${error instanceof Error ? error.message : "Unknown error"}`);
        }
      }
    }
    this.state.attached_policies = attachedPolicies;
  }
  detachPolicies() {
    if (!this.state.attached_policies || this.state.attached_policies.length === 0) {
      return;
    }
    const userName = formatIAMResourceName(this.definition.user_name);
    for (const policyArn of this.state.attached_policies) {
      try {
        this.makeAWSRequest("POST", IAM_ACTIONS.DETACH_USER_POLICY, {
          UserName: userName,
          PolicyArn: policyArn
        });
        cli.output(`Detached policy ${policyArn} from user ${userName}`);
      } catch (error) {
        cli.output(`Failed to detach policy ${policyArn}: ${error instanceof Error ? error.message : "Unknown error"}`);
      }
    }
    this.state.attached_policies = void 0;
  }
  createAccessKeysIfRequested() {
    if (!this.definition.create_access_keys) {
      return;
    }
    if (this.state.access_key_id && this.state.access_keys_created) {
      cli.output("Access keys already created for this user");
      return;
    }
    const userName = formatIAMResourceName(this.definition.user_name);
    try {
      const response = this.makeAWSRequest("POST", IAM_ACTIONS.CREATE_ACCESS_KEY, {
        UserName: userName
      });
      if (response?.AccessKey) {
        this.state.access_key_id = response.AccessKey.AccessKeyId;
        this.state.access_keys_created = true;
        this.storeCredentialsInSecrets(
          response.AccessKey.AccessKeyId,
          response.AccessKey.SecretAccessKey
        );
        cli.output(`Created access keys for IAM User ${userName}`);
        cli.output(`Access key ID stored in secret: ${this.getAccessKeyIdSecretRef()}`);
        cli.output(`Secret access key stored in secret: ${this.getSecretAccessKeySecretRef()}`);
      } else {
        throw new Error("Access key creation response missing AccessKey object");
      }
    } catch (error) {
      throw new Error(`Failed to create access keys for IAM User ${userName}: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  deleteAccessKeys() {
    if (!this.state.access_key_id) {
      return;
    }
    const userName = formatIAMResourceName(this.definition.user_name);
    try {
      this.makeAWSRequest("POST", IAM_ACTIONS.DELETE_ACCESS_KEY, {
        UserName: userName,
        AccessKeyId: this.state.access_key_id
      });
      this.removeCredentialsFromSecrets();
      cli.output(`Deleted access keys for IAM User ${userName}`);
      this.state.access_key_id = void 0;
      this.state.access_keys_created = void 0;
    } catch (error) {
      cli.output(`Failed to delete access keys for IAM User ${userName}: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  deleteAllAccessKeys() {
    const userName = formatIAMResourceName(this.definition.user_name);
    try {
      const response = this.makeAWSRequest("POST", IAM_ACTIONS.LIST_ACCESS_KEYS, {
        UserName: userName
      });
      let accessKeys = [];
      if (response && response.AccessKeys) {
        accessKeys = response.AccessKeys;
      } else if (response && response.AccessKeyMetadata) {
        accessKeys = response.AccessKeyMetadata;
      } else if (response && response.ListAccessKeysResult) {
        if (response.ListAccessKeysResult.AccessKeys) {
          accessKeys = response.ListAccessKeysResult.AccessKeys;
        } else if (response.ListAccessKeysResult.AccessKeyMetadata) {
          accessKeys = response.ListAccessKeysResult.AccessKeyMetadata;
        }
      }
      if (accessKeys.length > 0) {
        for (const keyData of accessKeys) {
          const accessKeyId = keyData.AccessKeyId;
          if (accessKeyId) {
            try {
              this.makeAWSRequest("POST", IAM_ACTIONS.DELETE_ACCESS_KEY, {
                UserName: userName,
                AccessKeyId: accessKeyId
              });
            } catch (keyError) {
              const keyErrorMsg = keyError instanceof Error ? keyError.message : "Unknown error";
              cli.output(`Warning: Failed to delete access key ${accessKeyId}: ${keyErrorMsg}`);
            }
          }
        }
      }
      if (this.state.access_key_id) {
        this.removeCredentialsFromSecrets();
      }
      this.state.access_key_id = void 0;
      this.state.access_keys_created = void 0;
    } catch (error) {
      if (this.state.access_key_id) {
        try {
          this.makeAWSRequest("POST", IAM_ACTIONS.DELETE_ACCESS_KEY, {
            UserName: userName,
            AccessKeyId: this.state.access_key_id
          });
          this.removeCredentialsFromSecrets();
        } catch (knownKeyError) {
          const knownKeyErrorMsg = knownKeyError instanceof Error ? knownKeyError.message : "Unknown error";
          throw new Error(`Failed to delete access keys: ${knownKeyErrorMsg}`);
        }
      }
      this.state.access_key_id = void 0;
      this.state.access_keys_created = void 0;
    }
  }
  storeCredentialsInSecrets(accessKeyId, secretAccessKey) {
    const accessKeyIdRef = this.getAccessKeyIdSecretRef();
    const secretAccessKeyRef = this.getSecretAccessKeySecretRef();
    try {
      secret.set(accessKeyIdRef, accessKeyId);
      secret.set(secretAccessKeyRef, secretAccessKey);
    } catch (error) {
      throw new Error(`Failed to store credentials in secrets: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  removeCredentialsFromSecrets() {
    const accessKeyIdRef = this.getAccessKeyIdSecretRef();
    const secretAccessKeyRef = this.getSecretAccessKeySecretRef();
    try {
      secret.set(accessKeyIdRef, "");
      secret.set(secretAccessKeyRef, "");
      cli.output(`Cleared secrets: ${accessKeyIdRef}, ${secretAccessKeyRef}`);
    } catch (error) {
      cli.output(`Note: Could not clear secrets (may not exist): ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  getAccessKeyIdSecretRef() {
    return this.definition.access_key_id_secret_ref || `${this.definition.user_name}-access-key-id`;
  }
  getSecretAccessKeySecretRef() {
    return this.definition.secret_access_key_secret_ref || `${this.definition.user_name}-secret-access-key`;
  }
  // Override makeAWSRequest to handle user-specific XML parsing
  makeAWSRequest(method, action2, body = {}) {
    const response = super.makeAWSRequest(method, action2, body);
    if (response.rawBody && typeof response.rawBody === "string") {
      return this.parseUserXMLResponse(response.rawBody);
    }
    return response;
  }
  parseUserXMLResponse(xmlBody) {
    if (xmlBody.indexOf("<CreateUserResponse") !== -1) {
      return this.parseCreateUserResponse(xmlBody);
    } else if (xmlBody.indexOf("<GetUserResponse") !== -1) {
      return this.parseGetUserResponse(xmlBody);
    } else if (xmlBody.indexOf("<CreateAccessKeyResponse") !== -1) {
      return this.parseCreateAccessKeyResponse(xmlBody);
    } else if (xmlBody.indexOf("<ListAccessKeysResponse") !== -1) {
      return this.parseListAccessKeysResponse(xmlBody);
    } else if (xmlBody.indexOf("<ListAttachedUserPoliciesResponse") !== -1) {
      return this.parseListAttachedUserPoliciesResponse(xmlBody);
    }
    return { rawBody: xmlBody };
  }
  parseCreateUserResponse(xmlBody) {
    let userMatch = xmlBody.match(/<User>(.*?)<\/User>/s);
    if (!userMatch) {
      const resultMatch = xmlBody.match(/<CreateUserResult>(.*?)<\/CreateUserResult>/s);
      if (resultMatch) {
        userMatch = resultMatch[1].match(/<User>(.*?)<\/User>/s);
      }
    }
    if (!userMatch) {
      return {};
    }
    const userContent = userMatch[1];
    return {
      User: {
        UserName: this.extractUserXMLValue(userContent, "UserName"),
        UserId: this.extractUserXMLValue(userContent, "UserId"),
        Arn: this.extractUserXMLValue(userContent, "Arn"),
        Path: this.extractUserXMLValue(userContent, "Path") || "/",
        CreateDate: this.extractUserXMLValue(userContent, "CreateDate"),
        PermissionsBoundary: this.extractUserXMLValue(userContent, "PermissionsBoundary")
      }
    };
  }
  parseGetUserResponse(xmlBody) {
    let userMatch = xmlBody.match(/<User>(.*?)<\/User>/s);
    if (!userMatch) {
      const resultMatch = xmlBody.match(/<GetUserResult>(.*?)<\/GetUserResult>/s);
      if (resultMatch) {
        userMatch = resultMatch[1].match(/<User>(.*?)<\/User>/s);
      }
    }
    if (!userMatch) {
      return {};
    }
    const userContent = userMatch[1];
    return {
      User: {
        UserName: this.extractUserXMLValue(userContent, "UserName"),
        UserId: this.extractUserXMLValue(userContent, "UserId"),
        Arn: this.extractUserXMLValue(userContent, "Arn"),
        Path: this.extractUserXMLValue(userContent, "Path") || "/",
        CreateDate: this.extractUserXMLValue(userContent, "CreateDate"),
        PermissionsBoundary: this.extractUserXMLValue(userContent, "PermissionsBoundary")
      }
    };
  }
  parseCreateAccessKeyResponse(xmlBody) {
    let accessKeyMatch = xmlBody.match(/<AccessKey>(.*?)<\/AccessKey>/s);
    if (!accessKeyMatch) {
      const resultMatch = xmlBody.match(/<CreateAccessKeyResult>(.*?)<\/CreateAccessKeyResult>/s);
      if (resultMatch) {
        accessKeyMatch = resultMatch[1].match(/<AccessKey>(.*?)<\/AccessKey>/s);
      }
    }
    if (!accessKeyMatch) {
      return {};
    }
    const accessKeyContent = accessKeyMatch[1];
    return {
      AccessKey: {
        UserName: this.extractUserXMLValue(accessKeyContent, "UserName"),
        AccessKeyId: this.extractUserXMLValue(accessKeyContent, "AccessKeyId"),
        SecretAccessKey: this.extractUserXMLValue(accessKeyContent, "SecretAccessKey"),
        Status: this.extractUserXMLValue(accessKeyContent, "Status") || "Active",
        CreateDate: this.extractUserXMLValue(accessKeyContent, "CreateDate")
      }
    };
  }
  parseListAccessKeysResponse(xmlBody) {
    const resultMatch = xmlBody.match(/<ListAccessKeysResult>(.*?)<\/ListAccessKeysResult>/s);
    if (!resultMatch) {
      return { AccessKeys: [] };
    }
    const accessKeys = [];
    const memberMatches = resultMatch[1].match(/<member>(.*?)<\/member>/gs);
    if (memberMatches) {
      for (const memberMatch of memberMatches) {
        const accessKey = {
          UserName: this.extractUserXMLValue(memberMatch, "UserName"),
          AccessKeyId: this.extractUserXMLValue(memberMatch, "AccessKeyId"),
          Status: this.extractUserXMLValue(memberMatch, "Status") || "Active",
          CreateDate: this.extractUserXMLValue(memberMatch, "CreateDate")
        };
        accessKeys.push(accessKey);
      }
    }
    return { AccessKeys: accessKeys };
  }
  parseListAttachedUserPoliciesResponse(xmlBody) {
    const resultMatch = xmlBody.match(/<ListAttachedUserPoliciesResult>(.*?)<\/ListAttachedUserPoliciesResult>/s);
    if (!resultMatch) {
      return { AttachedPolicies: [] };
    }
    const attachedPolicies = [];
    const memberMatches = resultMatch[1].match(/<member>(.*?)<\/member>/gs);
    if (memberMatches) {
      for (const memberMatch of memberMatches) {
        const policy = {
          PolicyName: this.extractUserXMLValue(memberMatch, "PolicyName"),
          PolicyArn: this.extractUserXMLValue(memberMatch, "PolicyArn")
        };
        attachedPolicies.push(policy);
      }
    }
    return { AttachedPolicies: attachedPolicies };
  }
  extractUserXMLValue(xmlContent, tagName) {
    const match = xmlContent.match(new RegExp(`<${tagName}>(.*?)</${tagName}>`, "s"));
    return match ? match[1].trim() : "";
  }
  getUserInfo() {
    const userName = formatIAMResourceName(this.definition.user_name);
    try {
      if (!this.state.user_arn) {
        cli.output(`IAM User ${userName} not found in entity state`);
        throw new Error(`IAM User ${userName} not found`);
      }
      const response = this.checkUserExists(userName);
      if (!response?.User) {
        cli.output(`IAM User ${userName} not found in AWS`);
        throw new Error(`IAM User ${userName} not found`);
      }
      const user = response.User;
      cli.output("=== IAM User Information ===");
      cli.output(`User Name: ${user.UserName}`);
      cli.output(`User ID: ${user.UserId}`);
      cli.output(`ARN: ${user.Arn}`);
      cli.output(`Path: ${user.Path}`);
      cli.output(`Create Date: ${user.CreateDate}`);
      const permissionsBoundary = user.PermissionsBoundary;
      if (permissionsBoundary) {
        cli.output(`Permissions Boundary: ${permissionsBoundary.PermissionsBoundaryArn}`);
      }
      if (this.state.access_key_id) {
        cli.output(`Access Key ID: ${this.state.access_key_id}`);
        cli.output(`Access Key Secret Reference: ${this.getAccessKeyIdSecretRef()}`);
        cli.output(`Secret Access Key Reference: ${this.getSecretAccessKeySecretRef()}`);
      } else {
        cli.output("No access keys created");
      }
      if (this.state.attached_policies && this.state.attached_policies.length > 0) {
        cli.output("\nAttached Policies:");
        for (const policyArn of this.state.attached_policies) {
          cli.output(`  - ${policyArn}`);
        }
      }
    } catch (error) {
      const errorMsg = `Failed to get user information: ${error instanceof Error ? error.message : "Unknown error"}`;
      cli.output(errorMsg);
      throw new Error(errorMsg);
    }
  }
  listAccessKeys() {
    const userName = formatIAMResourceName(this.definition.user_name);
    try {
      const response = this.makeAWSRequest("POST", IAM_ACTIONS.LIST_ACCESS_KEYS, {
        UserName: userName
      });
      cli.output("=== Access Keys ===");
      if (response?.AccessKeyMetadata && response.AccessKeyMetadata.length > 0) {
        for (const keyMetadata of response.AccessKeyMetadata) {
          cli.output(`Access Key ID: ${keyMetadata.AccessKeyId}`);
          cli.output(`Status: ${keyMetadata.Status}`);
          cli.output(`Create Date: ${keyMetadata.CreateDate}`);
          cli.output("---");
        }
      } else {
        cli.output("No access keys found");
      }
    } catch (error) {
      const errorMsg = `Failed to list access keys: ${error instanceof Error ? error.message : "Unknown error"}`;
      cli.output(errorMsg);
      throw new Error(errorMsg);
    }
  }
  getCredentials() {
    const userName = formatIAMResourceName(this.definition.user_name);
    try {
      if (!this.state.access_key_id) {
        cli.output(`No access keys created for user ${userName}`);
        return;
      }
      cli.output("=== AWS Credentials ===");
      cli.output(`Access Key ID Secret: ${this.getAccessKeyIdSecretRef()}`);
      cli.output(`Secret Access Key Secret: ${this.getSecretAccessKeySecretRef()}`);
      cli.output("\nTo use these credentials:");
      cli.output(`export AWS_ACCESS_KEY_ID=$(monk get secret ${this.getAccessKeyIdSecretRef()})`);
      cli.output(`export AWS_SECRET_ACCESS_KEY=$(monk get secret ${this.getSecretAccessKeySecretRef()})`);
      cli.output(`export AWS_REGION=${this.region}`);
    } catch (error) {
      const errorMsg = `Failed to get credentials: ${error instanceof Error ? error.message : "Unknown error"}`;
      cli.output(errorMsg);
      throw new Error(errorMsg);
    }
  }
  createAccessKeysAction() {
    try {
      if (this.state.access_key_id && this.state.access_keys_created) {
        cli.output("Access keys already exist for this user");
        return;
      }
      const originalValue = this.definition.create_access_keys;
      this.definition.create_access_keys = true;
      this.createAccessKeysIfRequested();
      this.definition.create_access_keys = originalValue;
    } catch (error) {
      const errorMsg = `Failed to create access keys: ${error instanceof Error ? error.message : "Unknown error"}`;
      cli.output(errorMsg);
      throw new Error(errorMsg);
    }
  }
  regenerateAccessKeys() {
    const userName = formatIAMResourceName(this.definition.user_name);
    try {
      if (this.state.access_key_id) {
        this.deleteAccessKeys();
        cli.output("Deleted existing access keys");
      }
      const originalValue = this.definition.create_access_keys;
      this.definition.create_access_keys = true;
      this.createAccessKeysIfRequested();
      this.definition.create_access_keys = originalValue;
      cli.output(`Successfully regenerated access keys for user ${userName}`);
    } catch (error) {
      const errorMsg = `Failed to regenerate access keys: ${error instanceof Error ? error.message : "Unknown error"}`;
      cli.output(errorMsg);
      throw new Error(errorMsg);
    }
  }
};
_init = __decoratorStart(_a);
__decorateElement(_init, 1, "getUserInfo", _getUserInfo_dec, _IAMUser);
__decorateElement(_init, 1, "listAccessKeys", _listAccessKeys_dec, _IAMUser);
__decorateElement(_init, 1, "getCredentials", _getCredentials_dec, _IAMUser);
__decorateElement(_init, 1, "createAccessKeysAction", _createAccessKeysAction_dec, _IAMUser);
__decorateElement(_init, 1, "regenerateAccessKeys", _regenerateAccessKeys_dec, _IAMUser);
__decoratorMetadata(_init, _IAMUser);
__name(_IAMUser, "IAMUser");
// Customize readiness check parameters
__publicField(_IAMUser, "readiness", { period: 5, initialDelay: 5, attempts: 12 });
var IAMUser = _IAMUser;



function main(def, state, ctx) {
  const entity = new IAMUser(def, state, ctx);
  return entity.main(ctx);
}
