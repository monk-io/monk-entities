// Generated by MonkEC - targeting Goja runtime
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __knownSymbol = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __decoratorStart = (base) => [, , , __create(base?.[__knownSymbol("metadata")] ?? null)];
var __decoratorStrings = ["class", "method", "getter", "setter", "accessor", "field", "value", "get", "set"];
var __expectFn = (fn) => fn !== void 0 && typeof fn !== "function" ? __typeError("Function expected") : fn;
var __decoratorContext = (kind, name, done, metadata, fns) => ({ kind: __decoratorStrings[kind], name, metadata, addInitializer: (fn) => done._ ? __typeError("Already initialized") : fns.push(__expectFn(fn || null)) });
var __decoratorMetadata = (array, target) => __defNormalProp(target, __knownSymbol("metadata"), array[3]);
var __runInitializers = (array, flags, self, value) => {
  for (var i = 0, fns = array[flags >> 1], n = fns && fns.length; i < n; i++) flags & 1 ? fns[i].call(self) : value = fns[i].call(self, value);
  return value;
};
var __decorateElement = (array, flags, name, decorators, target, extra) => {
  var fn, it, done, ctx, access, k = flags & 7, s = !!(flags & 8), p = !!(flags & 16);
  var j = k > 3 ? array.length + 1 : k ? s ? 1 : 2 : 0, key = __decoratorStrings[k + 5];
  var initializers = k > 3 && (array[j - 1] = []), extraInitializers = array[j] || (array[j] = []);
  var desc = k && (!p && !s && (target = target.prototype), k < 5 && (k > 3 || !p) && __getOwnPropDesc(k < 4 ? target : { get [name]() {
    return __privateGet(this, extra);
  }, set [name](x) {
    return __privateSet(this, extra, x);
  } }, name));
  k ? p && k < 4 && __name(extra, (k > 2 ? "set " : k > 1 ? "get " : "") + name) : __name(target, name);
  for (var i = decorators.length - 1; i >= 0; i--) {
    ctx = __decoratorContext(k, name, done = {}, array[3], extraInitializers);
    if (k) {
      ctx.static = s, ctx.private = p, access = ctx.access = { has: p ? (x) => __privateIn(target, x) : (x) => name in x };
      if (k ^ 3) access.get = p ? (x) => (k ^ 1 ? __privateGet : __privateMethod)(x, target, k ^ 4 ? extra : desc.get) : (x) => x[name];
      if (k > 2) access.set = p ? (x, y) => __privateSet(x, target, y, k ^ 4 ? extra : desc.set) : (x, y) => x[name] = y;
    }
    it = (0, decorators[i])(k ? k < 4 ? p ? extra : desc[key] : k > 4 ? void 0 : { get: desc.get, set: desc.set } : target, ctx), done._ = 1;
    if (k ^ 4 || it === void 0) __expectFn(it) && (k > 4 ? initializers.unshift(it) : k ? p ? extra = it : desc[key] = it : target = it);
    else if (typeof it !== "object" || it === null) __typeError("Object expected");
    else __expectFn(fn = it.get) && (desc.get = fn), __expectFn(fn = it.set) && (desc.set = fn), __expectFn(fn = it.init) && initializers.unshift(fn);
  }
  return k || __decoratorMetadata(array, target), desc && __defProp(target, name, desc), p ? k ^ 4 ? extra : desc : target;
};
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateIn = (member, obj) => Object(obj) !== obj ? __typeError('Cannot use the "in" operator on this value') : member.has(obj);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);

// input/redis-cloud/proDatabase.ts
var pro_database_exports = {};
__export(pro_database_exports, {
  ProDatabase: () => ProDatabase
});
module.exports = __toCommonJS(pro_database_exports);
var import_cli2 = __toESM(require("cli"));
var import_secret2 = __toESM(require("secret"));
var import_base2 = require("monkec/base");

// input/redis-cloud/base.ts
var base_exports = {};
__export(base_exports, {
  RedisCloudEntity: () => RedisCloudEntity
});
var import_base = require("monkec/base");
var import_http_client = require("monkec/http-client");

// input/redis-cloud/common.ts
var BASE_URL = "https://api.redislabs.com/v1";
var CONTENT_TYPE = "application/json";
var DEFAULT_TASK_TIMEOUT = 600;
var DEFAULT_POLLING_INTERVAL = 5e3;

// input/redis-cloud/base.ts
var import_cli = __toESM(require("cli"));
var import_secret = __toESM(require("secret"));
var RedisCloudEntity = class extends import_base.MonkEntity {
  constructor() {
    super(...arguments);
    /**
     * HTTP client configured for Redis Cloud API
     */
    __publicField(this, "httpClient");
    /**
     * Authentication credentials
     */
    __publicField(this, "credentials");
  }
  /**
   * Initialize authentication and HTTP client before any operations
   */
  before() {
    this.credentials = this.getEntityCredentials();
    this.httpClient = new import_http_client.HttpClient({
      baseUrl: BASE_URL,
      headers: {
        "x-api-key": this.credentials.accessKey,
        "x-api-secret-key": this.credentials.secretKey,
        "content-type": CONTENT_TYPE
      },
      parseJson: true,
      stringifyJson: true
    });
  }
  /**
   * Get credentials using either new or legacy authentication method
   */
  getEntityCredentials() {
    if (this.definition.account_key_secret && this.definition.user_key_secret) {
      const accountKey = import_secret.default.get(this.definition.account_key_secret);
      const userKey = import_secret.default.get(this.definition.user_key_secret);
      if (!accountKey || !userKey) {
        throw new Error(`Redis Cloud credentials not found. Expected secrets: ${this.definition.account_key_secret} and ${this.definition.user_key_secret}`);
      }
      return { accessKey: accountKey, secretKey: userKey };
    }
    throw new Error("Redis Cloud authentication not configured. Provide 'account_key_secret' and 'user_key_secret'");
  }
  /**
   * Standard start implementation for Redis Cloud entities
   */
  start() {
    import_cli.default.output(`Starting Redis Cloud operations for: ${this.getEntityName()}`);
  }
  /**
   * Standard stop implementation for Redis Cloud entities
   */
  stop() {
    import_cli.default.output(`Stopping Redis Cloud operations for: ${this.getEntityName()}`);
  }
  /**
   * Helper method to make authenticated HTTP requests with consistent error handling
   */
  makeRequest(method, path, body) {
    try {
      const response = this.httpClient.request(method, path, {
        body,
        headers: {
          "x-api-key": this.credentials.accessKey,
          "x-api-secret-key": this.credentials.secretKey,
          "content-type": CONTENT_TYPE
        }
      });
      if (!response.ok) {
        const errorBody = typeof response.data === "string" ? response.data : JSON.stringify(response.data);
        throw new Error(`Redis Cloud API error: ${response.statusCode} ${response.status}. Body: ${errorBody || response.raw}`);
      }
      let responseData = response.data;
      if (typeof responseData === "string") {
        try {
          responseData = JSON.parse(responseData);
        } catch (e) {
        }
      }
      return responseData;
    } catch (error) {
      if (error instanceof Error) {
        throw new Error(`Redis Cloud ${method} request to ${path} failed: ${error.message}`);
      }
      throw error;
    }
  }
  /**
   * Helper method to check if a resource exists by making a GET request
   * Returns the resource data if it exists, null otherwise
   */
  checkResourceExists(path) {
    try {
      return this.makeRequest("GET", path);
    } catch (error) {
      return null;
    }
  }
  /**
   * Helper method to handle resource deletion with proper existing resource checks
   */
  deleteResource(path, resourceName) {
    if (this.state.existing) {
      import_cli.default.output(`${resourceName} wasn't created by this entity, skipping delete`);
      return;
    }
    try {
      this.makeRequest("DELETE", path);
      import_cli.default.output(`Successfully deleted ${resourceName}`);
    } catch (error) {
      throw new Error(`Failed to delete ${resourceName}: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  /**
   * Wait for task completion with timeout
   */
  waitForTask(taskId, timeoutSeconds = DEFAULT_TASK_TIMEOUT) {
    if (!taskId) {
      return null;
    }
    const startTime = Date.now();
    const timeout = timeoutSeconds * 1e3;
    while (Date.now() - startTime < timeout) {
      try {
        const taskData = this.makeRequest("GET", `/tasks/${taskId}`);
        if (taskData && taskData.status) {
          if (taskData.status === "processing-completed") {
            import_cli.default.output(`\u2705 Task ${taskId} completed successfully`);
            return taskData;
          }
          if (taskData.status === "processing-error") {
            throw new Error(`Task processing error: ${JSON.stringify(taskData)}`);
          }
          import_cli.default.output(`\u23F3 Task ${taskId} status: ${taskData.status}`);
        }
      } catch (error) {
        if (error instanceof Error && error.message.includes("Task processing error:")) {
          throw error;
        }
        import_cli.default.output(`\u26A0\uFE0F Error checking task status: ${error}`);
      }
      const currentTime = Date.now();
      const elapsed = currentTime - startTime;
      if (elapsed + DEFAULT_POLLING_INTERVAL < timeout) {
        const endTime = currentTime + DEFAULT_POLLING_INTERVAL;
        while (Date.now() < endTime) {
        }
      } else {
        break;
      }
    }
    throw new Error(`Task ${taskId} timed out after ${timeoutSeconds} seconds`);
  }
};

// input/redis-cloud/proDatabase.ts
var { RedisCloudEntity: RedisCloudEntity2 } = base_exports;
var _backup_dec, _a, _init;
var ProDatabase = class extends (_a = RedisCloudEntity2, _backup_dec = [(0, import_base2.action)("backup")], _a) {
  constructor() {
    super(...arguments);
    __runInitializers(_init, 5, this);
  }
  getEntityName() {
    return `Pro Database: ${this.definition.name}`;
  }
  /** Create a new Redis Cloud Pro database */
  create() {
    const existingDatabase = this.findExistingDatabase();
    if (existingDatabase) {
      this.state.existing = true;
      this.state.id = existingDatabase.databaseId;
      this.state.name = existingDatabase.name;
      this.state.status = existingDatabase.status;
      this.state.public_endpoint = existingDatabase.publicEndpoint;
      this.state.private_endpoint = existingDatabase.privateEndpoint;
      this.state.port = existingDatabase.port;
      this.state.memory_limit_in_mb = existingDatabase.memoryLimitInMb;
      import_cli2.default.output(`\u2705 Using existing Pro database: ${existingDatabase.name} (${existingDatabase.databaseId})`);
      return;
    }
    const password = this.getOrCreatePassword();
    const body = {
      name: this.definition.name,
      protocol: this.definition.protocol || "redis",
      dryRun: this.definition.dry_run || false
    };
    if (this.definition.dataset_size_in_gb !== void 0) {
      body.datasetSizeInGb = this.definition.dataset_size_in_gb;
    }
    if (this.definition.port !== void 0) {
      body.port = this.definition.port;
    }
    if (this.definition.redis_version !== void 0) {
      body.redisVersion = this.definition.redis_version;
    }
    if (this.definition.resp_version !== void 0) {
      body.respVersion = this.definition.resp_version;
    }
    body.supportOSSClusterApi = this.definition.support_oss_cluster_api || false;
    body.useExternalEndpointForOSSClusterApi = this.definition.use_external_endpoint_for_oss_cluster_api || false;
    body.dataPersistence = this.mapDataPersistence();
    body.dataEvictionPolicy = this.definition.data_eviction_policy || "volatile-lru";
    body.replication = this.definition.replication ?? true;
    body.password = password;
    body.sourceIp = this.definition.source_ip || [];
    if (this.definition.modules && this.definition.modules.length > 0) {
      body.modules = [...this.definition.modules];
    }
    if (this.definition.alerts && this.definition.alerts.length > 0) {
      body.alerts = [...this.definition.alerts];
    }
    if (this.definition.replica) {
      body.replica = {
        syncSources: this.definition.replica.sync_sources.map((source) => ({
          endpoint: source.endpoint,
          encryption: source.encryption,
          serverCert: source.server_cert
        }))
      };
    }
    if (this.definition.throughput_measurement) {
      body.throughputMeasurement = {
        by: this.definition.throughput_measurement.by,
        value: this.definition.throughput_measurement.value
      };
    }
    if (this.definition.local_throughput_measurement) {
      body.localThroughputMeasurement = this.definition.local_throughput_measurement.map((ltp) => ({
        region: ltp.region,
        writeOperationsPerSecond: ltp.write_operations_per_second || 1e3,
        readOperationsPerSecond: ltp.read_operations_per_second || 1e3
      }));
    }
    if (this.definition.average_item_size_in_bytes !== void 0) {
      body.averageItemSizeInBytes = this.definition.average_item_size_in_bytes;
    }
    if (this.definition.remote_backup) {
      body.remoteBackup = {
        active: this.definition.remote_backup.active,
        interval: this.definition.remote_backup.interval,
        timeUTC: this.definition.remote_backup.time_utc,
        storageType: this.definition.remote_backup.storage_type,
        storagePath: this.definition.remote_backup.storage_path
      };
    }
    if (this.definition.client_tls_certificates) {
      body.clientTlsCertificates = this.definition.client_tls_certificates.map((cert) => ({
        publicCertificatePEMString: cert.public_certificate_pem_string
      }));
    }
    if (this.definition.enable_tls !== void 0) {
      body.enableTls = this.definition.enable_tls;
    }
    if (this.definition.protocol === "memcached") {
      if (this.definition.sasl_username !== void 0) {
        body.saslUsername = this.definition.sasl_username;
      }
      if (this.definition.sasl_password !== void 0) {
        body.saslPassword = this.definition.sasl_password;
      }
    }
    if (this.definition.sharding_type !== void 0) {
      body.shardingType = this.definition.sharding_type;
    }
    if (this.definition.query_performance_factor !== void 0) {
      body.queryPerformanceFactor = this.definition.query_performance_factor;
    }
    const response = this.makeRequest("POST", `/subscriptions/${this.definition.subscription_id}/databases`, body);
    this.state.task_id = response.taskId;
    this.state.name = this.definition.name;
    this.state.memory_limit_in_mb = (this.definition.dataset_size_in_gb || 1) * 1024;
    import_cli2.default.output(`\u2705 Pro database creation initiated: ${this.state.name}`);
    import_cli2.default.output(`\u{1F4CB} Task ID: ${this.state.task_id}`);
    if (!this.state.task_id) {
      throw new Error("No task ID returned from database creation request");
    }
    const taskResult = this.waitForTask(this.state.task_id);
    if (taskResult && taskResult.response && taskResult.response.resourceId) {
      this.state.id = taskResult.response.resourceId;
      import_cli2.default.output(`\u2705 Database created with ID: ${this.state.id}`);
      const databaseData = this.makeRequest("GET", `/subscriptions/${this.definition.subscription_id}/databases/${this.state.id}`);
      if (databaseData) {
        this.state.status = databaseData.status;
        this.state.public_endpoint = databaseData.publicEndpoint;
        this.state.private_endpoint = databaseData.privateEndpoint;
        this.state.port = databaseData.port;
        this.state.memory_usage_in_mb = databaseData.memoryUsageInMb;
        if (this.definition.support_oss_cluster_api && databaseData.clustering) {
          this.state.cluster_info = {
            shard_count: databaseData.clustering.numberOfShards,
            status: databaseData.clustering.status
          };
        }
        import_cli2.default.output(`\u2705 Pro database ready: ${this.state.name} (${databaseData.status})`);
      }
    } else {
      throw new Error("Task completed but no resource ID was returned");
    }
  }
  mapDataPersistence() {
    return this.definition.data_persistence || "none";
  }
  findExistingDatabase() {
    try {
      const response = this.makeRequest("GET", `/subscriptions/${this.definition.subscription_id}/databases`);
      return response.databases?.find((db) => db.name === this.definition.name);
    } catch (error) {
      import_cli2.default.output(`\u26A0\uFE0F Could not check for existing databases: ${error}`);
      return null;
    }
  }
  getOrCreatePassword() {
    if (!this.definition.password_secret_ref) {
      throw new Error("Password secret reference not defined");
    }
    try {
      const storedPassword = import_secret2.default.get(this.definition.password_secret_ref);
      if (!storedPassword) {
        throw new Error("Password not found");
      }
      return storedPassword;
    } catch (e) {
      const password = import_secret2.default.randString(16);
      import_secret2.default.set(this.definition.password_secret_ref, password);
      return password;
    }
  }
  start() {
    super.start();
  }
  update() {
    if (!this.state.id) {
      this.create();
      return;
    }
    const databaseData = this.checkResourceExists(`/subscriptions/${this.definition.subscription_id}/databases/${this.state.id}`);
    if (databaseData) {
      this.state.status = databaseData.status;
      this.state.public_endpoint = databaseData.publicEndpoint;
      this.state.private_endpoint = databaseData.privateEndpoint;
      this.state.port = databaseData.port;
      this.state.memory_usage_in_mb = databaseData.memoryUsageInMb;
      if (databaseData.clustering) {
        this.state.cluster_info = {
          shard_count: databaseData.clustering.numberOfShards,
          status: databaseData.clustering.status
        };
      }
      if (databaseData.modules) {
        this.state.enabled_modules = databaseData.modules.map((m) => m.name);
      }
      if (this.definition.alerts && this.definition.alerts.length > 0) {
        this.updateAdvancedAlerts();
      }
    }
  }
  updateAdvancedAlerts() {
    if (!this.state.id) return;
    const alerts = this.definition.alerts || [];
    if (alerts.length > 0) {
      try {
        this.makeRequest("PUT", `/subscriptions/${this.definition.subscription_id}/databases/${this.state.id}/alerts`, { alerts });
        import_cli2.default.output(`\u2705 Updated alerts for Pro database ${this.state.name}`);
      } catch (error) {
        import_cli2.default.output(`\u26A0\uFE0F Failed to update alerts: ${error}`);
      }
    }
  }
  delete() {
    if (!this.state.id) {
      import_cli2.default.output("Pro database does not exist, nothing to delete");
      return;
    }
    this.deleteResource(`/subscriptions/${this.definition.subscription_id}/databases/${this.state.id}`, `Pro Database ${this.state.name}`);
  }
  checkReadiness() {
    if (!this.state.id) {
      return false;
    }
    const databaseData = this.checkResourceExists(`/subscriptions/${this.definition.subscription_id}/databases/${this.state.id}`);
    if (!databaseData) {
      return false;
    }
    if (databaseData.status === "active") {
      this.state.status = "active";
      this.state.public_endpoint = databaseData.publicEndpoint;
      this.state.private_endpoint = databaseData.privateEndpoint;
      this.state.port = databaseData.port;
      this.state.memory_usage_in_mb = databaseData.memoryUsageInMb;
      if (databaseData.clustering) {
        this.state.cluster_info = {
          shard_count: databaseData.clustering.numberOfShards,
          status: databaseData.clustering.status
        };
      }
      if (databaseData.modules) {
        this.state.enabled_modules = databaseData.modules.map((m) => m.name);
      }
      return true;
    }
    this.state.status = databaseData.status;
    return false;
  }
  checkLiveness() {
    return this.checkReadiness();
  }
  backup(args) {
    import_cli2.default.output(`Initiating backup for Pro database: ${this.state.name}`);
    if (!this.state.id) {
      throw new Error("Database ID is not available. Cannot initiate backup.");
    }
    if (!this.definition.remote_backup?.storage_path && !args?.adhocBackupPath) {
      throw new Error("remote_backup.storage_path is not configured for this database, and no adhocBackupPath was provided. Cannot initiate backup.");
    }
    const body = {};
    if (args?.regionName) {
      body.regionName = args.regionName;
    }
    if (args?.adhocBackupPath) {
      body.adhocBackupPath = args.adhocBackupPath;
    }
    try {
      const response = this.makeRequest(
        "POST",
        `/subscriptions/${this.definition.subscription_id}/databases/${this.state.id}/backup`,
        Object.keys(body).length > 0 ? body : void 0
      );
      if (response && response.taskId) {
        import_cli2.default.output(`\u2705 Backup initiated. Task ID: ${response.taskId}`);
        this.waitForTask(response.taskId);
        import_cli2.default.output(`\u2705 Backup task ${response.taskId} completed successfully.`);
      } else {
        import_cli2.default.output(`\u26A0\uFE0F  Backup request sent but no task ID returned. Response: ${JSON.stringify(response)}`);
      }
    } catch (error) {
      throw new Error(`Failed to initiate backup for Pro database ${this.state.name}: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
};
_init = __decoratorStart(_a);
__decorateElement(_init, 1, "backup", _backup_dec, ProDatabase);
__decoratorMetadata(_init, ProDatabase);
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  ProDatabase
});
