
// Generated by MonkEC - targeting Goja runtime
var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });

// input/redis-cloud/proDatabase.ts
const base = require("redis-cloud/base");
const RedisCloudEntity = base.RedisCloudEntity;
const cli = require("cli");
var _ProDatabase = class _ProDatabase extends RedisCloudEntity {
  getEntityName() {
    return `Pro Database: ${this.definition.name}`;
  }
  /** Create a new Redis Cloud Pro database */
  create() {
    const existingDatabase = this.findExistingDatabase();
    if (existingDatabase) {
      this.state.existing = true;
      this.state.id = existingDatabase.databaseId;
      this.state.name = existingDatabase.name;
      this.state.status = existingDatabase.status;
      this.state.public_endpoint = existingDatabase.publicEndpoint;
      this.state.private_endpoint = existingDatabase.privateEndpoint;
      this.state.port = existingDatabase.port;
      this.state.memory_limit_in_mb = existingDatabase.memoryLimitInMb;
      cli.output(`\u2705 Using existing Pro database: ${existingDatabase.name} (${existingDatabase.databaseId})`);
      return;
    }
    const password = this.getOrGeneratePassword();
    const body = {
      name: this.definition.name,
      protocol: this.definition.protocol || "redis",
      dryRun: this.definition.dry_run || false
    };
    if (this.definition.dataset_size_in_gb !== void 0) {
      body.datasetSizeInGb = this.definition.dataset_size_in_gb;
    }
    if (this.definition.port !== void 0) {
      body.port = this.definition.port;
    }
    if (this.definition.redis_version !== void 0) {
      body.redisVersion = this.definition.redis_version;
    }
    if (this.definition.resp_version !== void 0) {
      body.respVersion = this.definition.resp_version;
    }
    body.supportOSSClusterApi = this.definition.support_oss_cluster_api || false;
    body.useExternalEndpointForOSSClusterApi = this.definition.use_external_endpoint_for_oss_cluster_api || false;
    body.dataPersistence = this.mapDataPersistence();
    body.dataEvictionPolicy = this.definition.data_eviction_policy || "volatile-lru";
    body.replication = this.definition.replication ?? true;
    body.password = password;
    body.sourceIp = this.definition.source_ip || [];
    if (this.definition.modules && this.definition.modules.length > 0) {
      body.modules = [...this.definition.modules];
    }
    if (this.definition.alerts && this.definition.alerts.length > 0) {
      body.alerts = [...this.definition.alerts];
    }
    if (this.definition.replica) {
      body.replica = {
        syncSources: this.definition.replica.sync_sources.map((source) => ({
          endpoint: source.endpoint,
          encryption: source.encryption,
          serverCert: source.server_cert
        }))
      };
    }
    if (this.definition.throughput_measurement) {
      body.throughputMeasurement = {
        by: this.definition.throughput_measurement.by,
        value: this.definition.throughput_measurement.value
      };
    }
    if (this.definition.local_throughput_measurement) {
      body.localThroughputMeasurement = this.definition.local_throughput_measurement.map((ltp) => ({
        region: ltp.region,
        writeOperationsPerSecond: ltp.write_operations_per_second || 1e3,
        readOperationsPerSecond: ltp.read_operations_per_second || 1e3
      }));
    }
    if (this.definition.average_item_size_in_bytes !== void 0) {
      body.averageItemSizeInBytes = this.definition.average_item_size_in_bytes;
    }
    if (this.definition.remote_backup) {
      body.remoteBackup = {
        active: this.definition.remote_backup.active,
        interval: this.definition.remote_backup.interval,
        timeUTC: this.definition.remote_backup.time_utc,
        storageType: this.definition.remote_backup.storage_type,
        storagePath: this.definition.remote_backup.storage_path
      };
    }
    if (this.definition.client_tls_certificates) {
      body.clientTlsCertificates = this.definition.client_tls_certificates.map((cert) => ({
        publicCertificatePEMString: cert.public_certificate_pem_string
      }));
    }
    if (this.definition.enable_tls !== void 0) {
      body.enableTls = this.definition.enable_tls;
    }
    if (this.definition.protocol === "memcached") {
      if (this.definition.sasl_username !== void 0) {
        body.saslUsername = this.definition.sasl_username;
      }
      if (this.definition.sasl_password !== void 0) {
        body.saslPassword = this.definition.sasl_password;
      }
    }
    if (this.definition.sharding_type !== void 0) {
      body.shardingType = this.definition.sharding_type;
    }
    if (this.definition.query_performance_factor !== void 0) {
      body.queryPerformanceFactor = this.definition.query_performance_factor;
    }
    const response = this.makeRequest("POST", `/subscriptions/${this.definition.subscription_id}/databases`, body);
    this.state.task_id = response.taskId;
    this.state.name = this.definition.name;
    this.state.password = password;
    this.state.memory_limit_in_mb = (this.definition.dataset_size_in_gb || 1) * 1024;
    cli.output(`\u2705 Pro database creation initiated: ${this.state.name}`);
    cli.output(`\u{1F4CB} Task ID: ${this.state.task_id}`);
    if (!this.state.task_id) {
      throw new Error("No task ID returned from database creation request");
    }
    const taskResult = this.waitForTask(this.state.task_id);
    if (taskResult && taskResult.response && taskResult.response.resourceId) {
      this.state.id = taskResult.response.resourceId;
      cli.output(`\u2705 Database created with ID: ${this.state.id}`);
      const databaseData = this.makeRequest("GET", `/subscriptions/${this.definition.subscription_id}/databases/${this.state.id}`);
      if (databaseData) {
        this.state.status = databaseData.status;
        this.state.public_endpoint = databaseData.publicEndpoint;
        this.state.private_endpoint = databaseData.privateEndpoint;
        this.state.port = databaseData.port;
        this.state.memory_usage_in_mb = databaseData.memoryUsageInMb;
        if (this.definition.support_oss_cluster_api && databaseData.clustering) {
          this.state.cluster_info = {
            shard_count: databaseData.clustering.numberOfShards,
            status: databaseData.clustering.status
          };
        }
        cli.output(`\u2705 Pro database ready: ${this.state.name} (${databaseData.status})`);
      }
    } else {
      throw new Error("Task completed but no resource ID was returned");
    }
  }
  mapDataPersistence() {
    return this.definition.data_persistence || "none";
  }
  findExistingDatabase() {
    try {
      const response = this.makeRequest("GET", `/subscriptions/${this.definition.subscription_id}/databases`);
      return response.databases?.find((db) => db.name === this.definition.name);
    } catch (error) {
      cli.output(`\u26A0\uFE0F Could not check for existing databases: ${error}`);
      return null;
    }
  }
  getOrGeneratePassword() {
    if (this.definition.password) {
      return this.definition.password;
    }
    const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*";
    let password = "";
    for (let i = 0; i < 16; i++) {
      password += chars.charAt(Math.floor(Math.random() * chars.length));
    }
    return password;
  }
  start() {
    super.start();
  }
  update() {
    if (!this.state.id) {
      this.create();
      return;
    }
    const databaseData = this.checkResourceExists(`/subscriptions/${this.definition.subscription_id}/databases/${this.state.id}`);
    if (databaseData) {
      this.state.status = databaseData.status;
      this.state.public_endpoint = databaseData.publicEndpoint;
      this.state.private_endpoint = databaseData.privateEndpoint;
      this.state.port = databaseData.port;
      this.state.memory_usage_in_mb = databaseData.memoryUsageInMb;
      if (databaseData.clustering) {
        this.state.cluster_info = {
          shard_count: databaseData.clustering.numberOfShards,
          status: databaseData.clustering.status
        };
      }
      if (databaseData.modules) {
        this.state.enabled_modules = databaseData.modules.map((m) => m.name);
      }
      if (this.definition.alerts && this.definition.alerts.length > 0) {
        this.updateAdvancedAlerts();
      }
    }
  }
  updateAdvancedAlerts() {
    if (!this.state.id) return;
    const alerts = this.definition.alerts || [];
    if (alerts.length > 0) {
      try {
        this.makeRequest("PUT", `/subscriptions/${this.definition.subscription_id}/databases/${this.state.id}/alerts`, { alerts });
        cli.output(`\u2705 Updated alerts for Pro database ${this.state.name}`);
      } catch (error) {
        cli.output(`\u26A0\uFE0F Failed to update alerts: ${error}`);
      }
    }
  }
  delete() {
    if (!this.state.id) {
      cli.output("Pro database does not exist, nothing to delete");
      return;
    }
    this.deleteResource(`/subscriptions/${this.definition.subscription_id}/databases/${this.state.id}`, `Pro Database ${this.state.name}`);
  }
  checkReadiness() {
    if (!this.state.id) {
      return false;
    }
    const databaseData = this.checkResourceExists(`/subscriptions/${this.definition.subscription_id}/databases/${this.state.id}`);
    if (!databaseData) {
      return false;
    }
    if (databaseData.status === "active") {
      this.state.status = "active";
      this.state.public_endpoint = databaseData.publicEndpoint;
      this.state.private_endpoint = databaseData.privateEndpoint;
      this.state.port = databaseData.port;
      this.state.memory_usage_in_mb = databaseData.memoryUsageInMb;
      if (databaseData.clustering) {
        this.state.cluster_info = {
          shard_count: databaseData.clustering.numberOfShards,
          status: databaseData.clustering.status
        };
      }
      if (databaseData.modules) {
        this.state.enabled_modules = databaseData.modules.map((m) => m.name);
      }
      return true;
    }
    this.state.status = databaseData.status;
    return false;
  }
};
__name(_ProDatabase, "ProDatabase");
var ProDatabase = _ProDatabase;



function main(def, state, ctx) {
  const entity = new ProDatabase(def, state, ctx);
  return entity.main(ctx);
}
