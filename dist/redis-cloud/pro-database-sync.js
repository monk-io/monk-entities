
// Generated by MonkEC - targeting Goja runtime
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __knownSymbol = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __decoratorStart = (base) => [, , , __create(base?.[__knownSymbol("metadata")] ?? null)];
var __decoratorStrings = ["class", "method", "getter", "setter", "accessor", "field", "value", "get", "set"];
var __expectFn = (fn) => fn !== void 0 && typeof fn !== "function" ? __typeError("Function expected") : fn;
var __decoratorContext = (kind, name, done, metadata, fns) => ({ kind: __decoratorStrings[kind], name, metadata, addInitializer: (fn) => done._ ? __typeError("Already initialized") : fns.push(__expectFn(fn || null)) });
var __decoratorMetadata = (array, target) => __defNormalProp(target, __knownSymbol("metadata"), array[3]);
var __runInitializers = (array, flags, self, value) => {
  for (var i = 0, fns = array[flags >> 1], n = fns && fns.length; i < n; i++) flags & 1 ? fns[i].call(self) : value = fns[i].call(self, value);
  return value;
};
var __decorateElement = (array, flags, name, decorators, target, extra) => {
  var fn, it, done, ctx, access, k = flags & 7, s = !!(flags & 8), p = !!(flags & 16);
  var j = k > 3 ? array.length + 1 : k ? s ? 1 : 2 : 0, key = __decoratorStrings[k + 5];
  var initializers = k > 3 && (array[j - 1] = []), extraInitializers = array[j] || (array[j] = []);
  var desc = k && (!p && !s && (target = target.prototype), k < 5 && (k > 3 || !p) && __getOwnPropDesc(k < 4 ? target : { get [name]() {
    return __privateGet(this, extra);
  }, set [name](x) {
    return __privateSet(this, extra, x);
  } }, name));
  k ? p && k < 4 && __name(extra, (k > 2 ? "set " : k > 1 ? "get " : "") + name) : __name(target, name);
  for (var i = decorators.length - 1; i >= 0; i--) {
    ctx = __decoratorContext(k, name, done = {}, array[3], extraInitializers);
    if (k) {
      ctx.static = s, ctx.private = p, access = ctx.access = { has: p ? (x) => __privateIn(target, x) : (x) => name in x };
      if (k ^ 3) access.get = p ? (x) => (k ^ 1 ? __privateGet : __privateMethod)(x, target, k ^ 4 ? extra : desc.get) : (x) => x[name];
      if (k > 2) access.set = p ? (x, y) => __privateSet(x, target, y, k ^ 4 ? extra : desc.set) : (x, y) => x[name] = y;
    }
    it = (0, decorators[i])(k ? k < 4 ? p ? extra : desc[key] : k > 4 ? void 0 : { get: desc.get, set: desc.set } : target, ctx), done._ = 1;
    if (k ^ 4 || it === void 0) __expectFn(it) && (k > 4 ? initializers.unshift(it) : k ? p ? extra = it : desc[key] = it : target = it);
    else if (typeof it !== "object" || it === null) __typeError("Object expected");
    else __expectFn(fn = it.get) && (desc.get = fn), __expectFn(fn = it.set) && (desc.set = fn), __expectFn(fn = it.init) && initializers.unshift(fn);
  }
  return k || __decoratorMetadata(array, target), desc && __defProp(target, name, desc), p ? k ^ 4 ? extra : desc : target;
};
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateIn = (member, obj) => Object(obj) !== obj ? __typeError('Cannot use the "in" operator on this value') : member.has(obj);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);

// input/redis-cloud/proDatabase.ts
const cli = require("cli");
const secret = require("secret");
const base = require("redis-cloud/base");
const RedisCloudEntity = base.RedisCloudEntity;
const MonkecBase = require("monkec/base");
var action2 = MonkecBase.action;
var _listSnapshots_dec, _restore_dec, _createSnapshot_dec, _getBackupInfo_dec, _a, _init;
var _ProDatabase = class _ProDatabase extends (_a = RedisCloudEntity, _getBackupInfo_dec = [action2("get-backup-info")], _createSnapshot_dec = [action2("create-snapshot")], _restore_dec = [action2("restore")], _listSnapshots_dec = [action2("list-snapshots")], _a) {
  constructor() {
    super(...arguments);
    __runInitializers(_init, 5, this);
  }
  getEntityName() {
    return `Pro Database: ${this.definition.name}`;
  }
  /** Create a new Redis Cloud Pro database */
  create() {
    const existingDatabase = this.findExistingDatabase();
    if (existingDatabase) {
      this.state.existing = true;
      this.state.id = existingDatabase.databaseId;
      this.state.name = existingDatabase.name;
      this.state.status = existingDatabase.status;
      this.state.public_endpoint = existingDatabase.publicEndpoint;
      this.state.private_endpoint = existingDatabase.privateEndpoint;
      this.state.port = existingDatabase.port;
      this.state.memory_limit_in_mb = existingDatabase.memoryLimitInMb;
      cli.output(`\u2705 Using existing Pro database: ${existingDatabase.name} (${existingDatabase.databaseId})`);
      return;
    }
    const password = this.getOrCreatePassword();
    const body = {
      name: this.definition.name,
      protocol: this.definition.protocol || "redis",
      dryRun: this.definition.dry_run || false
    };
    if (this.definition.dataset_size_in_gb !== void 0) {
      body.datasetSizeInGb = this.definition.dataset_size_in_gb;
    }
    if (this.definition.port !== void 0) {
      body.port = this.definition.port;
    }
    if (this.definition.redis_version !== void 0) {
      body.redisVersion = this.definition.redis_version;
    }
    if (this.definition.resp_version !== void 0) {
      body.respVersion = this.definition.resp_version;
    }
    body.supportOSSClusterApi = this.definition.support_oss_cluster_api || false;
    body.useExternalEndpointForOSSClusterApi = this.definition.use_external_endpoint_for_oss_cluster_api || false;
    body.dataPersistence = this.mapDataPersistence();
    body.dataEvictionPolicy = this.definition.data_eviction_policy || "volatile-lru";
    body.replication = this.definition.replication ?? true;
    body.password = password;
    body.sourceIp = this.definition.source_ip || [];
    if (this.definition.modules && this.definition.modules.length > 0) {
      body.modules = [...this.definition.modules];
    }
    if (this.definition.alerts && this.definition.alerts.length > 0) {
      body.alerts = [...this.definition.alerts];
    }
    if (this.definition.replica) {
      body.replica = {
        syncSources: this.definition.replica.sync_sources.map((source) => ({
          endpoint: source.endpoint,
          encryption: source.encryption,
          serverCert: source.server_cert
        }))
      };
    }
    if (this.definition.throughput_measurement) {
      body.throughputMeasurement = {
        by: this.definition.throughput_measurement.by,
        value: this.definition.throughput_measurement.value
      };
    }
    if (this.definition.local_throughput_measurement) {
      body.localThroughputMeasurement = this.definition.local_throughput_measurement.map((ltp) => ({
        region: ltp.region,
        writeOperationsPerSecond: ltp.write_operations_per_second || 1e3,
        readOperationsPerSecond: ltp.read_operations_per_second || 1e3
      }));
    }
    if (this.definition.average_item_size_in_bytes !== void 0) {
      body.averageItemSizeInBytes = this.definition.average_item_size_in_bytes;
    }
    if (this.definition.remote_backup) {
      body.remoteBackup = {
        active: this.definition.remote_backup.active,
        interval: this.definition.remote_backup.interval,
        timeUTC: this.definition.remote_backup.time_utc,
        storageType: this.definition.remote_backup.storage_type,
        storagePath: this.definition.remote_backup.storage_path
      };
    }
    if (this.definition.client_tls_certificates) {
      body.clientTlsCertificates = this.definition.client_tls_certificates.map((cert) => ({
        publicCertificatePEMString: cert.public_certificate_pem_string
      }));
    }
    if (this.definition.enable_tls !== void 0) {
      body.enableTls = this.definition.enable_tls;
    }
    if (this.definition.protocol === "memcached") {
      if (this.definition.sasl_username !== void 0) {
        body.saslUsername = this.definition.sasl_username;
      }
      if (this.definition.sasl_password !== void 0) {
        body.saslPassword = this.definition.sasl_password;
      }
    }
    if (this.definition.sharding_type !== void 0) {
      body.shardingType = this.definition.sharding_type;
    }
    if (this.definition.query_performance_factor !== void 0) {
      body.queryPerformanceFactor = this.definition.query_performance_factor;
    }
    const response = this.makeRequest("POST", `/subscriptions/${this.definition.subscription_id}/databases`, body);
    this.state.task_id = response.taskId;
    this.state.name = this.definition.name;
    this.state.memory_limit_in_mb = (this.definition.dataset_size_in_gb || 1) * 1024;
    cli.output(`\u2705 Pro database creation initiated: ${this.state.name}`);
    cli.output(`\u{1F4CB} Task ID: ${this.state.task_id}`);
    if (!this.state.task_id) {
      throw new Error("No task ID returned from database creation request");
    }
    const taskResult = this.waitForTask(this.state.task_id);
    if (taskResult && taskResult.response && taskResult.response.resourceId) {
      this.state.id = taskResult.response.resourceId;
      cli.output(`\u2705 Database created with ID: ${this.state.id}`);
      const databaseData = this.makeRequest("GET", `/subscriptions/${this.definition.subscription_id}/databases/${this.state.id}`);
      if (databaseData) {
        this.state.status = databaseData.status;
        this.state.public_endpoint = databaseData.publicEndpoint;
        this.state.private_endpoint = databaseData.privateEndpoint;
        this.state.port = databaseData.port;
        this.state.memory_usage_in_mb = databaseData.memoryUsageInMb;
        if (this.definition.support_oss_cluster_api && databaseData.clustering) {
          this.state.cluster_info = {
            shard_count: databaseData.clustering.numberOfShards,
            status: databaseData.clustering.status
          };
        }
        cli.output(`\u2705 Pro database ready: ${this.state.name} (${databaseData.status})`);
      }
    } else {
      throw new Error("Task completed but no resource ID was returned");
    }
  }
  mapDataPersistence() {
    return this.definition.data_persistence || "none";
  }
  findExistingDatabase() {
    try {
      const response = this.makeRequest("GET", `/subscriptions/${this.definition.subscription_id}/databases`);
      return response.databases?.find((db) => db.name === this.definition.name);
    } catch (error) {
      cli.output(`\u26A0\uFE0F Could not check for existing databases: ${error}`);
      return null;
    }
  }
  getOrCreatePassword() {
    if (!this.definition.password_secret_ref) {
      throw new Error("Password secret reference not defined");
    }
    try {
      const storedPassword = secret.get(this.definition.password_secret_ref);
      if (!storedPassword) {
        throw new Error("Password not found");
      }
      return storedPassword;
    } catch (e) {
      const password = secret.randString(16);
      secret.set(this.definition.password_secret_ref, password);
      return password;
    }
  }
  start() {
    super.start();
  }
  update() {
    if (!this.state.id) {
      this.create();
      return;
    }
    const databaseData = this.checkResourceExists(`/subscriptions/${this.definition.subscription_id}/databases/${this.state.id}`);
    if (databaseData) {
      this.state.status = databaseData.status;
      this.state.public_endpoint = databaseData.publicEndpoint;
      this.state.private_endpoint = databaseData.privateEndpoint;
      this.state.port = databaseData.port;
      this.state.memory_usage_in_mb = databaseData.memoryUsageInMb;
      if (databaseData.clustering) {
        this.state.cluster_info = {
          shard_count: databaseData.clustering.numberOfShards,
          status: databaseData.clustering.status
        };
      }
      if (databaseData.modules) {
        this.state.enabled_modules = databaseData.modules.map((m) => m.name);
      }
      if (this.definition.alerts && this.definition.alerts.length > 0) {
        this.updateAdvancedAlerts();
      }
    }
  }
  updateAdvancedAlerts() {
    if (!this.state.id) return;
    const alerts = this.definition.alerts || [];
    if (alerts.length > 0) {
      try {
        this.makeRequest("PUT", `/subscriptions/${this.definition.subscription_id}/databases/${this.state.id}/alerts`, { alerts });
        cli.output(`\u2705 Updated alerts for Pro database ${this.state.name}`);
      } catch (error) {
        cli.output(`\u26A0\uFE0F Failed to update alerts: ${error}`);
      }
    }
  }
  delete() {
    if (!this.state.id) {
      cli.output("Pro database does not exist, nothing to delete");
      return;
    }
    this.deleteResource(`/subscriptions/${this.definition.subscription_id}/databases/${this.state.id}`, `Pro Database ${this.state.name}`);
  }
  checkReadiness() {
    if (!this.state.id) {
      return false;
    }
    const databaseData = this.checkResourceExists(`/subscriptions/${this.definition.subscription_id}/databases/${this.state.id}`);
    if (!databaseData) {
      return false;
    }
    if (databaseData.status === "active") {
      this.state.status = "active";
      this.state.public_endpoint = databaseData.publicEndpoint;
      this.state.private_endpoint = databaseData.privateEndpoint;
      this.state.port = databaseData.port;
      this.state.memory_usage_in_mb = databaseData.memoryUsageInMb;
      if (databaseData.clustering) {
        this.state.cluster_info = {
          shard_count: databaseData.clustering.numberOfShards,
          status: databaseData.clustering.status
        };
      }
      if (databaseData.modules) {
        this.state.enabled_modules = databaseData.modules.map((m) => m.name);
      }
      return true;
    }
    this.state.status = databaseData.status;
    return false;
  }
  checkLiveness() {
    return this.checkReadiness();
  }
  getBackupInfo(_args) {
    cli.output(`==================================================`);
    cli.output(`\u{1F4E6} Backup Information for Pro database: ${this.state.name}`);
    cli.output(`==================================================`);
    cli.output(`Database ID: ${this.state.id}`);
    cli.output(`Subscription ID: ${this.definition.subscription_id}`);
    if (!this.state.id) {
      throw new Error("Database ID is not available. Ensure the database is created and ready.");
    }
    try {
      const databaseData = this.checkResourceExists(`/subscriptions/${this.definition.subscription_id}/databases/${this.state.id}`);
      if (!databaseData) {
        throw new Error(`Database ${this.state.name} not found`);
      }
      cli.output(`
\u{1F527} Backup Configuration:`);
      if (this.definition.remote_backup) {
        cli.output(`   Remote Backup: ${this.definition.remote_backup.active ? "\u2705 Enabled" : "\u274C Disabled"}`);
        if (this.definition.remote_backup.interval) {
          cli.output(`   Backup Interval: ${this.definition.remote_backup.interval}`);
        }
        if (this.definition.remote_backup.storage_type) {
          cli.output(`   Storage Type: ${this.definition.remote_backup.storage_type}`);
        }
        if (this.definition.remote_backup.storage_path) {
          cli.output(`   Storage Path: ${this.definition.remote_backup.storage_path}`);
        }
        if (this.definition.remote_backup.time_utc) {
          cli.output(`   Backup Time (UTC): ${this.definition.remote_backup.time_utc}`);
        }
      } else {
        cli.output(`   Remote Backup: \u274C Not configured`);
      }
      if (this.state.backup) {
        cli.output(`
\u{1F4C5} Last Backup Status:`);
        if (this.state.backup.status) cli.output(`   Status: ${this.state.backup.status}`);
        if (this.state.backup.last_backup) cli.output(`   Last Backup: ${this.state.backup.last_backup}`);
        if (this.state.backup.path) cli.output(`   Path: ${this.state.backup.path}`);
      }
      cli.output(`
\u{1F4CB} To create a manual snapshot:`);
      cli.output(`   monk do namespace/database create-snapshot`);
      cli.output(`
\u{1F4CB} To list all backups:`);
      cli.output(`   monk do namespace/database list-snapshots`);
      cli.output(`
==================================================`);
    } catch (error) {
      cli.output(`
\u274C Failed to get backup info`);
      throw new Error(`Get backup info failed: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  createSnapshot(args) {
    cli.output(`Initiating backup for Pro database: ${this.state.name}`);
    if (!this.state.id) {
      throw new Error("Database ID is not available. Cannot initiate backup.");
    }
    const backupPath = args?.backup_path || args?.adhocBackupPath;
    const regionName = args?.region_name || args?.regionName;
    if (!this.definition.remote_backup?.storage_path && !backupPath) {
      throw new Error("remote_backup.storage_path is not configured for this database, and no backup_path was provided. Cannot initiate backup.");
    }
    const body = {};
    if (regionName) {
      body.regionName = regionName;
    }
    if (backupPath) {
      body.adhocBackupPath = backupPath;
    }
    try {
      const response = this.makeRequest(
        "POST",
        `/subscriptions/${this.definition.subscription_id}/databases/${this.state.id}/backup`,
        Object.keys(body).length > 0 ? body : void 0
      );
      if (response && response.taskId) {
        cli.output(`\u2705 Backup initiated. Task ID: ${response.taskId}`);
        this.waitForTask(response.taskId);
        cli.output(`\u2705 Backup task ${response.taskId} completed successfully.`);
      } else {
        cli.output(`\u26A0\uFE0F  Backup request sent but no task ID returned. Response: ${JSON.stringify(response)}`);
      }
    } catch (error) {
      throw new Error(`Failed to initiate backup for Pro database ${this.state.name}: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  restore(args) {
    cli.output(`==================================================`);
    cli.output(`\u{1F504} RESTORE PRO DATABASE FROM BACKUP`);
    cli.output(`==================================================`);
    cli.output(`Database: ${this.state.name}`);
    cli.output(`Database ID: ${this.state.id}`);
    cli.output(`Subscription ID: ${this.definition.subscription_id}`);
    cli.output(`--------------------------------------------------`);
    if (!this.state.id) {
      cli.output(`\u274C ERROR: Database does not exist, cannot restore`);
      throw new Error("Database does not exist, cannot restore");
    }
    const sourceType = args?.source_type || args?.sourceType;
    const importFromUri = args?.source_uri || args?.importFromUri;
    if (!sourceType || !importFromUri) {
      cli.output(`\u274C ERROR: Missing required parameters`);
      cli.output(`Required parameters:`);
      cli.output(`  - source_type: Type of storage (aws-s3, ftp, google-blob-storage, azure-blob-storage, redis, http)`);
      cli.output(`  - source_uri: URI to the backup file`);
      cli.output(`--------------------------------------------------`);
      cli.output(`Example usage:`);
      cli.output(`  monk do <namespace>/<database> restore source_type="aws-s3" source_uri="s3://bucket/backup.rdb"`);
      cli.output(`==================================================`);
      throw new Error("Both source_type and source_uri are required parameters");
    }
    const validSourceTypes = ["aws-s3", "ftp", "google-blob-storage", "azure-blob-storage", "redis", "http"];
    if (!validSourceTypes.includes(sourceType)) {
      cli.output(`\u274C ERROR: Invalid source_type: ${sourceType}`);
      cli.output(`Valid source types: ${validSourceTypes.join(", ")}`);
      cli.output(`==================================================`);
      throw new Error(`Invalid source_type: ${sourceType}`);
    }
    cli.output(`\u26A0\uFE0F  WARNING: DESTRUCTIVE OPERATION!`);
    cli.output(`\u26A0\uFE0F  This will OVERWRITE ALL EXISTING DATA in the database!`);
    cli.output(`\u26A0\uFE0F  Ensure you have a backup before proceeding.`);
    cli.output(`--------------------------------------------------`);
    cli.output(`Source Type: ${sourceType}`);
    cli.output(`Import From: ${importFromUri}`);
    cli.output(`--------------------------------------------------`);
    try {
      const endpoint = `/subscriptions/${this.definition.subscription_id}/databases/${this.state.id}/import`;
      cli.output(`Making request to: POST ${endpoint}`);
      const body = {
        sourceType,
        importFromUri: [importFromUri]
        // Must be an array
      };
      cli.output(`Request body: ${JSON.stringify(body, null, 2)}`);
      const response = this.makeRequest("POST", endpoint, body);
      cli.output(`Response received: ${JSON.stringify(response)}`);
      if (response && response.taskId) {
        cli.output(`--------------------------------------------------`);
        cli.output(`\u2705 Import task created!`);
        cli.output(`Task ID: ${response.taskId}`);
        cli.output(`\u23F3 Waiting for import to complete...`);
        cli.output(`Note: Large datasets may take several minutes to import.`);
        this.waitForTask(response.taskId);
        cli.output(`--------------------------------------------------`);
        cli.output(`\u2705 RESTORE COMPLETED SUCCESSFULLY`);
        cli.output(`Database: ${this.state.name}`);
        cli.output(`Database ID: ${this.state.id}`);
        cli.output(`Source: ${importFromUri}`);
        cli.output(`Task ID: ${response.taskId}`);
        cli.output(`==================================================`);
      } else {
        cli.output(`--------------------------------------------------`);
        cli.output(`\u26A0\uFE0F  WARNING: No task ID in response!`);
        cli.output(`Response was: ${JSON.stringify(response)}`);
        cli.output(`==================================================`);
      }
    } catch (error) {
      cli.output(`--------------------------------------------------`);
      cli.output(`\u274C FAILED to restore database`);
      cli.output(`Error: ${error instanceof Error ? error.message : "Unknown error"}`);
      cli.output(`==================================================`);
      throw new Error(`Failed to restore Pro database ${this.state.name}: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  /**
   * Helper method to display backup information
   */
  displayBackups(backups) {
    if (backups.length === 0) {
      cli.output(`--------------------------------------------------`);
      cli.output(`\u2139\uFE0F  No backups found for this database`);
      cli.output(`==================================================`);
    } else {
      cli.output(`--------------------------------------------------`);
      cli.output(`\u2705 Found ${backups.length} backup(s):`);
      cli.output(`--------------------------------------------------`);
      backups.forEach((backup, index) => {
        cli.output(`
\u{1F4E6} Backup #${index + 1}:`);
        if (backup.backupId) cli.output(`  ID: ${backup.backupId}`);
        if (backup.status) cli.output(`  Status: ${backup.status}`);
        if (backup.timestamp) cli.output(`  Timestamp: ${backup.timestamp}`);
        if (backup.size) cli.output(`  Size: ${backup.size}`);
        if (backup.path) cli.output(`  Path: ${backup.path}`);
        if (backup.type) cli.output(`  Type: ${backup.type}`);
        if (backup.regionName) cli.output(`  Region: ${backup.regionName}`);
      });
      cli.output(`
==================================================`);
    }
  }
  listSnapshots() {
    cli.output(`==================================================`);
    cli.output(`\u{1F4CB} Listing backups for Pro database: ${this.state.name}`);
    cli.output(`==================================================`);
    cli.output(`Database ID: ${this.state.id}`);
    cli.output(`Subscription ID: ${this.definition.subscription_id}`);
    if (!this.state.id) {
      cli.output(`ERROR: Database ID is not available`);
      throw new Error("Database ID is not available. Cannot list backups.");
    }
    try {
      const endpoint = `/subscriptions/${this.definition.subscription_id}/databases/${this.state.id}/backup`;
      cli.output(`Making request to: GET ${endpoint}`);
      cli.output(`--------------------------------------------------`);
      const response = this.makeRequest("GET", endpoint);
      cli.output(`\u{1F4E5} Response received`);
      if (response && response.taskId) {
        cli.output(`\u23F3 Backup listing is processing (Task ID: ${response.taskId})`);
        cli.output(`Waiting for task to complete...`);
        const taskResult = this.waitForTask(response.taskId);
        cli.output(`--------------------------------------------------`);
        if (taskResult && taskResult.response) {
          const backupData = taskResult.response;
          if (Array.isArray(backupData)) {
            this.displayBackups(backupData);
          } else if (backupData.backups && Array.isArray(backupData.backups)) {
            this.displayBackups(backupData.backups);
          } else {
            cli.output(`\u{1F4CB} Task result:`);
            cli.output(JSON.stringify(taskResult, null, 2));
            cli.output(`==================================================`);
          }
        } else {
          cli.output(`\u{1F4CB} Task completed but no backup data found in response`);
          cli.output(`Full task result:`);
          cli.output(JSON.stringify(taskResult, null, 2));
          cli.output(`==================================================`);
        }
      } else if (response && Array.isArray(response)) {
        this.displayBackups(response);
      } else if (response && response.backups && Array.isArray(response.backups)) {
        this.displayBackups(response.backups);
      } else {
        cli.output(`--------------------------------------------------`);
        cli.output(`\u{1F4CB} Backup information:`);
        cli.output(JSON.stringify(response, null, 2));
        cli.output(`==================================================`);
      }
    } catch (error) {
      cli.output(`--------------------------------------------------`);
      cli.output(`\u274C FAILED TO LIST BACKUPS`);
      cli.output(`Error: ${error instanceof Error ? error.message : "Unknown error"}`);
      cli.output(`==================================================`);
      throw new Error(`Failed to list backups for Pro database ${this.state.name}: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
};
_init = __decoratorStart(_a);
__decorateElement(_init, 1, "getBackupInfo", _getBackupInfo_dec, _ProDatabase);
__decorateElement(_init, 1, "createSnapshot", _createSnapshot_dec, _ProDatabase);
__decorateElement(_init, 1, "restore", _restore_dec, _ProDatabase);
__decorateElement(_init, 1, "listSnapshots", _listSnapshots_dec, _ProDatabase);
__decoratorMetadata(_init, _ProDatabase);
__name(_ProDatabase, "ProDatabase");
var ProDatabase = _ProDatabase;



function main(def, state, ctx) {
  const entity = new ProDatabase(def, state, ctx);
  return entity.main(ctx);
}
