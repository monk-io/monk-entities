
// Generated by MonkEC - targeting Goja runtime
var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });

// input/redis-cloud/essentialsDatabase.ts
const secret = require("secret");
const cli = require("cli");
const base = require("redis-cloud/base");
const RedisCloudEntity = base.RedisCloudEntity;
var _EssentialsDatabase = class _EssentialsDatabase extends RedisCloudEntity {
  getEntityName() {
    return `Essentials Database: ${this.definition.name}`;
  }
  /** Create a new Redis Cloud Essentials database */
  create() {
    const existingDatabase = this.findExistingDatabase();
    if (existingDatabase) {
      this.state.existing = true;
      this.state.id = existingDatabase.databaseId;
      this.state.name = existingDatabase.name;
      this.state.username = "default";
      this.state.publicEndpoint = existingDatabase.publicEndpoint;
      if (existingDatabase.publicEndpoint) {
        const endpointParts = existingDatabase.publicEndpoint.split(":");
        this.state.publicEndpointHost = endpointParts[0];
        this.state.publicEndpointPort = endpointParts[1];
      }
      cli.output(`\u2705 Using existing Essentials database: ${existingDatabase.name} (${existingDatabase.databaseId})`);
      return;
    }
    const body = {
      name: this.definition.name,
      protocol: this.definition.protocol || "stack",
      password: this.getOrCreatePassword()
    };
    if (this.definition.dataset_size_in_gb !== void 0) {
      body.datasetSizeInGb = this.definition.dataset_size_in_gb;
    }
    if (this.definition.memory_limit_in_gb !== void 0) {
      body.memoryLimitInGb = this.definition.memory_limit_in_gb;
    }
    if (this.definition.support_oss_cluster_api !== void 0) {
      body.supportOSSClusterApi = this.definition.support_oss_cluster_api;
    }
    if (this.definition.redis_version) {
      body.redisVersion = this.definition.redis_version;
    }
    if (this.definition.resp_version) {
      body.respVersion = this.definition.resp_version;
    }
    if (this.definition.use_external_endpoint_for_oss_cluster_api !== void 0) {
      body.useExternalEndpointForOSSClusterApi = this.definition.use_external_endpoint_for_oss_cluster_api;
    }
    if (this.definition.enable_database_clustering !== void 0) {
      body.enableDatabaseClustering = this.definition.enable_database_clustering;
    }
    if (this.definition.number_of_shards !== void 0) {
      body.numberOfShards = this.definition.number_of_shards;
    }
    if (this.definition.data_persistence) {
      body.dataPersistence = this.definition.data_persistence;
    }
    if (this.definition.data_eviction_policy) {
      body.dataEvictionPolicy = this.definition.data_eviction_policy;
    }
    if (this.definition.replication !== void 0) {
      body.replication = this.definition.replication;
    }
    if (this.definition.periodic_backup_path) {
      body.periodicBackupPath = this.definition.periodic_backup_path;
    }
    if (this.definition.source_ips && this.definition.source_ips.length > 0) {
      body.sourceIps = this.definition.source_ips;
    }
    if (this.definition.regex_rules && this.definition.regex_rules.length > 0) {
      body.regexRules = this.definition.regex_rules;
    }
    if (this.definition.replica) {
      body.replica = {
        uris: this.definition.replica.uris,
        encryptionInTransit: this.definition.replica.encryptionInTransit
      };
    }
    if (this.definition.client_tls_certificates && this.definition.client_tls_certificates.length > 0) {
      body.clientTlsCertificates = this.definition.client_tls_certificates.map((cert) => ({
        name: cert.name,
        certificate: cert.certificate
      }));
    }
    if (this.definition.enable_tls !== void 0) {
      body.enableTls = this.definition.enable_tls;
    }
    if (this.definition.alerts && this.definition.alerts.length > 0) {
      body.alerts = this.definition.alerts.map((alert) => ({
        name: alert.name,
        value: alert.value
      }));
    }
    if (this.definition.modules && this.definition.modules.length > 0) {
      body.modules = this.definition.modules.map((module) => ({
        name: module.name,
        parameters: module.parameters
      }));
    }
    const response = this.makeRequest("POST", `/fixed/subscriptions/${this.definition.subscription_id}/databases`, body);
    this.state.task_id = response.taskId;
    this.state.name = this.definition.name;
    cli.output(`\u2705 Essentials database creation initiated: ${this.state.name}`);
    cli.output(`\u{1F4CB} Task ID: ${this.state.task_id}`);
    if (!this.state.task_id) {
      throw new Error("No task ID returned from database creation request");
    }
    const taskResult = this.waitForTask(this.state.task_id);
    if (taskResult && taskResult.response && taskResult.response.resourceId) {
      this.state.id = taskResult.response.resourceId;
      cli.output(`\u2705 Database created with ID: ${this.state.id}`);
      const databaseData = this.makeRequest("GET", `/fixed/subscriptions/${this.definition.subscription_id}/databases/${this.state.id}`);
      if (databaseData) {
        this.state.username = "default";
        this.state.publicEndpoint = databaseData.publicEndpoint;
        if (databaseData.publicEndpoint) {
          const endpointParts = databaseData.publicEndpoint.split(":");
          this.state.publicEndpointHost = endpointParts[0];
          this.state.publicEndpointPort = endpointParts[1];
        }
        cli.output(`\u2705 Essentials database ready: ${this.state.name} (${databaseData.status})`);
      }
    } else {
      throw new Error("Task completed but no resource ID was returned");
    }
  }
  findExistingDatabase() {
    try {
      const response = this.makeRequest("GET", `/fixed/subscriptions/${this.definition.subscription_id}/databases`);
      return response.databases?.find((db) => db.name === this.definition.name);
    } catch (error) {
      cli.output(`\u26A0\uFE0F Could not check for existing databases: ${error}`);
      return null;
    }
  }
  getOrCreatePassword() {
    if (!this.definition.password_secret_ref) {
      throw new Error("Password secret reference not defined");
    }
    try {
      const storedPassword = secret.get(this.definition.password_secret_ref);
      if (!storedPassword) {
        throw new Error("Password not found");
      }
      return storedPassword;
    } catch (e) {
      const password = secret.randString(16);
      secret.set(this.definition.password_secret_ref, password);
      return password;
    }
  }
  start() {
    super.start();
  }
  update() {
    if (!this.state.id) {
      this.create();
      return;
    }
    const databaseData = this.checkResourceExists(`/fixed/subscriptions/${this.definition.subscription_id}/databases/${this.state.id}`);
    if (databaseData) {
      this.state.publicEndpoint = databaseData.publicEndpoint;
      if (databaseData.publicEndpoint) {
        const endpointParts = databaseData.publicEndpoint.split(":");
        this.state.publicEndpointHost = endpointParts[0];
        this.state.publicEndpointPort = endpointParts[1];
      }
    }
  }
  delete() {
    if (!this.state.id) {
      cli.output("Essentials database does not exist, nothing to delete");
      return;
    }
    if (this.state.existing) {
      cli.output(`Essentials Database ${this.state.name} wasn't created by this entity, skipping delete`);
      return;
    }
    try {
      const response = this.makeRequest("DELETE", `/fixed/subscriptions/${this.definition.subscription_id}/databases/${this.state.id}`);
      if (response && response.taskId) {
        cli.output(`\u{1F5D1}\uFE0F Essentials database deletion initiated: ${this.state.name}`);
        cli.output(`\u{1F4CB} Delete Task ID: ${response.taskId}`);
        this.waitForTask(response.taskId);
        cli.output(`\u2705 Essentials database deleted successfully: ${this.state.name}`);
      } else {
        cli.output(`\u2705 Essentials database deleted successfully: ${this.state.name}`);
      }
    } catch (error) {
      throw new Error(`Failed to delete Essentials Database ${this.state.name}: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  checkReadiness() {
    if (!this.state.id) {
      return false;
    }
    const databaseData = this.checkResourceExists(`/fixed/subscriptions/${this.definition.subscription_id}/databases/${this.state.id}`);
    if (!databaseData) {
      return false;
    }
    if (databaseData.status === "active") {
      this.state.publicEndpoint = databaseData.publicEndpoint;
      if (databaseData.publicEndpoint) {
        const endpointParts = databaseData.publicEndpoint.split(":");
        this.state.publicEndpointHost = endpointParts[0];
        this.state.publicEndpointPort = endpointParts[1];
      }
      return true;
    }
    return false;
  }
};
__name(_EssentialsDatabase, "EssentialsDatabase");
var EssentialsDatabase = _EssentialsDatabase;



function main(def, state, ctx) {
  const entity = new EssentialsDatabase(def, state, ctx);
  return entity.main(ctx);
}
