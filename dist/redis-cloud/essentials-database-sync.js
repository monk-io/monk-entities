
// Generated by MonkEC - targeting Goja runtime
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __knownSymbol = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __decoratorStart = (base) => [, , , __create(base?.[__knownSymbol("metadata")] ?? null)];
var __decoratorStrings = ["class", "method", "getter", "setter", "accessor", "field", "value", "get", "set"];
var __expectFn = (fn) => fn !== void 0 && typeof fn !== "function" ? __typeError("Function expected") : fn;
var __decoratorContext = (kind, name, done, metadata, fns) => ({ kind: __decoratorStrings[kind], name, metadata, addInitializer: (fn) => done._ ? __typeError("Already initialized") : fns.push(__expectFn(fn || null)) });
var __decoratorMetadata = (array, target) => __defNormalProp(target, __knownSymbol("metadata"), array[3]);
var __runInitializers = (array, flags, self, value) => {
  for (var i = 0, fns = array[flags >> 1], n = fns && fns.length; i < n; i++) flags & 1 ? fns[i].call(self) : value = fns[i].call(self, value);
  return value;
};
var __decorateElement = (array, flags, name, decorators, target, extra) => {
  var fn, it, done, ctx, access, k = flags & 7, s = !!(flags & 8), p = !!(flags & 16);
  var j = k > 3 ? array.length + 1 : k ? s ? 1 : 2 : 0, key = __decoratorStrings[k + 5];
  var initializers = k > 3 && (array[j - 1] = []), extraInitializers = array[j] || (array[j] = []);
  var desc = k && (!p && !s && (target = target.prototype), k < 5 && (k > 3 || !p) && __getOwnPropDesc(k < 4 ? target : { get [name]() {
    return __privateGet(this, extra);
  }, set [name](x) {
    return __privateSet(this, extra, x);
  } }, name));
  k ? p && k < 4 && __name(extra, (k > 2 ? "set " : k > 1 ? "get " : "") + name) : __name(target, name);
  for (var i = decorators.length - 1; i >= 0; i--) {
    ctx = __decoratorContext(k, name, done = {}, array[3], extraInitializers);
    if (k) {
      ctx.static = s, ctx.private = p, access = ctx.access = { has: p ? (x) => __privateIn(target, x) : (x) => name in x };
      if (k ^ 3) access.get = p ? (x) => (k ^ 1 ? __privateGet : __privateMethod)(x, target, k ^ 4 ? extra : desc.get) : (x) => x[name];
      if (k > 2) access.set = p ? (x, y) => __privateSet(x, target, y, k ^ 4 ? extra : desc.set) : (x, y) => x[name] = y;
    }
    it = (0, decorators[i])(k ? k < 4 ? p ? extra : desc[key] : k > 4 ? void 0 : { get: desc.get, set: desc.set } : target, ctx), done._ = 1;
    if (k ^ 4 || it === void 0) __expectFn(it) && (k > 4 ? initializers.unshift(it) : k ? p ? extra = it : desc[key] = it : target = it);
    else if (typeof it !== "object" || it === null) __typeError("Object expected");
    else __expectFn(fn = it.get) && (desc.get = fn), __expectFn(fn = it.set) && (desc.set = fn), __expectFn(fn = it.init) && initializers.unshift(fn);
  }
  return k || __decoratorMetadata(array, target), desc && __defProp(target, name, desc), p ? k ^ 4 ? extra : desc : target;
};
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateIn = (member, obj) => Object(obj) !== obj ? __typeError('Cannot use the "in" operator on this value') : member.has(obj);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);

// input/redis-cloud/essentialsDatabase.ts
const secret = require("secret");
const cli = require("cli");
const base = require("redis-cloud/base");
const RedisCloudEntity = base.RedisCloudEntity;
const MonkecBase = require("monkec/base");
var action2 = MonkecBase.action;
var _listSnapshots_dec, _restore_dec, _createSnapshot_dec, _getBackupInfo_dec, _a, _init;
var _EssentialsDatabase = class _EssentialsDatabase extends (_a = RedisCloudEntity, _getBackupInfo_dec = [action2("get-backup-info")], _createSnapshot_dec = [action2("create-snapshot")], _restore_dec = [action2("restore")], _listSnapshots_dec = [action2("list-snapshots")], _a) {
  constructor() {
    super(...arguments);
    __runInitializers(_init, 5, this);
  }
  getEntityName() {
    return `Essentials Database: ${this.definition.name}`;
  }
  /** Create a new Redis Cloud Essentials database */
  create() {
    const existingDatabase = this.findExistingDatabase();
    if (existingDatabase) {
      this.state.existing = true;
      this.state.id = existingDatabase.databaseId;
      this.state.name = existingDatabase.name;
      this.state.username = "default";
      this.state.publicEndpoint = existingDatabase.publicEndpoint;
      if (existingDatabase.publicEndpoint) {
        const endpointParts = existingDatabase.publicEndpoint.split(":");
        this.state.publicEndpointHost = endpointParts[0];
        this.state.publicEndpointPort = endpointParts[1];
      }
      cli.output(`\u2705 Using existing Essentials database: ${existingDatabase.name} (${existingDatabase.databaseId})`);
      return;
    }
    const body = {
      name: this.definition.name,
      protocol: this.definition.protocol || "stack",
      password: this.getOrCreatePassword()
    };
    if (this.definition.dataset_size_in_gb !== void 0) {
      body.datasetSizeInGb = this.definition.dataset_size_in_gb;
    }
    if (this.definition.memory_limit_in_gb !== void 0) {
      body.memoryLimitInGb = this.definition.memory_limit_in_gb;
    }
    if (this.definition.support_oss_cluster_api !== void 0) {
      body.supportOSSClusterApi = this.definition.support_oss_cluster_api;
    }
    if (this.definition.redis_version) {
      body.redisVersion = this.definition.redis_version;
    }
    if (this.definition.resp_version) {
      body.respVersion = this.definition.resp_version;
    }
    if (this.definition.use_external_endpoint_for_oss_cluster_api !== void 0) {
      body.useExternalEndpointForOSSClusterApi = this.definition.use_external_endpoint_for_oss_cluster_api;
    }
    if (this.definition.enable_database_clustering !== void 0) {
      body.enableDatabaseClustering = this.definition.enable_database_clustering;
    }
    if (this.definition.number_of_shards !== void 0) {
      body.numberOfShards = this.definition.number_of_shards;
    }
    if (this.definition.data_persistence) {
      body.dataPersistence = this.definition.data_persistence;
    }
    if (this.definition.data_eviction_policy) {
      body.dataEvictionPolicy = this.definition.data_eviction_policy;
    }
    if (this.definition.replication !== void 0) {
      body.replication = this.definition.replication;
    }
    if (this.definition.periodic_backup_path) {
      body.periodicBackupPath = this.definition.periodic_backup_path;
    }
    if (this.definition.source_ips && this.definition.source_ips.length > 0) {
      body.sourceIps = this.definition.source_ips;
    }
    if (this.definition.regex_rules && this.definition.regex_rules.length > 0) {
      body.regexRules = this.definition.regex_rules;
    }
    if (this.definition.replica) {
      body.replica = {
        uris: this.definition.replica.uris,
        encryptionInTransit: this.definition.replica.encryptionInTransit
      };
    }
    if (this.definition.client_tls_certificates && this.definition.client_tls_certificates.length > 0) {
      body.clientTlsCertificates = this.definition.client_tls_certificates.map((cert) => ({
        name: cert.name,
        certificate: cert.certificate
      }));
    }
    if (this.definition.enable_tls !== void 0) {
      body.enableTls = this.definition.enable_tls;
    }
    if (this.definition.alerts && this.definition.alerts.length > 0) {
      body.alerts = this.definition.alerts.map((alert) => ({
        name: alert.name,
        value: alert.value
      }));
    }
    if (this.definition.modules && this.definition.modules.length > 0) {
      body.modules = this.definition.modules.map((module) => ({
        name: module.name,
        parameters: module.parameters
      }));
    }
    const response = this.makeRequest("POST", `/fixed/subscriptions/${this.definition.subscription_id}/databases`, body);
    this.state.task_id = response.taskId;
    this.state.name = this.definition.name;
    cli.output(`\u2705 Essentials database creation initiated: ${this.state.name}`);
    cli.output(`\u{1F4CB} Task ID: ${this.state.task_id}`);
    if (!this.state.task_id) {
      throw new Error("No task ID returned from database creation request");
    }
    const taskResult = this.waitForTask(this.state.task_id);
    if (taskResult && taskResult.response && taskResult.response.resourceId) {
      this.state.id = taskResult.response.resourceId;
      cli.output(`\u2705 Database created with ID: ${this.state.id}`);
      const databaseData = this.makeRequest("GET", `/fixed/subscriptions/${this.definition.subscription_id}/databases/${this.state.id}`);
      if (databaseData) {
        this.state.username = "default";
        this.state.publicEndpoint = databaseData.publicEndpoint;
        if (databaseData.publicEndpoint) {
          const endpointParts = databaseData.publicEndpoint.split(":");
          this.state.publicEndpointHost = endpointParts[0];
          this.state.publicEndpointPort = endpointParts[1];
        }
        cli.output(`\u2705 Essentials database ready: ${this.state.name} (${databaseData.status})`);
      }
    } else {
      throw new Error("Task completed but no resource ID was returned");
    }
  }
  findExistingDatabase() {
    try {
      const response = this.makeRequest("GET", `/fixed/subscriptions/${this.definition.subscription_id}/databases`);
      return response.databases?.find((db) => db.name === this.definition.name);
    } catch (error) {
      cli.output(`\u26A0\uFE0F Could not check for existing databases: ${error}`);
      return null;
    }
  }
  getOrCreatePassword() {
    if (!this.definition.password_secret_ref) {
      throw new Error("Password secret reference not defined");
    }
    try {
      const storedPassword = secret.get(this.definition.password_secret_ref);
      if (!storedPassword) {
        throw new Error("Password not found");
      }
      return storedPassword;
    } catch (e) {
      const password = secret.randString(16);
      secret.set(this.definition.password_secret_ref, password);
      return password;
    }
  }
  start() {
    super.start();
  }
  update() {
    if (!this.state.id) {
      this.create();
      return;
    }
    const databaseData = this.checkResourceExists(`/fixed/subscriptions/${this.definition.subscription_id}/databases/${this.state.id}`);
    if (databaseData) {
      this.state.publicEndpoint = databaseData.publicEndpoint;
      if (databaseData.publicEndpoint) {
        const endpointParts = databaseData.publicEndpoint.split(":");
        this.state.publicEndpointHost = endpointParts[0];
        this.state.publicEndpointPort = endpointParts[1];
      }
    }
  }
  delete() {
    if (!this.state.id) {
      cli.output("Essentials database does not exist, nothing to delete");
      return;
    }
    if (this.state.existing) {
      cli.output(`Essentials Database ${this.state.name} wasn't created by this entity, skipping delete`);
      return;
    }
    try {
      const response = this.makeRequest("DELETE", `/fixed/subscriptions/${this.definition.subscription_id}/databases/${this.state.id}`);
      if (response && response.taskId) {
        cli.output(`\u{1F5D1}\uFE0F Essentials database deletion initiated: ${this.state.name}`);
        cli.output(`\u{1F4CB} Delete Task ID: ${response.taskId}`);
        this.waitForTask(response.taskId);
        cli.output(`\u2705 Essentials database deleted successfully: ${this.state.name}`);
      } else {
        cli.output(`\u2705 Essentials database deleted successfully: ${this.state.name}`);
      }
    } catch (error) {
      throw new Error(`Failed to delete Essentials Database ${this.state.name}: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  checkReadiness() {
    if (!this.state.id) {
      return false;
    }
    const databaseData = this.checkResourceExists(`/fixed/subscriptions/${this.definition.subscription_id}/databases/${this.state.id}`);
    if (!databaseData) {
      return false;
    }
    if (databaseData.status === "active") {
      this.state.publicEndpoint = databaseData.publicEndpoint;
      if (databaseData.publicEndpoint) {
        const endpointParts = databaseData.publicEndpoint.split(":");
        this.state.publicEndpointHost = endpointParts[0];
        this.state.publicEndpointPort = endpointParts[1];
      }
      return true;
    }
    return false;
  }
  checkLiveness() {
    return this.checkReadiness();
  }
  getBackupInfo(_args) {
    cli.output(`==================================================`);
    cli.output(`\u{1F4E6} Backup Information for Essentials database: ${this.state.name}`);
    cli.output(`==================================================`);
    cli.output(`Database ID: ${this.state.id}`);
    cli.output(`Subscription ID: ${this.definition.subscription_id}`);
    if (!this.state.id) {
      throw new Error("Database ID is not available. Ensure the database is created and ready.");
    }
    try {
      cli.output(`
\u{1F527} Backup Configuration:`);
      if (this.definition.periodic_backup_path) {
        cli.output(`   Periodic Backup: \u2705 Enabled`);
        cli.output(`   Backup Path: ${this.definition.periodic_backup_path}`);
        cli.output(`   Interval: Every 24 hours`);
      } else {
        cli.output(`   Periodic Backup: \u274C Not configured`);
        cli.output(`   Note: Set periodic_backup_path to enable automatic backups`);
      }
      cli.output(`
\u{1F4CB} To create a manual snapshot:`);
      cli.output(`   monk do namespace/database create-snapshot`);
      cli.output(`
\u{1F4CB} To list all backups:`);
      cli.output(`   monk do namespace/database list-snapshots`);
      cli.output(`
==================================================`);
    } catch (error) {
      cli.output(`
\u274C Failed to get backup info`);
      throw new Error(`Get backup info failed: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  createSnapshot(args) {
    cli.output(`==================================================`);
    cli.output(`Starting backup for database: ${this.state.name}`);
    cli.output(`Database ID: ${this.state.id}`);
    cli.output(`Subscription ID: ${this.definition.subscription_id}`);
    cli.output(`Backup path: ${this.definition.periodic_backup_path || "not set"}`);
    cli.output(`==================================================`);
    if (!this.state.id) {
      cli.output(`ERROR: Database ID is not available`);
      throw new Error("Database ID is not available. Cannot initiate backup.");
    }
    const backupPath = args?.backup_path || args?.adhocBackupPath;
    if (!this.definition.periodic_backup_path && !backupPath) {
      cli.output(`ERROR: No backup path configured`);
      throw new Error("periodic_backup_path is not configured for this database, and no backup_path was provided. Cannot initiate backup.");
    }
    const body = {};
    if (backupPath) {
      body.adhocBackupPath = backupPath;
      cli.output(`Using ad-hoc backup path: ${backupPath}`);
    } else {
      cli.output(`Using configured periodic backup path`);
    }
    try {
      const endpoint = `/fixed/subscriptions/${this.definition.subscription_id}/databases/${this.state.id}/backup`;
      cli.output(`Making request to: POST ${endpoint}`);
      if (Object.keys(body).length > 0) {
        cli.output(`Request body: ${JSON.stringify(body)}`);
      } else {
        cli.output(`Request body: (empty - using configured path)`);
      }
      const response = this.makeRequest(
        "POST",
        endpoint,
        Object.keys(body).length > 0 ? body : void 0
      );
      cli.output(`Response received: ${JSON.stringify(response)}`);
      if (response && response.taskId) {
        cli.output(`--------------------------------------------------`);
        cli.output(`\u2705 Backup task created!`);
        cli.output(`Task ID: ${response.taskId}`);
        cli.output(`Waiting for task to complete...`);
        this.waitForTask(response.taskId);
        cli.output(`--------------------------------------------------`);
        cli.output(`\u2705 BACKUP COMPLETED SUCCESSFULLY`);
        cli.output(`Database: ${this.state.name}`);
        cli.output(`Task ID: ${response.taskId}`);
        cli.output(`==================================================`);
      } else {
        cli.output(`--------------------------------------------------`);
        cli.output(`\u26A0\uFE0F  WARNING: No task ID in response!`);
        cli.output(`Response was: ${JSON.stringify(response)}`);
        cli.output(`==================================================`);
      }
    } catch (error) {
      cli.output(`--------------------------------------------------`);
      cli.output(`\u274C BACKUP FAILED`);
      cli.output(`Error: ${error instanceof Error ? error.message : "Unknown error"}`);
      cli.output(`==================================================`);
      throw new Error(`Failed to initiate backup for Essentials database ${this.state.name}: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  restore(args) {
    cli.output(`==================================================`);
    cli.output(`\u{1F504} RESTORE DATABASE FROM BACKUP`);
    cli.output(`==================================================`);
    cli.output(`Database: ${this.state.name}`);
    cli.output(`Database ID: ${this.state.id}`);
    cli.output(`Subscription ID: ${this.definition.subscription_id}`);
    cli.output(`--------------------------------------------------`);
    if (!this.state.id) {
      cli.output(`\u274C ERROR: Database does not exist, cannot restore`);
      throw new Error("Database does not exist, cannot restore");
    }
    const sourceType = args?.source_type || args?.sourceType;
    const importFromUri = args?.source_uri || args?.importFromUri;
    if (!sourceType || !importFromUri) {
      cli.output(`\u274C ERROR: Missing required parameters`);
      cli.output(`Required parameters:`);
      cli.output(`  - source_type: Type of storage (aws-s3, ftp, google-blob-storage, azure-blob-storage, redis, http)`);
      cli.output(`  - source_uri: URI to the backup file`);
      cli.output(`--------------------------------------------------`);
      cli.output(`Example usage:`);
      cli.output(`  monk do <namespace>/<database> restore source_type="aws-s3" source_uri="s3://bucket/backup.rdb"`);
      cli.output(`==================================================`);
      throw new Error("Both source_type and source_uri are required parameters");
    }
    const validSourceTypes = ["aws-s3", "ftp", "google-blob-storage", "azure-blob-storage", "redis", "http"];
    if (!validSourceTypes.includes(sourceType)) {
      cli.output(`\u274C ERROR: Invalid source_type: ${sourceType}`);
      cli.output(`Valid source types: ${validSourceTypes.join(", ")}`);
      cli.output(`==================================================`);
      throw new Error(`Invalid source_type: ${sourceType}`);
    }
    cli.output(`\u26A0\uFE0F  WARNING: DESTRUCTIVE OPERATION!`);
    cli.output(`\u26A0\uFE0F  This will OVERWRITE ALL EXISTING DATA in the database!`);
    cli.output(`\u26A0\uFE0F  Ensure you have a backup before proceeding.`);
    cli.output(`--------------------------------------------------`);
    cli.output(`Source Type: ${sourceType}`);
    cli.output(`Import From: ${importFromUri}`);
    cli.output(`--------------------------------------------------`);
    try {
      const endpoint = `/fixed/subscriptions/${this.definition.subscription_id}/databases/${this.state.id}/import`;
      cli.output(`Making request to: POST ${endpoint}`);
      const body = {
        sourceType,
        importFromUri: [importFromUri]
        // Must be an array
      };
      cli.output(`Request body: ${JSON.stringify(body, null, 2)}`);
      const response = this.makeRequest("POST", endpoint, body);
      cli.output(`Response received: ${JSON.stringify(response)}`);
      if (response && response.taskId) {
        cli.output(`--------------------------------------------------`);
        cli.output(`\u2705 Import task created!`);
        cli.output(`Task ID: ${response.taskId}`);
        cli.output(`\u23F3 Waiting for import to complete...`);
        cli.output(`Note: Large datasets may take several minutes to import.`);
        this.waitForTask(response.taskId);
        cli.output(`--------------------------------------------------`);
        cli.output(`\u2705 RESTORE COMPLETED SUCCESSFULLY`);
        cli.output(`Database: ${this.state.name}`);
        cli.output(`Database ID: ${this.state.id}`);
        cli.output(`Source: ${importFromUri}`);
        cli.output(`Task ID: ${response.taskId}`);
        cli.output(`==================================================`);
      } else {
        cli.output(`--------------------------------------------------`);
        cli.output(`\u26A0\uFE0F  WARNING: No task ID in response!`);
        cli.output(`Response was: ${JSON.stringify(response)}`);
        cli.output(`==================================================`);
      }
    } catch (error) {
      cli.output(`--------------------------------------------------`);
      cli.output(`\u274C FAILED to restore database`);
      cli.output(`Error: ${error instanceof Error ? error.message : "Unknown error"}`);
      cli.output(`==================================================`);
      throw new Error(`Failed to restore Essentials database ${this.state.name}: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  /**
   * Helper method to display backup information
   */
  displayBackups(backups) {
    if (backups.length === 0) {
      cli.output(`--------------------------------------------------`);
      cli.output(`\u2139\uFE0F  No backups found for this database`);
      cli.output(`==================================================`);
    } else {
      cli.output(`--------------------------------------------------`);
      cli.output(`\u2705 Found ${backups.length} backup(s):`);
      cli.output(`--------------------------------------------------`);
      backups.forEach((backup, index) => {
        cli.output(`
\u{1F4E6} Backup #${index + 1}:`);
        if (backup.backupId) cli.output(`  ID: ${backup.backupId}`);
        if (backup.status) cli.output(`  Status: ${backup.status}`);
        if (backup.timestamp) cli.output(`  Timestamp: ${backup.timestamp}`);
        if (backup.size) cli.output(`  Size: ${backup.size}`);
        if (backup.path) cli.output(`  Path: ${backup.path}`);
        if (backup.type) cli.output(`  Type: ${backup.type}`);
      });
      cli.output(`
==================================================`);
    }
  }
  listSnapshots() {
    cli.output(`==================================================`);
    cli.output(`\u{1F4CB} Listing backups for database: ${this.state.name}`);
    cli.output(`==================================================`);
    cli.output(`Database ID: ${this.state.id}`);
    cli.output(`Subscription ID: ${this.definition.subscription_id}`);
    if (!this.state.id) {
      cli.output(`ERROR: Database ID is not available`);
      throw new Error("Database ID is not available. Cannot list backups.");
    }
    try {
      const endpoint = `/fixed/subscriptions/${this.definition.subscription_id}/databases/${this.state.id}/backup`;
      cli.output(`Making request to: GET ${endpoint}`);
      cli.output(`--------------------------------------------------`);
      const response = this.makeRequest("GET", endpoint);
      cli.output(`\u{1F4E5} Response received`);
      if (response && response.taskId) {
        cli.output(`\u23F3 Backup listing is processing (Task ID: ${response.taskId})`);
        cli.output(`Waiting for task to complete...`);
        const taskResult = this.waitForTask(response.taskId);
        cli.output(`--------------------------------------------------`);
        if (taskResult && taskResult.response) {
          const backupData = taskResult.response;
          if (Array.isArray(backupData)) {
            this.displayBackups(backupData);
          } else if (backupData.backups && Array.isArray(backupData.backups)) {
            this.displayBackups(backupData.backups);
          } else if (backupData.resource && backupData.resource.lastBackupTime) {
            cli.output(`\u{1F4E6} Last backup time: ${backupData.resource.lastBackupTime}`);
            cli.output(`\u2139\uFE0F  Note: Essentials databases only track the last backup time.`);
            cli.output(`   For detailed backup history, upgrade to a Pro subscription.`);
            cli.output(`==================================================`);
          } else {
            cli.output(`\u{1F4CB} Backup status:`);
            cli.output(JSON.stringify(taskResult.response, null, 2));
            cli.output(`==================================================`);
          }
        } else {
          cli.output(`\u{1F4CB} Task completed but no backup data found in response`);
          cli.output(`Full task result:`);
          cli.output(JSON.stringify(taskResult, null, 2));
          cli.output(`==================================================`);
        }
      } else if (response && Array.isArray(response)) {
        this.displayBackups(response);
      } else if (response && response.backups && Array.isArray(response.backups)) {
        this.displayBackups(response.backups);
      } else {
        cli.output(`--------------------------------------------------`);
        cli.output(`\u{1F4CB} Backup information:`);
        cli.output(JSON.stringify(response, null, 2));
        cli.output(`==================================================`);
      }
    } catch (error) {
      cli.output(`--------------------------------------------------`);
      cli.output(`\u274C FAILED TO LIST BACKUPS`);
      cli.output(`Error: ${error instanceof Error ? error.message : "Unknown error"}`);
      cli.output(`==================================================`);
      throw new Error(`Failed to list backups for Essentials database ${this.state.name}: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
};
_init = __decoratorStart(_a);
__decorateElement(_init, 1, "getBackupInfo", _getBackupInfo_dec, _EssentialsDatabase);
__decorateElement(_init, 1, "createSnapshot", _createSnapshot_dec, _EssentialsDatabase);
__decorateElement(_init, 1, "restore", _restore_dec, _EssentialsDatabase);
__decorateElement(_init, 1, "listSnapshots", _listSnapshots_dec, _EssentialsDatabase);
__decoratorMetadata(_init, _EssentialsDatabase);
__name(_EssentialsDatabase, "EssentialsDatabase");
var EssentialsDatabase = _EssentialsDatabase;



function main(def, state, ctx) {
  const entity = new EssentialsDatabase(def, state, ctx);
  return entity.main(ctx);
}
