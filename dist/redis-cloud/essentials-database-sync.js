
// Generated by MonkEC - targeting Goja runtime
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);

// input/redis-cloud/essentialsDatabase.ts
const base = require("monkec/base");
const MonkEntity = base.MonkEntity;
const httpClient = require("monkec/http-client");
const HttpClient = httpClient.HttpClient;
const common = require("redis-cloud/common");
const BASE_URL = common.BASE_URL;
const CONTENT_TYPE = common.CONTENT_TYPE;
const DEFAULT_TASK_TIMEOUT = common.DEFAULT_TASK_TIMEOUT;
const DEFAULT_POLLING_INTERVAL = common.DEFAULT_POLLING_INTERVAL;
const secret = require("secret");
const cli = require("cli");
var _EssentialsDatabase = class _EssentialsDatabase extends MonkEntity {
  constructor() {
    super(...arguments);
    /**
     * HTTP client configured for Redis Cloud API
     */
    __publicField(this, "httpClient");
    /**
     * Authentication credentials
     */
    __publicField(this, "credentials");
  }
  /**
   * Initialize authentication and HTTP client before any operations
   */
  before() {
    const accountKey = secret.get(this.definition.account_key_secret);
    const userKey = secret.get(this.definition.user_key_secret);
    if (!accountKey || !userKey) {
      throw new Error(`Redis Cloud credentials not found. Expected secrets: ${this.definition.account_key_secret} and ${this.definition.user_key_secret}`);
    }
    this.credentials = { accountKey, userKey };
    this.httpClient = new HttpClient({
      baseUrl: BASE_URL,
      headers: {
        "accept": "application/json",
        "x-api-key": accountKey,
        "x-api-secret-key": userKey,
        "content-type": CONTENT_TYPE
      },
      parseJson: true,
      stringifyJson: true
    });
  }
  getEntityName() {
    return `Essentials Database: ${this.definition.name}`;
  }
  /**
   * Helper method to make authenticated HTTP requests with consistent error handling
   */
  makeRequest(method, path, body) {
    try {
      const response = this.httpClient.request(method, path, {
        body,
        headers: {
          "accept": "application/json",
          "x-api-key": this.credentials.accountKey,
          "x-api-secret-key": this.credentials.userKey,
          "content-type": CONTENT_TYPE
        }
      });
      if (!response.ok) {
        const errorBody = typeof response.data === "string" ? response.data : JSON.stringify(response.data);
        throw new Error(`Redis Cloud API error: ${response.statusCode} ${response.status}. Body: ${errorBody || response.raw}`);
      }
      let responseData = response.data;
      if (typeof responseData === "string") {
        try {
          responseData = JSON.parse(responseData);
        } catch (e) {
        }
      }
      return responseData;
    } catch (error) {
      if (error instanceof Error) {
        throw new Error(`Redis Cloud ${method} request to ${path} failed: ${error.message}`);
      }
      throw error;
    }
  }
  /**
   * Helper method to check if a resource exists by making a GET request
   * Returns the resource data if it exists, null otherwise
   */
  checkResourceExists(path) {
    try {
      return this.makeRequest("GET", path);
    } catch (error) {
      return null;
    }
  }
  /**
   * Wait for task completion with timeout
   */
  waitForTask(taskId, timeoutSeconds = DEFAULT_TASK_TIMEOUT) {
    if (!taskId) {
      return null;
    }
    const startTime = Date.now();
    const timeout = timeoutSeconds * 1e3;
    while (Date.now() - startTime < timeout) {
      try {
        const taskData = this.makeRequest("GET", `/tasks/${taskId}`);
        if (taskData && taskData.status) {
          if (taskData.status === "processing-completed") {
            cli.output(`\u2705 Task ${taskId} completed successfully`);
            return taskData;
          }
          if (taskData.status === "processing-error") {
            throw new Error(`Task failed: ${taskData.description || "Unknown error"}`);
          }
          cli.output(`\u23F3 Task ${taskId} status: ${taskData.status}`);
        }
      } catch (error) {
        cli.output(`\u26A0\uFE0F Error checking task status: ${error}`);
      }
      const currentTime = Date.now();
      const elapsed = currentTime - startTime;
      if (elapsed + DEFAULT_POLLING_INTERVAL < timeout) {
        const endTime = currentTime + DEFAULT_POLLING_INTERVAL;
        while (Date.now() < endTime) {
        }
      } else {
        break;
      }
    }
    throw new Error(`Task ${taskId} timed out after ${timeoutSeconds} seconds`);
  }
  /** Create a new Redis Cloud Essentials database */
  create() {
    const existingDatabase = this.findExistingDatabase();
    if (existingDatabase) {
      this.state.existing = true;
      this.state.id = existingDatabase.databaseId;
      this.state.name = existingDatabase.name;
      this.state.username = "default";
      this.state.publicEndpoint = existingDatabase.publicEndpoint;
      if (existingDatabase.publicEndpoint) {
        const endpointParts = existingDatabase.publicEndpoint.split(":");
        this.state.publicEndpointHost = endpointParts[0];
        this.state.publicEndpointPort = endpointParts[1];
      }
      cli.output(`\u2705 Using existing Essentials database: ${existingDatabase.name} (${existingDatabase.databaseId})`);
      return;
    }
    const body = {
      name: this.definition.name,
      protocol: this.definition.protocol || "stack",
      password: this.getOrGeneratePassword()
    };
    if (this.definition.dataset_size_in_gb !== void 0) {
      body.datasetSizeInGb = this.definition.dataset_size_in_gb;
    }
    if (this.definition.memory_limit_in_gb !== void 0) {
      body.memoryLimitInGb = this.definition.memory_limit_in_gb;
    }
    if (this.definition.support_oss_cluster_api !== void 0) {
      body.supportOSSClusterApi = this.definition.support_oss_cluster_api;
    }
    if (this.definition.redis_version) {
      body.redisVersion = this.definition.redis_version;
    }
    if (this.definition.resp_version) {
      body.respVersion = this.definition.resp_version;
    }
    if (this.definition.use_external_endpoint_for_oss_cluster_api !== void 0) {
      body.useExternalEndpointForOSSClusterApi = this.definition.use_external_endpoint_for_oss_cluster_api;
    }
    if (this.definition.enable_database_clustering !== void 0) {
      body.enableDatabaseClustering = this.definition.enable_database_clustering;
    }
    if (this.definition.number_of_shards !== void 0) {
      body.numberOfShards = this.definition.number_of_shards;
    }
    if (this.definition.data_persistence) {
      body.dataPersistence = this.definition.data_persistence;
    }
    if (this.definition.data_eviction_policy) {
      body.dataEvictionPolicy = this.definition.data_eviction_policy;
    }
    if (this.definition.replication !== void 0) {
      body.replication = this.definition.replication;
    }
    if (this.definition.periodic_backup_path) {
      body.periodicBackupPath = this.definition.periodic_backup_path;
    }
    if (this.definition.source_ips && this.definition.source_ips.length > 0) {
      body.sourceIps = this.definition.source_ips;
    }
    if (this.definition.regex_rules && this.definition.regex_rules.length > 0) {
      body.regexRules = this.definition.regex_rules;
    }
    if (this.definition.replica) {
      body.replica = {
        uris: this.definition.replica.uris,
        encryptionInTransit: this.definition.replica.encryptionInTransit
      };
    }
    if (this.definition.client_tls_certificates && this.definition.client_tls_certificates.length > 0) {
      body.clientTlsCertificates = this.definition.client_tls_certificates.map((cert) => ({
        name: cert.name,
        certificate: cert.certificate
      }));
    }
    if (this.definition.enable_tls !== void 0) {
      body.enableTls = this.definition.enable_tls;
    }
    if (this.definition.alerts && this.definition.alerts.length > 0) {
      body.alerts = this.definition.alerts.map((alert) => ({
        name: alert.name,
        value: alert.value
      }));
    }
    if (this.definition.modules && this.definition.modules.length > 0) {
      body.modules = this.definition.modules.map((module) => ({
        name: module.name,
        parameters: module.parameters
      }));
    }
    const response = this.makeRequest("POST", `/fixed/subscriptions/${this.definition.subscription_id}/databases`, body);
    this.state.task_id = response.taskId;
    this.state.name = this.definition.name;
    this.state.password = body.password;
    cli.output(`\u2705 Essentials database creation initiated: ${this.state.name}`);
    cli.output(`\u{1F4CB} Task ID: ${this.state.task_id}`);
    if (!this.state.task_id) {
      throw new Error("No task ID returned from database creation request");
    }
    const taskResult = this.waitForTask(this.state.task_id);
    if (taskResult && taskResult.response && taskResult.response.resourceId) {
      this.state.id = taskResult.response.resourceId;
      cli.output(`\u2705 Database created with ID: ${this.state.id}`);
      const databaseData = this.makeRequest("GET", `/fixed/subscriptions/${this.definition.subscription_id}/databases/${this.state.id}`);
      if (databaseData) {
        this.state.username = "default";
        this.state.publicEndpoint = databaseData.publicEndpoint;
        if (databaseData.publicEndpoint) {
          const endpointParts = databaseData.publicEndpoint.split(":");
          this.state.publicEndpointHost = endpointParts[0];
          this.state.publicEndpointPort = endpointParts[1];
        }
        cli.output(`\u2705 Essentials database ready: ${this.state.name} (${databaseData.status})`);
      }
    } else {
      throw new Error("Task completed but no resource ID was returned");
    }
  }
  findExistingDatabase() {
    try {
      const response = this.makeRequest("GET", `/fixed/subscriptions/${this.definition.subscription_id}/databases`);
      return response.databases?.find((db) => db.name === this.definition.name);
    } catch (error) {
      cli.output(`\u26A0\uFE0F Could not check for existing databases: ${error}`);
      return null;
    }
  }
  getOrGeneratePassword() {
    if (this.definition.password) {
      return this.definition.password;
    }
    if (this.definition.password_secret) {
      try {
        const passwordFromSecret = secret.get(this.definition.password_secret);
        if (passwordFromSecret) {
          return passwordFromSecret;
        }
      } catch (error) {
        cli.output(`\u26A0\uFE0F Could not retrieve password from secret, generating new one`);
      }
    }
    const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
    let password = "";
    for (let i = 0; i < 32; i++) {
      password += chars.charAt(Math.floor(Math.random() * chars.length));
    }
    return password;
  }
  start() {
    super.start();
  }
  update() {
    if (!this.state.id) {
      this.create();
      return;
    }
    const databaseData = this.checkResourceExists(`/fixed/subscriptions/${this.definition.subscription_id}/databases/${this.state.id}`);
    if (databaseData) {
      this.state.publicEndpoint = databaseData.publicEndpoint;
      if (databaseData.publicEndpoint) {
        const endpointParts = databaseData.publicEndpoint.split(":");
        this.state.publicEndpointHost = endpointParts[0];
        this.state.publicEndpointPort = endpointParts[1];
      }
    }
  }
  delete() {
    if (!this.state.id) {
      cli.output("Essentials database does not exist, nothing to delete");
      return;
    }
    if (this.state.existing) {
      cli.output(`Essentials Database ${this.state.name} wasn't created by this entity, skipping delete`);
      return;
    }
    try {
      const response = this.makeRequest("DELETE", `/fixed/subscriptions/${this.definition.subscription_id}/databases/${this.state.id}`);
      if (response && response.taskId) {
        cli.output(`\u{1F5D1}\uFE0F Essentials database deletion initiated: ${this.state.name}`);
        cli.output(`\u{1F4CB} Delete Task ID: ${response.taskId}`);
        this.waitForTask(response.taskId);
        cli.output(`\u2705 Essentials database deleted successfully: ${this.state.name}`);
      } else {
        cli.output(`\u2705 Essentials database deleted successfully: ${this.state.name}`);
      }
    } catch (error) {
      throw new Error(`Failed to delete Essentials Database ${this.state.name}: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  checkReadiness() {
    if (!this.state.id) {
      return false;
    }
    const databaseData = this.checkResourceExists(`/fixed/subscriptions/${this.definition.subscription_id}/databases/${this.state.id}`);
    if (!databaseData) {
      return false;
    }
    if (databaseData.status === "active") {
      this.state.publicEndpoint = databaseData.publicEndpoint;
      if (databaseData.publicEndpoint) {
        const endpointParts = databaseData.publicEndpoint.split(":");
        this.state.publicEndpointHost = endpointParts[0];
        this.state.publicEndpointPort = endpointParts[1];
      }
      return true;
    }
    return false;
  }
};
__name(_EssentialsDatabase, "EssentialsDatabase");
var EssentialsDatabase = _EssentialsDatabase;



function main(def, state, ctx) {
  const entity = new EssentialsDatabase(def, state, ctx);
  return entity.main(ctx);
}
