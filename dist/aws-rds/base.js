// Generated by MonkEC - targeting Goja runtime
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);

// input/aws-rds/base.ts
var base_exports = {};
__export(base_exports, {
  AWSRDSEntity: () => AWSRDSEntity
});
module.exports = __toCommonJS(base_exports);
var import_base = require("monkec/base");
var import_aws = __toESM(require("cloud/aws"));
var import_cli = __toESM(require("cli"));
var AWSRDSEntity = class extends import_base.MonkEntity {
  constructor() {
    super(...arguments);
    __publicField(this, "region");
  }
  before() {
    this.region = this.definition.region;
  }
  makeRDSRequest(action, params = {}) {
    const url = `https://rds.${this.region}.amazonaws.com/`;
    const formParams = {
      "Action": action,
      "Version": "2014-10-31"
    };
    this.addParamsToFormData(formParams, params);
    const formBody = Object.entries(formParams).map(([key, value]) => `${encodeURIComponent(key)}=${encodeURIComponent(value)}`).join("&");
    const response = import_aws.default.post(url, {
      service: "rds",
      region: this.region,
      headers: {
        "Content-Type": "application/x-www-form-urlencoded"
      },
      body: formBody
    });
    if (response.statusCode >= 400) {
      let errorMessage = `AWS RDS API error: ${response.statusCode} ${response.status}`;
      try {
        const errorMatch = /<Message>(.*?)<\/Message>/.exec(response.body);
        if (errorMatch) {
          errorMessage += ` - ${errorMatch[1]}`;
        }
        const codeMatch = /<Code>(.*?)<\/Code>/.exec(response.body);
        if (codeMatch) {
          errorMessage += ` (${codeMatch[1]})`;
        }
      } catch (_parseError) {
        errorMessage += ` - Raw: ${response.body}`;
      }
      throw new Error(errorMessage);
    }
    return this.parseRDSResponse(response.body);
  }
  addParamsToFormData(formParams, params, prefix = "") {
    for (const [key, value] of Object.entries(params)) {
      const paramKey = prefix ? `${prefix}.${key}` : key;
      if (value === null || value === void 0) {
        continue;
      }
      if (Array.isArray(value)) {
        value.forEach((item, index) => {
          if (typeof item === "object") {
            this.addParamsToFormData(formParams, item, `${paramKey}.member.${index + 1}`);
          } else {
            formParams[`${paramKey}.member.${index + 1}`] = String(item);
          }
        });
      } else if (typeof value === "object") {
        this.addParamsToFormData(formParams, value, paramKey);
      } else {
        formParams[paramKey] = String(value);
      }
    }
  }
  parseRDSResponse(xmlBody) {
    const dbInstance = {};
    const identifierMatch = /<DBInstanceIdentifier>(.*?)<\/DBInstanceIdentifier>/.exec(xmlBody);
    if (identifierMatch) dbInstance.DBInstanceIdentifier = identifierMatch[1];
    const classMatch = /<DBInstanceClass>(.*?)<\/DBInstanceClass>/.exec(xmlBody);
    if (classMatch) dbInstance.DBInstanceClass = classMatch[1];
    const engineMatch = /<Engine>(.*?)<\/Engine>/.exec(xmlBody);
    if (engineMatch) dbInstance.Engine = engineMatch[1];
    const statusMatch = /<DBInstanceStatus>(.*?)<\/DBInstanceStatus>/.exec(xmlBody);
    if (statusMatch) {
      dbInstance.DBInstanceStatus = statusMatch[1];
    }
    const usernameMatch = /<MasterUsername>(.*?)<\/MasterUsername>/.exec(xmlBody);
    if (usernameMatch) dbInstance.MasterUsername = usernameMatch[1];
    const storageMatch = /<AllocatedStorage>(.*?)<\/AllocatedStorage>/.exec(xmlBody);
    if (storageMatch) dbInstance.AllocatedStorage = parseInt(storageMatch[1]);
    const engineVersionMatch = /<EngineVersion>(.*?)<\/EngineVersion>/.exec(xmlBody);
    if (engineVersionMatch) dbInstance.EngineVersion = engineVersionMatch[1];
    const createTimeMatch = /<InstanceCreateTime>(.*?)<\/InstanceCreateTime>/.exec(xmlBody);
    if (createTimeMatch) dbInstance.InstanceCreateTime = createTimeMatch[1];
    const arnMatch = /<DBInstanceArn>(.*?)<\/DBInstanceArn>/.exec(xmlBody);
    if (arnMatch) dbInstance.DBInstanceArn = arnMatch[1];
    const endpointAddressMatch = /<Address>(.*?)<\/Address>/.exec(xmlBody);
    const endpointPortMatch = /<Port>(.*?)<\/Port>/.exec(xmlBody);
    if (endpointAddressMatch || endpointPortMatch) {
      dbInstance.Endpoint = {};
      if (endpointAddressMatch) dbInstance.Endpoint.Address = endpointAddressMatch[1];
      if (endpointPortMatch) dbInstance.Endpoint.Port = parseInt(endpointPortMatch[1]);
    }
    return { DBInstance: dbInstance };
  }
  checkDBInstanceExists(dbInstanceIdentifier) {
    try {
      return this.makeRDSRequest("DescribeDBInstances", {
        DBInstanceIdentifier: dbInstanceIdentifier
      });
    } catch (error) {
      if (error instanceof Error && error.message.includes("DBInstanceNotFound")) {
        return null;
      }
      throw error;
    }
  }
  createDBInstance(params) {
    return this.makeRDSRequest("CreateDBInstance", params);
  }
  modifyDBInstance(dbInstanceIdentifier, params) {
    return this.makeRDSRequest("ModifyDBInstance", {
      DBInstanceIdentifier: dbInstanceIdentifier,
      ...params
    });
  }
  deleteDBInstance(dbInstanceIdentifier, skipFinalSnapshot = true, finalSnapshotId) {
    const params = {
      DBInstanceIdentifier: dbInstanceIdentifier,
      SkipFinalSnapshot: skipFinalSnapshot
    };
    if (!skipFinalSnapshot && finalSnapshotId) {
      params.FinalDBSnapshotIdentifier = finalSnapshotId;
    }
    this.makeRDSRequest("DeleteDBInstance", params);
  }
  waitForDBInstanceState(dbInstanceIdentifier, targetState, maxAttempts = 60) {
    for (let attempt = 0; attempt < maxAttempts; attempt++) {
      try {
        const response = this.checkDBInstanceExists(dbInstanceIdentifier);
        if (response?.DBInstance?.DBInstanceStatus === targetState) {
          return true;
        }
        if (response?.DBInstance?.DBInstanceStatus === "failed") {
          throw new Error(`DB instance ${dbInstanceIdentifier} is in failed state`);
        }
        const start = Date.now();
        while (Date.now() - start < 3e4) {
        }
      } catch (error) {
        if (attempt === maxAttempts - 1) {
          throw error;
        }
      }
    }
    return false;
  }
  // Security Group Management Methods
  makeEC2Request(action, params = {}) {
    const url = `https://ec2.${this.region}.amazonaws.com/`;
    const formParams = {
      "Action": action,
      "Version": "2016-11-15"
    };
    this.addParamsToFormData(formParams, params);
    const formBody = Object.entries(formParams).map(([key, value]) => `${encodeURIComponent(key)}=${encodeURIComponent(value)}`).join("&");
    const response = import_aws.default.post(url, {
      service: "ec2",
      region: this.region,
      headers: {
        "Content-Type": "application/x-www-form-urlencoded"
      },
      body: formBody
    });
    if (response.statusCode >= 400) {
      let errorMessage = `AWS EC2 API error: ${response.statusCode} ${response.status}`;
      try {
        const errorMatch = /<message>(.*?)<\/message>/i.exec(response.body);
        if (errorMatch) {
          errorMessage += ` - ${errorMatch[1]}`;
        }
        const codeMatch = /<code>(.*?)<\/code>/i.exec(response.body);
        if (codeMatch) {
          errorMessage += ` (${codeMatch[1]})`;
        }
      } catch (_parseError) {
        errorMessage += ` - Raw: ${response.body}`;
      }
      throw new Error(errorMessage);
    }
    if (action === "DescribeSecurityGroups" && params["GroupId.1"]) {
      import_cli.default.output(`[DEBUG] Raw XML response for security group ${params["GroupId.1"]}: ${response.body}`);
    }
    const parsedResponse = this.parseEC2Response(response.body);
    if (action === "DescribeSecurityGroups" && params["GroupId.1"]) {
      import_cli.default.output(`[DEBUG] Parsed response for SG ${params["GroupId.1"]}: ${JSON.stringify(parsedResponse, null, 2)}`);
      if (parsedResponse.SecurityGroups && parsedResponse.SecurityGroups.length > 0) {
        import_cli.default.output(`[DEBUG] First SG in parsed response: ${JSON.stringify(parsedResponse.SecurityGroups[0], null, 2)}`);
      }
    }
    return parsedResponse;
  }
  parseEC2Response(xmlBody) {
    const result = {};
    const groupIdMatch = /<groupId>(.*?)<\/groupId>/.exec(xmlBody);
    if (groupIdMatch) {
      result.GroupId = groupIdMatch[1];
    }
    const groupNameMatch = /<groupName>(.*?)<\/groupName>/.exec(xmlBody);
    if (groupNameMatch) {
      result.GroupName = groupNameMatch[1];
    }
    const descriptionMatch = /<groupDescription>(.*?)<\/groupDescription>/.exec(xmlBody);
    if (descriptionMatch) {
      result.Description = descriptionMatch[1];
    }
    const vpcIdMatch = /<vpcId>(.*?)<\/vpcId>/.exec(xmlBody);
    if (vpcIdMatch) {
      result.VpcId = vpcIdMatch[1];
    }
    const isDefaultMatch = /<isDefault>true<\/isDefault>/.exec(xmlBody);
    if (isDefaultMatch && vpcIdMatch) {
      result.IsDefault = true;
    }
    const securityGroupInfoMatch = /<securityGroupInfo>(.*?)<\/securityGroupInfo>/s.exec(xmlBody);
    if (securityGroupInfoMatch) {
      const securityGroupInfoXml = securityGroupInfoMatch[1];
      import_cli.default.output(`[DEBUG] securityGroupInfoXml: ${securityGroupInfoXml.substring(0, 500)}...`);
      const sgMatches = [];
      let currentIndex = 0;
      let itemStart = securityGroupInfoXml.indexOf("<item>", currentIndex);
      while (itemStart !== -1) {
        let depth = 1;
        let searchPos = itemStart + 6;
        let itemEnd = -1;
        while (depth > 0 && searchPos < securityGroupInfoXml.length) {
          const nextOpen = securityGroupInfoXml.indexOf("<item>", searchPos);
          const nextClose = securityGroupInfoXml.indexOf("</item>", searchPos);
          if (nextClose === -1) break;
          if (nextOpen !== -1 && nextOpen < nextClose) {
            depth++;
            searchPos = nextOpen + 6;
          } else {
            depth--;
            if (depth === 0) {
              itemEnd = nextClose + 7;
            }
            searchPos = nextClose + 7;
          }
        }
        if (itemEnd !== -1) {
          sgMatches.push(securityGroupInfoXml.substring(itemStart, itemEnd));
          currentIndex = itemEnd;
          itemStart = securityGroupInfoXml.indexOf("<item>", currentIndex);
        } else {
          break;
        }
      }
      import_cli.default.output(`[DEBUG] sgMatches count: ${sgMatches.length}`);
      if (sgMatches.length > 0) {
        result.SecurityGroups = [];
        sgMatches.forEach((sgItemXml) => {
          const sgContentMatch = /<item>(.*?)<\/item>/s.exec(sgItemXml);
          if (!sgContentMatch) return;
          const sgXml = sgContentMatch[1];
          const sgIdMatch = /<groupId>(.*?)<\/groupId>/.exec(sgXml);
          const sgNameMatch = /<groupName>(.*?)<\/groupName>/.exec(sgXml);
          if (sgIdMatch && sgNameMatch) {
            const vpcIdMatch2 = /<vpcId>(.*?)<\/vpcId>/.exec(sgXml);
            const securityGroup = {
              GroupId: sgIdMatch[1],
              GroupName: sgNameMatch[1],
              VpcId: vpcIdMatch2 ? vpcIdMatch2[1] : void 0
            };
            import_cli.default.output(`[DEBUG] Looking for ipPermissions in full sgItemXml: ${sgItemXml.substring(0, 200)}...`);
            const ipPermissionsMatch = /<ipPermissions>(.*?)<\/ipPermissions>/s.exec(sgItemXml);
            import_cli.default.output(`[DEBUG] ipPermissionsMatch found: ${ipPermissionsMatch ? "YES" : "NO"}`);
            if (ipPermissionsMatch) {
              const ipPermissionsXml = ipPermissionsMatch[1];
              import_cli.default.output(`[DEBUG] ipPermissionsXml: ${ipPermissionsXml.substring(0, 300)}`);
              const permissionItems = [];
              let currentIndex2 = 0;
              let itemStart2 = ipPermissionsXml.indexOf("<item>", currentIndex2);
              while (itemStart2 !== -1) {
                let depth = 1;
                let searchPos = itemStart2 + 6;
                let itemEnd = -1;
                while (depth > 0 && searchPos < ipPermissionsXml.length) {
                  const nextOpen = ipPermissionsXml.indexOf("<item>", searchPos);
                  const nextClose = ipPermissionsXml.indexOf("</item>", searchPos);
                  if (nextClose === -1) break;
                  if (nextOpen !== -1 && nextOpen < nextClose) {
                    depth++;
                    searchPos = nextOpen + 6;
                  } else {
                    depth--;
                    if (depth === 0) {
                      itemEnd = nextClose + 7;
                    }
                    searchPos = nextClose + 7;
                  }
                }
                if (itemEnd !== -1) {
                  permissionItems.push(ipPermissionsXml.substring(itemStart2, itemEnd));
                  currentIndex2 = itemEnd;
                  itemStart2 = ipPermissionsXml.indexOf("<item>", currentIndex2);
                } else {
                  break;
                }
              }
              import_cli.default.output(`[DEBUG] permissionItems count: ${permissionItems.length}`);
              if (permissionItems.length > 0) {
                securityGroup.IpPermissions = [];
                permissionItems.forEach((permXml) => {
                  const protocolMatch = /<ipProtocol>(.*?)<\/ipProtocol>/.exec(permXml);
                  const fromPortMatch = /<fromPort>(.*?)<\/fromPort>/.exec(permXml);
                  const toPortMatch = /<toPort>(.*?)<\/toPort>/.exec(permXml);
                  if (protocolMatch) {
                    const permission = {
                      IpProtocol: protocolMatch[1],
                      FromPort: fromPortMatch ? fromPortMatch[1] : null,
                      ToPort: toPortMatch ? toPortMatch[1] : null
                    };
                    const ipRangesMatch = /<ipRanges>(.*?)<\/ipRanges>/s.exec(permXml);
                    if (ipRangesMatch) {
                      const ipRangesXml = ipRangesMatch[1];
                      const ipRangeItems = ipRangesXml.match(/<item>.*?<\/item>/gs);
                      if (ipRangeItems) {
                        permission.IpRanges = [];
                        ipRangeItems.forEach((ipXml) => {
                          const cidrMatch = /<cidrIp>(.*?)<\/cidrIp>/.exec(ipXml);
                          if (cidrMatch) {
                            permission.IpRanges.push({ CidrIp: cidrMatch[1] });
                          }
                        });
                      }
                    }
                    import_cli.default.output(`[DEBUG] Looking for groups in permXml: ${permXml.substring(0, 200)}...`);
                    const groupsMatch = /<groups>(.*?)<\/groups>/s.exec(permXml);
                    import_cli.default.output(`[DEBUG] groupsMatch found: ${groupsMatch ? "YES" : "NO"}`);
                    if (groupsMatch) {
                      const groupsXml = groupsMatch[1];
                      import_cli.default.output(`[DEBUG] groupsXml: ${groupsXml.substring(0, 200)}`);
                      const groupItems = groupsXml.match(/<item>.*?<\/item>/gs);
                      import_cli.default.output(`[DEBUG] groupItems count: ${groupItems ? groupItems.length : 0}`);
                      if (groupItems) {
                        permission.UserIdGroupPairs = [];
                        groupItems.forEach((grpXml) => {
                          const grpIdMatch = /<groupId>(.*?)<\/groupId>/.exec(grpXml);
                          import_cli.default.output(`[DEBUG] grpXml: ${grpXml}, grpIdMatch: ${grpIdMatch ? grpIdMatch[1] : "NONE"}`);
                          if (grpIdMatch) {
                            permission.UserIdGroupPairs.push({ GroupId: grpIdMatch[1] });
                          }
                        });
                        import_cli.default.output(`[DEBUG] Final UserIdGroupPairs: ${JSON.stringify(permission.UserIdGroupPairs)}`);
                      }
                    }
                    securityGroup.IpPermissions.push(permission);
                  }
                });
              }
            }
            result.SecurityGroups.push(securityGroup);
          }
        });
      }
    }
    return result;
  }
  getDefaultVpc() {
    try {
      const response = this.makeEC2Request("DescribeVpcs", {
        "Filter.1.Name": "isDefault",
        "Filter.1.Value.1": "true"
      });
      if (response.VpcId && response.IsDefault) {
        console.log(`Found default VPC: ${response.VpcId}`);
        return response.VpcId;
      }
      console.log("No default VPC found");
      return null;
    } catch (error) {
      console.log(`Warning: Could not retrieve default VPC: ${error instanceof Error ? error.message : "Unknown error"}`);
      return null;
    }
  }
  resolveSecurityGroupNames(groupNames, vpcId) {
    import_cli.default.output(`[DEBUG] resolveSecurityGroupNames called with: groupNames=${JSON.stringify(groupNames)}, vpcId=${vpcId}`);
    if (groupNames.length === 0) {
      import_cli.default.output(`[DEBUG] No group names to resolve, returning empty array`);
      return [];
    }
    try {
      const params = {};
      params["Filter.1.Name"] = "group-name";
      groupNames.forEach((name, index) => {
        params[`Filter.1.Value.${index + 1}`] = name;
      });
      if (vpcId) {
        params["Filter.2.Name"] = "vpc-id";
        params["Filter.2.Value.1"] = vpcId;
        import_cli.default.output(`[DEBUG] Adding VPC filter: ${vpcId}`);
      } else {
        const defaultVpcId = this.getDefaultVpc();
        if (defaultVpcId) {
          params["Filter.2.Name"] = "vpc-id";
          params["Filter.2.Value.1"] = defaultVpcId;
          import_cli.default.output(`[DEBUG] Adding default VPC filter: ${defaultVpcId}`);
        } else {
          import_cli.default.output(`[DEBUG] No VPC filter - searching all VPCs`);
        }
      }
      import_cli.default.output(`[DEBUG] DescribeSecurityGroups parameters: ${JSON.stringify(params, null, 2)}`);
      const response = this.makeEC2Request("DescribeSecurityGroups", params);
      import_cli.default.output(`[DEBUG] DescribeSecurityGroups response: ${JSON.stringify(response, null, 2)}`);
      const sgIds = [];
      const sgMatches = response.SecurityGroups || [];
      if (Array.isArray(sgMatches)) {
        sgMatches.forEach((sg) => {
          if (sg.GroupId) {
            sgIds.push(sg.GroupId);
            import_cli.default.output(`[DEBUG] Found security group: ${sg.GroupName} -> ${sg.GroupId}`);
          }
        });
      } else {
        const xmlMatches = response.match ? response.match(/<groupId>(.*?)<\/groupId>/g) : [];
        if (xmlMatches) {
          xmlMatches.forEach((match) => {
            const idMatch = /<groupId>(.*?)<\/groupId>/.exec(match);
            if (idMatch) {
              sgIds.push(idMatch[1]);
              import_cli.default.output(`[DEBUG] Found security group ID from XML: ${idMatch[1]}`);
            }
          });
        } else {
          import_cli.default.output(`[DEBUG] No security groups found matching the criteria`);
        }
      }
      if (sgIds.length === 0 && (vpcId || this.getDefaultVpc())) {
        import_cli.default.output(`[DEBUG] No security groups found with VPC filter, trying without VPC filter...`);
        try {
          import_cli.default.output(`[DEBUG] Listing ALL security groups for reference...`);
          const allSgsResponse = this.makeEC2Request("DescribeSecurityGroups", {});
          if (allSgsResponse.SecurityGroups && Array.isArray(allSgsResponse.SecurityGroups)) {
            import_cli.default.output(`[DEBUG] Found ${allSgsResponse.SecurityGroups.length} total security groups:`);
            allSgsResponse.SecurityGroups.forEach((sg) => {
              import_cli.default.output(`[DEBUG]   - ${sg.GroupName} (${sg.GroupId}) in VPC: ${sg.VpcId}`);
            });
          } else {
            import_cli.default.output(`[DEBUG] No security groups found in account or parsing issue`);
          }
        } catch (listError) {
          import_cli.default.output(`[DEBUG] Failed to list all security groups: ${listError instanceof Error ? listError.message : "Unknown error"}`);
        }
        const noVpcParams = {};
        noVpcParams["Filter.1.Name"] = "group-name";
        groupNames.forEach((name, index) => {
          noVpcParams[`Filter.1.Value.${index + 1}`] = name;
        });
        import_cli.default.output(`[DEBUG] DescribeSecurityGroups parameters (no VPC): ${JSON.stringify(noVpcParams, null, 2)}`);
        const noVpcResponse = this.makeEC2Request("DescribeSecurityGroups", noVpcParams);
        import_cli.default.output(`[DEBUG] DescribeSecurityGroups response (no VPC): ${JSON.stringify(noVpcResponse, null, 2)}`);
        const noVpcMatches = noVpcResponse.SecurityGroups || [];
        if (Array.isArray(noVpcMatches)) {
          noVpcMatches.forEach((sg) => {
            if (sg.GroupId) {
              sgIds.push(sg.GroupId);
              import_cli.default.output(`[DEBUG] Found security group (no VPC filter): ${sg.GroupName} -> ${sg.GroupId} (VPC: ${sg.VpcId})`);
            }
          });
        }
      }
      if (sgIds.length !== groupNames.length) {
        const foundNames = sgIds.length;
        import_cli.default.output(`[DEBUG] Warning: Found ${foundNames} security groups out of ${groupNames.length} requested: ${JSON.stringify(groupNames)}`);
      }
      return sgIds;
    } catch (error) {
      throw new Error(`Failed to resolve security group names: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  createSecurityGroup(groupName, description, vpcId) {
    const params = {
      GroupName: groupName,
      GroupDescription: description
    };
    if (vpcId) {
      params.VpcId = vpcId;
    }
    const response = this.makeEC2Request("CreateSecurityGroup", params);
    if (!response.GroupId) {
      throw new Error("Failed to create security group: No GroupId in response");
    }
    return response.GroupId;
  }
  checkSecurityGroupExists(groupId) {
    try {
      this.makeEC2Request("DescribeSecurityGroups", {
        "GroupId.1": groupId
      });
      return true;
    } catch (error) {
      if (error instanceof Error && error.message.includes("InvalidGroupId.NotFound")) {
        return false;
      }
      throw error;
    }
  }
  findSecurityGroupByName(groupName, vpcId) {
    try {
      const params = {
        "Filter.1.Name": "group-name",
        "Filter.1.Value.1": groupName
      };
      const targetVpcId = vpcId || this.getDefaultVpc();
      if (targetVpcId) {
        params["Filter.2.Name"] = "vpc-id";
        params["Filter.2.Value.1"] = targetVpcId;
      }
      console.log(`Searching for security group '${groupName}' in VPC '${targetVpcId || "any"}'`);
      const response = this.makeEC2Request("DescribeSecurityGroups", params);
      if (response.SecurityGroups && response.SecurityGroups.length > 0) {
        const securityGroups = Array.isArray(response.SecurityGroups) ? response.SecurityGroups : [response.SecurityGroups];
        if (securityGroups.length > 0) {
          console.log(`Found existing security group: ${securityGroups[0].GroupId}`);
          return securityGroups[0].GroupId;
        }
      }
      console.log(`No security group found with name '${groupName}' in VPC '${targetVpcId || "any"}'`);
      return null;
    } catch (error) {
      console.log(`Error finding security group by name: ${error instanceof Error ? error.message : "Unknown error"}`);
      return null;
    }
  }
  authorizeSecurityGroupIngress(groupId, protocol, fromPort, toPort, cidrBlocks, sourceSecurityGroupIds = []) {
    import_cli.default.output(`[DEBUG] authorizeSecurityGroupIngress called with: groupId=${groupId}, protocol=${protocol}, fromPort=${fromPort}, toPort=${toPort}, cidrBlocks=${JSON.stringify(cidrBlocks)}, sourceSecurityGroupIds=${JSON.stringify(sourceSecurityGroupIds)}`);
    const params = {
      GroupId: groupId
    };
    let permissionIndex = 1;
    cidrBlocks.forEach((cidr) => {
      const permissionBase = `IpPermissions.${permissionIndex}`;
      params[`${permissionBase}.IpProtocol`] = protocol;
      params[`${permissionBase}.FromPort`] = fromPort.toString();
      params[`${permissionBase}.ToPort`] = toPort.toString();
      params[`${permissionBase}.IpRanges.1.CidrIp`] = cidr;
      permissionIndex++;
    });
    sourceSecurityGroupIds.forEach((sgId) => {
      const permissionBase = `IpPermissions.${permissionIndex}`;
      params[`${permissionBase}.IpProtocol`] = protocol;
      params[`${permissionBase}.FromPort`] = fromPort.toString();
      params[`${permissionBase}.ToPort`] = toPort.toString();
      params[`${permissionBase}.Groups.1.GroupId`] = sgId;
      permissionIndex++;
    });
    import_cli.default.output(`[DEBUG] AuthorizeSecurityGroupIngress parameters: ${JSON.stringify(params, null, 2)}`);
    try {
      this.makeEC2Request("AuthorizeSecurityGroupIngress", params);
      import_cli.default.output(`[DEBUG] AuthorizeSecurityGroupIngress completed successfully`);
    } catch (error) {
      if (error instanceof Error && !error.message.includes("InvalidPermission.Duplicate")) {
        import_cli.default.output(`[ERROR] AuthorizeSecurityGroupIngress failed: ${error.message}`);
        throw error;
      }
      import_cli.default.output(`[DEBUG] Some security group rules already exist, continuing...`);
    }
  }
  revokeSecurityGroupIngress(groupId, protocol, fromPort, toPort, cidrBlocks, sourceSecurityGroupIds = []) {
    import_cli.default.output(`[DEBUG] revokeSecurityGroupIngress called with: groupId=${groupId}, protocol=${protocol}, fromPort=${fromPort}, toPort=${toPort}, cidrBlocks=${JSON.stringify(cidrBlocks)}, sourceSecurityGroupIds=${JSON.stringify(sourceSecurityGroupIds)}`);
    const params = {
      GroupId: groupId
    };
    let permissionIndex = 1;
    cidrBlocks.forEach((cidr) => {
      const permissionBase = `IpPermissions.${permissionIndex}`;
      params[`${permissionBase}.IpProtocol`] = protocol;
      params[`${permissionBase}.FromPort`] = fromPort.toString();
      params[`${permissionBase}.ToPort`] = toPort.toString();
      params[`${permissionBase}.IpRanges.1.CidrIp`] = cidr;
      permissionIndex++;
    });
    sourceSecurityGroupIds.forEach((sgId) => {
      const permissionBase = `IpPermissions.${permissionIndex}`;
      params[`${permissionBase}.IpProtocol`] = protocol;
      params[`${permissionBase}.FromPort`] = fromPort.toString();
      params[`${permissionBase}.ToPort`] = toPort.toString();
      params[`${permissionBase}.Groups.1.GroupId`] = sgId;
      permissionIndex++;
    });
    import_cli.default.output(`[DEBUG] RevokeSecurityGroupIngress parameters: ${JSON.stringify(params, null, 2)}`);
    try {
      this.makeEC2Request("RevokeSecurityGroupIngress", params);
      import_cli.default.output(`[DEBUG] RevokeSecurityGroupIngress completed successfully`);
    } catch (error) {
      if (error instanceof Error && !error.message.includes("InvalidPermission.NotFound")) {
        import_cli.default.output(`[ERROR] RevokeSecurityGroupIngress failed: ${error.message}`);
        throw error;
      }
      import_cli.default.output(`[DEBUG] Some security group rules already removed, continuing...`);
    }
  }
  updateSecurityGroupRules() {
    if (!this.state.created_security_group_id || this.state.created_security_group_existing) {
      import_cli.default.output("[DEBUG] Skipping security group rules update - not an auto-created security group");
      return;
    }
    const groupId = this.state.created_security_group_id;
    const port = this.definition.port || this.getDefaultPortForEngine(this.definition.engine);
    const allowedCidrs = this.definition.allowed_cidr_blocks || [];
    const allowedSgNames = this.definition.allowed_security_group_names || [];
    import_cli.default.output(`[DEBUG] Current definition: allowedCidrs=${JSON.stringify(allowedCidrs)}, allowedSgNames=${JSON.stringify(allowedSgNames)}, port=${port}`);
    import_cli.default.output(`[DEBUG] Updating security group rules for ${groupId} using API-only approach`);
    try {
      const currentAwsRules = this.getCurrentSecurityGroupRules(groupId, port);
      import_cli.default.output(`[DEBUG] Attempting to resolve security group names: ${JSON.stringify(allowedSgNames)}`);
      const allowedSgIds = allowedSgNames.length > 0 ? this.resolveSecurityGroupNames([...allowedSgNames], this.definition.vpc_id) : [];
      import_cli.default.output(`[DEBUG] Resolved security group IDs: ${JSON.stringify(allowedSgIds)}`);
      const cidrsToAdd = allowedCidrs.filter((cidr) => !currentAwsRules.cidrs.includes(cidr));
      const cidrsToRemove = currentAwsRules.cidrs.filter((cidr) => !allowedCidrs.includes(cidr));
      const sgIdsToAdd = allowedSgIds.filter((sgId) => !currentAwsRules.sgIds.includes(sgId));
      const sgIdsToRemove = currentAwsRules.sgIds.filter((sgId) => !allowedSgIds.includes(sgId));
      import_cli.default.output(`[DEBUG] Rules to add - CIDRs: ${JSON.stringify(cidrsToAdd)}, SG IDs: ${JSON.stringify(sgIdsToAdd)}`);
      import_cli.default.output(`[DEBUG] Rules to remove - CIDRs: ${JSON.stringify(cidrsToRemove)}, SG IDs: ${JSON.stringify(sgIdsToRemove)}`);
      if (cidrsToAdd.length === 0 && cidrsToRemove.length === 0 && sgIdsToAdd.length === 0 && sgIdsToRemove.length === 0) {
        import_cli.default.output(`[DEBUG] No security group rule changes needed for ${groupId}`);
        return;
      }
      if (cidrsToRemove.length > 0 || sgIdsToRemove.length > 0) {
        import_cli.default.output(`[DEBUG] Removing security group rules: CIDRs=${cidrsToRemove}, SGs=${sgIdsToRemove}`);
        this.revokeSecurityGroupIngress(groupId, "tcp", port, port, cidrsToRemove, sgIdsToRemove);
      }
      if (cidrsToAdd.length > 0 || sgIdsToAdd.length > 0) {
        import_cli.default.output(`[DEBUG] Adding security group rules: CIDRs=${JSON.stringify(cidrsToAdd)}, SGs=${JSON.stringify(sgIdsToAdd)}`);
        import_cli.default.output(`[DEBUG] Port: ${port}, Protocol: tcp`);
        this.authorizeSecurityGroupIngress(groupId, "tcp", port, port, cidrsToAdd, sgIdsToAdd);
        import_cli.default.output(`[DEBUG] Successfully added security group rules`);
      }
      import_cli.default.output(`[DEBUG] Security group rules updated successfully for ${groupId}`);
    } catch (error) {
      throw new Error(`Failed to update security group rules: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  getCurrentSecurityGroupRules(groupId, port) {
    try {
      import_cli.default.output(`[DEBUG] Querying current AWS security group rules for ${groupId}`);
      const response = this.makeEC2Request("DescribeSecurityGroups", {
        "GroupId.1": groupId
      });
      import_cli.default.output(`[DEBUG] getCurrentSecurityGroupRules - AWS response: ${JSON.stringify(response, null, 2)}`);
      const actualCidrs = [];
      const actualSgIds = [];
      if (response.SecurityGroups && response.SecurityGroups.length > 0) {
        const securityGroup = response.SecurityGroups[0];
        import_cli.default.output(`[DEBUG] Security group for rule parsing: ${JSON.stringify(securityGroup, null, 2)}`);
        if (securityGroup.IpPermissions) {
          const permissions = Array.isArray(securityGroup.IpPermissions) ? securityGroup.IpPermissions : [securityGroup.IpPermissions];
          permissions.forEach((permission) => {
            if (permission.IpProtocol === "tcp" && parseInt(permission.FromPort) === port && parseInt(permission.ToPort) === port) {
              if (permission.IpRanges) {
                const ipRanges = Array.isArray(permission.IpRanges) ? permission.IpRanges : [permission.IpRanges];
                ipRanges.forEach((range) => {
                  if (range.CidrIp) {
                    actualCidrs.push(range.CidrIp);
                  }
                });
              }
              if (permission.UserIdGroupPairs) {
                const groups = Array.isArray(permission.UserIdGroupPairs) ? permission.UserIdGroupPairs : [permission.UserIdGroupPairs];
                groups.forEach((group) => {
                  if (group.GroupId) {
                    actualSgIds.push(group.GroupId);
                  }
                });
              }
            }
          });
        }
      }
      import_cli.default.output(`[DEBUG] Current AWS rules - CIDRs: ${actualCidrs}, SG IDs: ${actualSgIds}`);
      return { cidrs: actualCidrs, sgIds: actualSgIds };
    } catch (error) {
      import_cli.default.output(`[DEBUG] Warning: Could not query current security group rules: ${error instanceof Error ? error.message : "Unknown error"}`);
      return { cidrs: [], sgIds: [] };
    }
  }
  deleteSecurityGroup(groupId) {
    this.makeEC2Request("DeleteSecurityGroup", {
      GroupId: groupId
    });
  }
  getOrCreateSecurityGroup() {
    if (this.definition.vpc_security_group_ids?.length) {
      return [...this.definition.vpc_security_group_ids];
    }
    if (this.definition.auto_create_security_group === false) {
      return [];
    }
    const dbInstanceIdentifier = this.getDBInstanceIdentifier();
    const groupName = this.definition.security_group_name || `${dbInstanceIdentifier}-sg`;
    const description = this.definition.security_group_description || `Security group for RDS instance ${dbInstanceIdentifier}`;
    const port = this.definition.port || this.getDefaultPortForEngine(this.definition.engine);
    const allowedCidrs = this.definition.allowed_cidr_blocks || [];
    const allowedSgNames = this.definition.allowed_security_group_names || [];
    if (allowedCidrs.length === 0 && allowedSgNames.length === 0) {
      throw new Error("Security group auto-creation requires either allowed_cidr_blocks or allowed_security_group_names to be specified for security");
    }
    if (this.state.created_security_group_id) {
      if (this.checkSecurityGroupExists(this.state.created_security_group_id)) {
        return [this.state.created_security_group_id];
      } else {
        this.state.created_security_group_id = void 0;
        this.state.created_security_group_existing = false;
      }
    }
    try {
      const vpcId = this.definition.vpc_id;
      let groupId = this.findSecurityGroupByName(groupName, vpcId);
      let isExisting = false;
      if (groupId) {
        import_cli.default.output(`[DEBUG] Found existing security group ${groupId} with name '${groupName}' for RDS instance ${dbInstanceIdentifier}`);
        isExisting = true;
      } else {
        groupId = this.createSecurityGroup(groupName, description, vpcId);
        import_cli.default.output(`[DEBUG] Created new security group ${groupId} for RDS instance ${dbInstanceIdentifier}`);
      }
      const allowedSgIds = allowedSgNames.length > 0 ? this.resolveSecurityGroupNames([...allowedSgNames], vpcId) : [];
      if (!isExisting) {
        this.authorizeSecurityGroupIngress(groupId, "tcp", port, port, [...allowedCidrs], allowedSgIds);
      } else {
        import_cli.default.output(`[DEBUG] Using existing security group ${groupId}, skipping rule creation`);
      }
      this.state.created_security_group_id = groupId;
      this.state.created_security_group_existing = isExisting;
      return [groupId];
    } catch (error) {
      throw new Error(`Failed to create or find security group: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  getDefaultPortForEngine(engine) {
    const portMap = {
      "mysql": 3306,
      "postgres": 5432,
      "mariadb": 3306,
      "oracle-ee": 1521,
      "oracle-se2": 1521,
      "sqlserver-ex": 1433,
      "sqlserver-web": 1433,
      "sqlserver-se": 1433,
      "sqlserver-ee": 1433
    };
    return portMap[engine.toLowerCase()] || 3306;
  }
  cleanupCreatedSecurityGroup() {
    if (this.state.created_security_group_id && !this.state.created_security_group_existing) {
      try {
        console.log(`Deleting created security group: ${this.state.created_security_group_id}`);
        this.deleteSecurityGroup(this.state.created_security_group_id);
        this.state.created_security_group_id = void 0;
        this.state.created_security_group_existing = false;
      } catch (error) {
        console.log(`Warning: Could not delete security group ${this.state.created_security_group_id}: ${error instanceof Error ? error.message : "Unknown error"}`);
      }
    }
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  AWSRDSEntity
});
