// Generated by MonkEC - targeting Goja runtime
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);

// input/aws-rds/base.ts
var base_exports = {};
__export(base_exports, {
  AWSRDSEntity: () => AWSRDSEntity
});
module.exports = __toCommonJS(base_exports);
var import_base = require("monkec/base");
var import_aws2 = __toESM(require("cloud/aws"));

// input/aws-rds/common.ts
var import_aws = __toESM(require("cloud/aws"));
function addParamsToFormData(formParams, params, prefix = "") {
  for (const [key, value] of Object.entries(params)) {
    const paramKey = prefix ? `${prefix}.${key}` : key;
    if (value === null || value === void 0) {
      continue;
    }
    if (Array.isArray(value)) {
      value.forEach((item, index) => {
        if (typeof item === "object") {
          addParamsToFormData(formParams, item, `${paramKey}.member.${index + 1}`);
        } else {
          formParams[`${paramKey}.member.${index + 1}`] = String(item);
        }
      });
    } else if (typeof value === "object") {
      addParamsToFormData(formParams, value, paramKey);
    } else {
      formParams[paramKey] = String(value);
    }
  }
}
function makeEC2Request(region, action, params = {}) {
  const url = `https://ec2.${region}.amazonaws.com/`;
  const formParams = {
    "Action": action,
    "Version": "2016-11-15"
  };
  addParamsToFormData(formParams, params);
  const formBody = Object.entries(formParams).map(([key, value]) => `${encodeURIComponent(key)}=${encodeURIComponent(value)}`).join("&");
  const response = import_aws.default.post(url, {
    service: "ec2",
    region,
    headers: {
      "Content-Type": "application/x-www-form-urlencoded"
    },
    body: formBody
  });
  if (response.statusCode >= 400) {
    let errorMessage = `AWS EC2 API error: ${response.statusCode} ${response.status}`;
    try {
      const errorMatch = /<message>(.*?)<\/message>/i.exec(response.body);
      if (errorMatch) {
        errorMessage += ` - ${errorMatch[1]}`;
      }
      const codeMatch = /<code>(.*?)<\/code>/i.exec(response.body);
      if (codeMatch) {
        errorMessage += ` (${codeMatch[1]})`;
      }
    } catch (_parseError) {
      errorMessage += ` - Raw: ${response.body}`;
    }
    throw new Error(errorMessage);
  }
  const parsedResponse = parseEC2Response(response.body);
  return parsedResponse;
}
function parseEC2Response(xmlBody) {
  const result = {};
  const groupIdMatch = /<groupId>(.*?)<\/groupId>/.exec(xmlBody);
  if (groupIdMatch) {
    result.GroupId = groupIdMatch[1];
  }
  const groupNameMatch = /<groupName>(.*?)<\/groupName>/.exec(xmlBody);
  if (groupNameMatch) {
    result.GroupName = groupNameMatch[1];
  }
  const descriptionMatch = /<groupDescription>(.*?)<\/groupDescription>/.exec(xmlBody);
  if (descriptionMatch) {
    result.Description = descriptionMatch[1];
  }
  const vpcIdMatch = /<vpcId>(.*?)<\/vpcId>/.exec(xmlBody);
  if (vpcIdMatch) {
    result.VpcId = vpcIdMatch[1];
  }
  const isDefaultMatch = /<isDefault>true<\/isDefault>/.exec(xmlBody);
  if (isDefaultMatch && vpcIdMatch) {
    result.IsDefault = true;
  }
  const securityGroupInfoMatch = /<securityGroupInfo>(.*?)<\/securityGroupInfo>/s.exec(xmlBody);
  if (securityGroupInfoMatch) {
    const securityGroupInfoXml = securityGroupInfoMatch[1];
    const sgMatches = [];
    let currentIndex = 0;
    let itemStart = securityGroupInfoXml.indexOf("<item>", currentIndex);
    while (itemStart !== -1) {
      let depth = 1;
      let searchPos = itemStart + 6;
      let itemEnd = -1;
      while (depth > 0 && searchPos < securityGroupInfoXml.length) {
        const nextOpen = securityGroupInfoXml.indexOf("<item>", searchPos);
        const nextClose = securityGroupInfoXml.indexOf("</item>", searchPos);
        if (nextClose === -1) break;
        if (nextOpen !== -1 && nextOpen < nextClose) {
          depth++;
          searchPos = nextOpen + 6;
        } else {
          depth--;
          if (depth === 0) {
            itemEnd = nextClose + 7;
          }
          searchPos = nextClose + 7;
        }
      }
      if (itemEnd !== -1) {
        sgMatches.push(securityGroupInfoXml.substring(itemStart, itemEnd));
        currentIndex = itemEnd;
        itemStart = securityGroupInfoXml.indexOf("<item>", currentIndex);
      } else {
        break;
      }
    }
    if (sgMatches.length > 0) {
      result.SecurityGroups = [];
      sgMatches.forEach((sgItemXml) => {
        const sgContentMatch = /<item>(.*?)<\/item>/s.exec(sgItemXml);
        if (!sgContentMatch) return;
        const sgXml = sgContentMatch[1];
        const sgIdMatch = /<groupId>(.*?)<\/groupId>/.exec(sgXml);
        const sgNameMatch = /<groupName>(.*?)<\/groupName>/.exec(sgXml);
        if (sgIdMatch && sgNameMatch) {
          const vpcIdMatch2 = /<vpcId>(.*?)<\/vpcId>/.exec(sgXml);
          const securityGroup = {
            GroupId: sgIdMatch[1],
            GroupName: sgNameMatch[1],
            VpcId: vpcIdMatch2 ? vpcIdMatch2[1] : void 0
          };
          const ipPermissionsMatch = /<ipPermissions>(.*?)<\/ipPermissions>/s.exec(sgItemXml);
          if (ipPermissionsMatch) {
            const ipPermissionsXml = ipPermissionsMatch[1];
            const permissionItems = [];
            let currentIndex2 = 0;
            let itemStart2 = ipPermissionsXml.indexOf("<item>", currentIndex2);
            while (itemStart2 !== -1) {
              let depth = 1;
              let searchPos = itemStart2 + 6;
              let itemEnd = -1;
              while (depth > 0 && searchPos < ipPermissionsXml.length) {
                const nextOpen = ipPermissionsXml.indexOf("<item>", searchPos);
                const nextClose = ipPermissionsXml.indexOf("</item>", searchPos);
                if (nextClose === -1) break;
                if (nextOpen !== -1 && nextOpen < nextClose) {
                  depth++;
                  searchPos = nextOpen + 6;
                } else {
                  depth--;
                  if (depth === 0) {
                    itemEnd = nextClose + 7;
                  }
                  searchPos = nextClose + 7;
                }
              }
              if (itemEnd !== -1) {
                permissionItems.push(ipPermissionsXml.substring(itemStart2, itemEnd));
                currentIndex2 = itemEnd;
                itemStart2 = ipPermissionsXml.indexOf("<item>", currentIndex2);
              } else {
                break;
              }
            }
            if (permissionItems.length > 0) {
              securityGroup.IpPermissions = [];
              permissionItems.forEach((permXml) => {
                const protocolMatch = /<ipProtocol>(.*?)<\/ipProtocol>/.exec(permXml);
                const fromPortMatch = /<fromPort>(.*?)<\/fromPort>/.exec(permXml);
                const toPortMatch = /<toPort>(.*?)<\/toPort>/.exec(permXml);
                if (protocolMatch) {
                  const permission = {
                    IpProtocol: protocolMatch[1],
                    FromPort: fromPortMatch ? fromPortMatch[1] : null,
                    ToPort: toPortMatch ? toPortMatch[1] : null
                  };
                  const ipRangesMatch = /<ipRanges>(.*?)<\/ipRanges>/s.exec(permXml);
                  if (ipRangesMatch) {
                    const ipRangesXml = ipRangesMatch[1];
                    const ipRangeItems = ipRangesXml.match(/<item>.*?<\/item>/gs);
                    if (ipRangeItems) {
                      permission.IpRanges = [];
                      ipRangeItems.forEach((ipXml) => {
                        const cidrMatch = /<cidrIp>(.*?)<\/cidrIp>/.exec(ipXml);
                        if (cidrMatch) {
                          permission.IpRanges.push({ CidrIp: cidrMatch[1] });
                        }
                      });
                    }
                  }
                  const groupsMatch = /<groups>(.*?)<\/groups>/s.exec(permXml);
                  if (groupsMatch) {
                    const groupsXml = groupsMatch[1];
                    const groupItems = groupsXml.match(/<item>.*?<\/item>/gs);
                    if (groupItems) {
                      permission.UserIdGroupPairs = [];
                      groupItems.forEach((grpXml) => {
                        const grpIdMatch = /<groupId>(.*?)<\/groupId>/.exec(grpXml);
                        if (grpIdMatch) {
                          permission.UserIdGroupPairs.push({ GroupId: grpIdMatch[1] });
                        }
                      });
                    }
                  }
                  securityGroup.IpPermissions.push(permission);
                }
              });
            }
          }
          result.SecurityGroups.push(securityGroup);
        }
      });
    }
  }
  return result;
}

// input/aws-rds/securityGroup.ts
var import_cli = __toESM(require("cli"));
function normalizeToCidr(ipOrCidr) {
  if (ipOrCidr.includes("/")) {
    return ipOrCidr;
  }
  const ipPattern = /^(\d{1,3}\.){3}\d{1,3}$/;
  if (ipPattern.test(ipOrCidr)) {
    return `${ipOrCidr}/32`;
  }
  return ipOrCidr;
}
function normalizeCidrArray(ipAddresses) {
  return ipAddresses.map((ip) => normalizeToCidr(ip.trim()));
}
function getDefaultVpc(region) {
  try {
    const response = makeEC2Request(region, "DescribeVpcs", {
      "Filter.1.Name": "isDefault",
      "Filter.1.Value.1": "true"
    });
    if (response.VpcId && response.IsDefault) {
      return response.VpcId;
    }
    return null;
  } catch (error) {
    console.log(`Warning: Could not retrieve default VPC: ${error instanceof Error ? error.message : "Unknown error"}`);
    return null;
  }
}
function resolveSecurityGroupNames(region, groupNames, vpcId) {
  if (groupNames.length === 0) {
    return [];
  }
  try {
    const params = {};
    params["Filter.1.Name"] = "group-name";
    groupNames.forEach((name, index) => {
      params[`Filter.1.Value.${index + 1}`] = name;
    });
    if (vpcId) {
      params["Filter.2.Name"] = "vpc-id";
      params["Filter.2.Value.1"] = vpcId;
    } else {
      const defaultVpcId = getDefaultVpc(region);
      if (defaultVpcId) {
        params["Filter.2.Name"] = "vpc-id";
        params["Filter.2.Value.1"] = defaultVpcId;
      } else {
      }
    }
    const response = makeEC2Request(region, "DescribeSecurityGroups", params);
    const sgIds = [];
    const sgMatches = response.SecurityGroups || [];
    if (Array.isArray(sgMatches)) {
      sgMatches.forEach((sg) => {
        if (sg.GroupId) {
          sgIds.push(sg.GroupId);
        }
      });
    } else {
      const xmlMatches = response.match ? response.match(/<groupId>(.*?)<\/groupId>/g) : [];
      if (xmlMatches) {
        xmlMatches.forEach((match) => {
          const idMatch = /<groupId>(.*?)<\/groupId>/.exec(match);
          if (idMatch) {
            sgIds.push(idMatch[1]);
          }
        });
      } else {
      }
    }
    if (sgIds.length === 0 && (vpcId || getDefaultVpc(region))) {
      try {
        const allSgsResponse = makeEC2Request(region, "DescribeSecurityGroups", {});
        if (allSgsResponse.SecurityGroups && Array.isArray(allSgsResponse.SecurityGroups)) {
        } else {
        }
      } catch (_listError) {
      }
      const noVpcParams = {};
      noVpcParams["Filter.1.Name"] = "group-name";
      groupNames.forEach((name, index) => {
        noVpcParams[`Filter.1.Value.${index + 1}`] = name;
      });
      const noVpcResponse = makeEC2Request(region, "DescribeSecurityGroups", noVpcParams);
      const noVpcMatches = noVpcResponse.SecurityGroups || [];
      if (Array.isArray(noVpcMatches)) {
        noVpcMatches.forEach((sg) => {
          if (sg.GroupId) {
            sgIds.push(sg.GroupId);
          }
        });
      }
    }
    return sgIds;
  } catch (error) {
    throw new Error(`Failed to resolve security group names: ${error instanceof Error ? error.message : "Unknown error"}`);
  }
}
function createSecurityGroup(region, groupName, description, vpcId) {
  const params = {
    GroupName: groupName,
    GroupDescription: description
  };
  if (vpcId) {
    params.VpcId = vpcId;
  }
  const response = makeEC2Request(region, "CreateSecurityGroup", params);
  if (!response.GroupId) {
    throw new Error("Failed to create security group: No GroupId in response");
  }
  return response.GroupId;
}
function checkSecurityGroupExists(region, groupId) {
  try {
    makeEC2Request(region, "DescribeSecurityGroups", {
      "GroupId.1": groupId
    });
    return true;
  } catch (error) {
    if (error instanceof Error && error.message.includes("InvalidGroupId.NotFound")) {
      return false;
    }
    throw error;
  }
}
function findSecurityGroupByName(region, groupName, vpcId) {
  try {
    const params = {
      "Filter.1.Name": "group-name",
      "Filter.1.Value.1": groupName
    };
    const targetVpcId = vpcId || getDefaultVpc(region);
    if (targetVpcId) {
      params["Filter.2.Name"] = "vpc-id";
      params["Filter.2.Value.1"] = targetVpcId;
    }
    const response = makeEC2Request(region, "DescribeSecurityGroups", params);
    if (response.SecurityGroups && response.SecurityGroups.length > 0) {
      const securityGroups = Array.isArray(response.SecurityGroups) ? response.SecurityGroups : [response.SecurityGroups];
      if (securityGroups.length > 0) {
        return securityGroups[0].GroupId;
      }
    }
    return null;
  } catch (error) {
    console.log(`Error finding security group by name: ${error instanceof Error ? error.message : "Unknown error"}`);
    return null;
  }
}
function authorizeSecurityGroupIngress(region, groupId, protocol, fromPort, toPort, cidrBlocks, sourceSecurityGroupIds = []) {
  const normalizedCidrs = normalizeCidrArray(cidrBlocks);
  const params = {
    GroupId: groupId
  };
  let permissionIndex = 1;
  normalizedCidrs.forEach((cidr) => {
    const permissionBase = `IpPermissions.${permissionIndex}`;
    params[`${permissionBase}.IpProtocol`] = protocol;
    params[`${permissionBase}.FromPort`] = fromPort.toString();
    params[`${permissionBase}.ToPort`] = toPort.toString();
    params[`${permissionBase}.IpRanges.1.CidrIp`] = cidr;
    permissionIndex++;
  });
  sourceSecurityGroupIds.forEach((sgId) => {
    const permissionBase = `IpPermissions.${permissionIndex}`;
    params[`${permissionBase}.IpProtocol`] = protocol;
    params[`${permissionBase}.FromPort`] = fromPort.toString();
    params[`${permissionBase}.ToPort`] = toPort.toString();
    params[`${permissionBase}.Groups.1.GroupId`] = sgId;
    permissionIndex++;
  });
  try {
    makeEC2Request(region, "AuthorizeSecurityGroupIngress", params);
  } catch (error) {
    if (error instanceof Error && !error.message.includes("InvalidPermission.Duplicate")) {
      import_cli.default.output(`[ERROR] AuthorizeSecurityGroupIngress failed: ${error.message}`);
      throw error;
    }
  }
}
function revokeSecurityGroupIngress(region, groupId, protocol, fromPort, toPort, cidrBlocks, sourceSecurityGroupIds = []) {
  const normalizedCidrs = normalizeCidrArray(cidrBlocks);
  const params = {
    GroupId: groupId
  };
  let permissionIndex = 1;
  normalizedCidrs.forEach((cidr) => {
    const permissionBase = `IpPermissions.${permissionIndex}`;
    params[`${permissionBase}.IpProtocol`] = protocol;
    params[`${permissionBase}.FromPort`] = fromPort.toString();
    params[`${permissionBase}.ToPort`] = toPort.toString();
    params[`${permissionBase}.IpRanges.1.CidrIp`] = cidr;
    permissionIndex++;
  });
  sourceSecurityGroupIds.forEach((sgId) => {
    const permissionBase = `IpPermissions.${permissionIndex}`;
    params[`${permissionBase}.IpProtocol`] = protocol;
    params[`${permissionBase}.FromPort`] = fromPort.toString();
    params[`${permissionBase}.ToPort`] = toPort.toString();
    params[`${permissionBase}.Groups.1.GroupId`] = sgId;
    permissionIndex++;
  });
  try {
    makeEC2Request(region, "RevokeSecurityGroupIngress", params);
  } catch (error) {
    if (error instanceof Error && !error.message.includes("InvalidPermission.NotFound")) {
      import_cli.default.output(`[ERROR] RevokeSecurityGroupIngress failed: ${error.message}`);
      throw error;
    }
  }
}
function updateSecurityGroupRules(region, groupId, port, allowedCidrs, allowedSgNames, vpcId) {
  try {
    const normalizedCidrs = normalizeCidrArray(allowedCidrs);
    const currentAwsRules = getCurrentSecurityGroupRules(region, groupId, port);
    const allowedSgIds = allowedSgNames.length > 0 ? resolveSecurityGroupNames(region, [...allowedSgNames], vpcId) : [];
    const cidrsToAdd = normalizedCidrs.filter((cidr) => !currentAwsRules.cidrs.includes(cidr));
    const cidrsToRemove = currentAwsRules.cidrs.filter((cidr) => !normalizedCidrs.includes(cidr));
    const sgIdsToAdd = allowedSgIds.filter((sgId) => !currentAwsRules.sgIds.includes(sgId));
    const sgIdsToRemove = currentAwsRules.sgIds.filter((sgId) => !allowedSgIds.includes(sgId));
    if (cidrsToAdd.length === 0 && cidrsToRemove.length === 0 && sgIdsToAdd.length === 0 && sgIdsToRemove.length === 0) {
      return;
    }
    if (cidrsToRemove.length > 0 || sgIdsToRemove.length > 0) {
      revokeSecurityGroupIngress(region, groupId, "tcp", port, port, cidrsToRemove, sgIdsToRemove);
    }
    if (cidrsToAdd.length > 0 || sgIdsToAdd.length > 0) {
      authorizeSecurityGroupIngress(region, groupId, "tcp", port, port, cidrsToAdd, sgIdsToAdd);
    }
  } catch (error) {
    throw new Error(`Failed to update security group rules: ${error instanceof Error ? error.message : "Unknown error"}`);
  }
}
function getCurrentSecurityGroupRules(region, groupId, port) {
  try {
    const response = makeEC2Request(region, "DescribeSecurityGroups", {
      "GroupId.1": groupId
    });
    const actualCidrs = [];
    const actualSgIds = [];
    if (response.SecurityGroups && response.SecurityGroups.length > 0) {
      const securityGroup = response.SecurityGroups[0];
      if (securityGroup.IpPermissions) {
        const permissions = Array.isArray(securityGroup.IpPermissions) ? securityGroup.IpPermissions : [securityGroup.IpPermissions];
        permissions.forEach((permission) => {
          if (permission.IpProtocol === "tcp" && parseInt(permission.FromPort) === port && parseInt(permission.ToPort) === port) {
            if (permission.IpRanges) {
              const ipRanges = Array.isArray(permission.IpRanges) ? permission.IpRanges : [permission.IpRanges];
              ipRanges.forEach((range) => {
                if (range.CidrIp) {
                  actualCidrs.push(range.CidrIp);
                }
              });
            }
            if (permission.UserIdGroupPairs) {
              const groups = Array.isArray(permission.UserIdGroupPairs) ? permission.UserIdGroupPairs : [permission.UserIdGroupPairs];
              groups.forEach((group) => {
                if (group.GroupId) {
                  actualSgIds.push(group.GroupId);
                }
              });
            }
          }
        });
      }
    }
    return { cidrs: actualCidrs, sgIds: actualSgIds };
  } catch (error) {
    return { cidrs: [], sgIds: [] };
  }
}
function deleteSecurityGroup(region, groupId) {
  makeEC2Request(region, "DeleteSecurityGroup", {
    GroupId: groupId
  });
}

// input/aws-rds/base.ts
var import_cli2 = __toESM(require("cli"));
var AWSRDSEntity = class extends import_base.MonkEntity {
  constructor() {
    super(...arguments);
    __publicField(this, "region");
  }
  before() {
    this.region = this.definition.region;
  }
  makeRDSRequest(action, params = {}) {
    const url = `https://rds.${this.region}.amazonaws.com/`;
    const formParams = {
      "Action": action,
      "Version": "2014-10-31"
    };
    addParamsToFormData(formParams, params);
    const formBody = Object.entries(formParams).map(([key, value]) => `${encodeURIComponent(key)}=${encodeURIComponent(value)}`).join("&");
    const response = import_aws2.default.post(url, {
      service: "rds",
      region: this.region,
      headers: {
        "Content-Type": "application/x-www-form-urlencoded"
      },
      body: formBody
    });
    if (response.statusCode >= 400) {
      let errorMessage = `AWS RDS API error: ${response.statusCode} ${response.status}`;
      try {
        const errorMatch = /<Message>(.*?)<\/Message>/.exec(response.body);
        if (errorMatch) {
          errorMessage += ` - ${errorMatch[1]}`;
        }
        const codeMatch = /<Code>(.*?)<\/Code>/.exec(response.body);
        if (codeMatch) {
          errorMessage += ` (${codeMatch[1]})`;
        }
      } catch (_parseError) {
        errorMessage += ` - Raw: ${response.body}`;
      }
      throw new Error(errorMessage);
    }
    return this.parseRDSResponse(response.body);
  }
  parseRDSResponse(xmlBody) {
    const dbInstance = {};
    const identifierMatch = /<DBInstanceIdentifier>(.*?)<\/DBInstanceIdentifier>/.exec(xmlBody);
    if (identifierMatch) dbInstance.DBInstanceIdentifier = identifierMatch[1];
    const classMatch = /<DBInstanceClass>(.*?)<\/DBInstanceClass>/.exec(xmlBody);
    if (classMatch) dbInstance.DBInstanceClass = classMatch[1];
    const engineMatch = /<Engine>(.*?)<\/Engine>/.exec(xmlBody);
    if (engineMatch) dbInstance.Engine = engineMatch[1];
    const statusMatch = /<DBInstanceStatus>(.*?)<\/DBInstanceStatus>/.exec(xmlBody);
    if (statusMatch) {
      dbInstance.DBInstanceStatus = statusMatch[1];
    }
    const usernameMatch = /<MasterUsername>(.*?)<\/MasterUsername>/.exec(xmlBody);
    if (usernameMatch) dbInstance.MasterUsername = usernameMatch[1];
    const storageMatch = /<AllocatedStorage>(.*?)<\/AllocatedStorage>/.exec(xmlBody);
    if (storageMatch) dbInstance.AllocatedStorage = parseInt(storageMatch[1]);
    const engineVersionMatch = /<EngineVersion>(.*?)<\/EngineVersion>/.exec(xmlBody);
    if (engineVersionMatch) dbInstance.EngineVersion = engineVersionMatch[1];
    const createTimeMatch = /<InstanceCreateTime>(.*?)<\/InstanceCreateTime>/.exec(xmlBody);
    if (createTimeMatch) dbInstance.InstanceCreateTime = createTimeMatch[1];
    const arnMatch = /<DBInstanceArn>(.*?)<\/DBInstanceArn>/.exec(xmlBody);
    if (arnMatch) dbInstance.DBInstanceArn = arnMatch[1];
    const endpointAddressMatch = /<Address>(.*?)<\/Address>/.exec(xmlBody);
    const endpointPortMatch = /<Port>(.*?)<\/Port>/.exec(xmlBody);
    if (endpointAddressMatch || endpointPortMatch) {
      dbInstance.Endpoint = {};
      if (endpointAddressMatch) dbInstance.Endpoint.Address = endpointAddressMatch[1];
      if (endpointPortMatch) dbInstance.Endpoint.Port = parseInt(endpointPortMatch[1]);
    }
    return { DBInstance: dbInstance };
  }
  checkDBInstanceExists(dbInstanceIdentifier) {
    try {
      return this.makeRDSRequest("DescribeDBInstances", {
        DBInstanceIdentifier: dbInstanceIdentifier
      });
    } catch (error) {
      if (error instanceof Error && error.message.includes("DBInstanceNotFound")) {
        return null;
      }
      throw error;
    }
  }
  createDBInstance(params) {
    return this.makeRDSRequest("CreateDBInstance", params);
  }
  modifyDBInstance(dbInstanceIdentifier, params) {
    return this.makeRDSRequest("ModifyDBInstance", {
      DBInstanceIdentifier: dbInstanceIdentifier,
      ...params
    });
  }
  deleteDBInstance(dbInstanceIdentifier, skipFinalSnapshot = true, finalSnapshotId) {
    const params = {
      DBInstanceIdentifier: dbInstanceIdentifier,
      SkipFinalSnapshot: skipFinalSnapshot
    };
    if (!skipFinalSnapshot && finalSnapshotId) {
      params.FinalDBSnapshotIdentifier = finalSnapshotId;
    }
    this.makeRDSRequest("DeleteDBInstance", params);
  }
  waitForDBInstanceState(dbInstanceIdentifier, targetState, maxAttempts = 60) {
    for (let attempt = 0; attempt < maxAttempts; attempt++) {
      try {
        const response = this.checkDBInstanceExists(dbInstanceIdentifier);
        if (response?.DBInstance?.DBInstanceStatus === targetState) {
          return true;
        }
        if (response?.DBInstance?.DBInstanceStatus === "failed") {
          throw new Error(`DB instance ${dbInstanceIdentifier} is in failed state`);
        }
        const start = Date.now();
        while (Date.now() - start < 3e4) {
        }
      } catch (error) {
        if (attempt === maxAttempts - 1) {
          throw error;
        }
      }
    }
    return false;
  }
  waitForDBInstanceDeletion(dbInstanceIdentifier, maxAttempts = 40) {
    console.log(`Waiting for DB instance ${dbInstanceIdentifier} to be fully deleted...`);
    for (let attempt = 0; attempt < maxAttempts; attempt++) {
      try {
        const response = this.checkDBInstanceExists(dbInstanceIdentifier);
        if (!response) {
          console.log(`DB instance ${dbInstanceIdentifier} has been successfully deleted`);
          return true;
        }
        const status = response.DBInstance?.DBInstanceStatus;
        console.log(`DB instance ${dbInstanceIdentifier} status: ${status} (attempt ${attempt + 1}/${maxAttempts})`);
        if (status === "deleting") {
          const start = Date.now();
          while (Date.now() - start < 3e4) {
          }
          continue;
        }
        throw new Error(`DB instance ${dbInstanceIdentifier} is in unexpected state: ${status}`);
      } catch (error) {
        if (error instanceof Error && error.message.includes("DBInstanceNotFound")) {
          console.log(`DB instance ${dbInstanceIdentifier} has been successfully deleted`);
          return true;
        }
        if (attempt === maxAttempts - 1) {
          throw new Error(`Failed to confirm DB instance deletion: ${error instanceof Error ? error.message : "Unknown error"}`);
        }
        const start = Date.now();
        while (Date.now() - start < 3e4) {
        }
      }
    }
    return false;
  }
  // Security Group Management Methods
  updateSecurityGroupRules() {
    if (!this.state.created_security_group_id || this.state.created_security_group_existing) {
      return;
    }
    const groupId = this.state.created_security_group_id;
    const port = this.definition.port || this.getDefaultPortForEngine(this.definition.engine);
    const allowedCidrs = this.definition.allowed_cidr_blocks || [];
    const allowedSgNames = this.definition.allowed_security_group_names || [];
    const vpcId = this.definition.vpc_id;
    updateSecurityGroupRules(this.region, groupId, port, [...allowedCidrs], [...allowedSgNames], vpcId);
  }
  getOrCreateSecurityGroup() {
    if (this.definition.vpc_security_group_ids?.length) {
      return [...this.definition.vpc_security_group_ids];
    }
    if (this.definition.auto_create_security_group === false) {
      return [];
    }
    const dbInstanceIdentifier = this.getDBInstanceIdentifier();
    const groupName = this.definition.security_group_name || `${dbInstanceIdentifier}-sg`;
    const description = this.definition.security_group_description || `Security group for RDS instance ${dbInstanceIdentifier}`;
    const port = this.definition.port || this.getDefaultPortForEngine(this.definition.engine);
    const allowedCidrs = this.definition.allowed_cidr_blocks || [];
    const allowedSgNames = this.definition.allowed_security_group_names || [];
    if (this.state.created_security_group_id) {
      if (checkSecurityGroupExists(this.region, this.state.created_security_group_id)) {
        return [this.state.created_security_group_id];
      } else {
        this.state.created_security_group_id = void 0;
        this.state.created_security_group_existing = false;
      }
    }
    try {
      const vpcId = this.definition.vpc_id;
      let groupId = findSecurityGroupByName(this.region, groupName, vpcId);
      let isExisting = false;
      if (groupId) {
        isExisting = true;
      } else {
        groupId = createSecurityGroup(this.region, groupName, description, vpcId);
      }
      const allowedSgIds = allowedSgNames.length > 0 ? resolveSecurityGroupNames(this.region, [...allowedSgNames], vpcId) : [];
      if (!isExisting && (allowedCidrs.length > 0 || allowedSgIds.length > 0)) {
        authorizeSecurityGroupIngress(this.region, groupId, "tcp", port, port, [...allowedCidrs], allowedSgIds);
      }
      this.state.created_security_group_id = groupId;
      this.state.created_security_group_existing = isExisting;
      return [groupId];
    } catch (error) {
      throw new Error(`Failed to create or find security group: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  cleanupCreatedSecurityGroup() {
    if (this.state.created_security_group_id && !this.state.created_security_group_existing) {
      try {
        import_cli2.default.output(`Deleting created security group: ${this.state.created_security_group_id}`);
        deleteSecurityGroup(this.region, this.state.created_security_group_id);
        this.state.created_security_group_id = void 0;
        this.state.created_security_group_existing = false;
      } catch (error) {
        import_cli2.default.output(`Warning: Could not delete security group ${this.state.created_security_group_id}: ${error instanceof Error ? error.message : "Unknown error"}`);
      }
    }
  }
  getDefaultPortForEngine(engine) {
    const portMap = {
      "mysql": 3306,
      "postgres": 5432,
      "mariadb": 3306,
      "oracle-ee": 1521,
      "oracle-se2": 1521,
      "sqlserver-ex": 1433,
      "sqlserver-web": 1433,
      "sqlserver-se": 1433,
      "sqlserver-ee": 1433
    };
    return portMap[engine.toLowerCase()] || 3306;
  }
  // ==================== Snapshot Operations ====================
  /**
   * List DB snapshots for an instance
   * @param dbInstanceIdentifier - Optional: filter by instance identifier
   * @param snapshotType - Optional: 'manual', 'automated', or 'shared'
   */
  listDBSnapshots(dbInstanceIdentifier, snapshotType) {
    const params = {};
    if (dbInstanceIdentifier) {
      params.DBInstanceIdentifier = dbInstanceIdentifier;
    }
    if (snapshotType) {
      params.SnapshotType = snapshotType;
    }
    const response = this.makeSnapshotRequest("DescribeDBSnapshots", params);
    return this.parseSnapshotsFromResponse(response);
  }
  /**
   * Get details of a specific snapshot
   * @param snapshotIdentifier - The snapshot identifier
   */
  describeDBSnapshot(snapshotIdentifier) {
    try {
      const params = {
        DBSnapshotIdentifier: snapshotIdentifier
      };
      const response = this.makeSnapshotRequest("DescribeDBSnapshots", params);
      const snapshots = this.parseSnapshotsFromResponse(response);
      return snapshots.length > 0 ? snapshots[0] : null;
    } catch (error) {
      if (error instanceof Error && error.message.includes("DBSnapshotNotFound")) {
        return null;
      }
      throw error;
    }
  }
  /**
   * Delete a manual DB snapshot
   * @param snapshotIdentifier - The snapshot identifier to delete
   */
  deleteDBSnapshot(snapshotIdentifier) {
    this.makeSnapshotRequest("DeleteDBSnapshot", {
      DBSnapshotIdentifier: snapshotIdentifier
    });
  }
  /**
   * Create a manual DB snapshot
   * @param dbInstanceIdentifier - The DB instance identifier
   * @param snapshotIdentifier - The snapshot identifier
   * @param tags - Optional tags for the snapshot
   */
  createDBSnapshot(dbInstanceIdentifier, snapshotIdentifier, tags) {
    const params = {
      DBInstanceIdentifier: dbInstanceIdentifier,
      DBSnapshotIdentifier: snapshotIdentifier
    };
    if (tags && Object.keys(tags).length > 0) {
      const tagList = [];
      Object.entries(tags).forEach(([key, value]) => {
        tagList.push({ Key: key, Value: value });
      });
      params.Tags = tagList;
    }
    const response = this.makeSnapshotRequest("CreateDBSnapshot", params);
    const snapshots = this.parseSnapshotsFromResponse(response);
    return snapshots.length > 0 ? snapshots[0] : {
      db_snapshot_identifier: snapshotIdentifier,
      db_instance_identifier: dbInstanceIdentifier,
      status: "creating"
    };
  }
  /**
   * Restore a DB instance from a snapshot
   * Creates a new DB instance from the specified snapshot
   * 
   * @param snapshotIdentifier - The snapshot to restore from
   * @param targetInstanceIdentifier - The identifier for the new instance
   * @param options - Optional configuration for the restored instance
   */
  restoreDBInstanceFromSnapshot(snapshotIdentifier, targetInstanceIdentifier, options) {
    const params = {
      DBSnapshotIdentifier: snapshotIdentifier,
      DBInstanceIdentifier: targetInstanceIdentifier
    };
    if (options?.dbInstanceClass) {
      params.DBInstanceClass = options.dbInstanceClass;
    }
    if (options?.port !== void 0) {
      params.Port = options.port;
    }
    if (options?.availabilityZone) {
      params.AvailabilityZone = options.availabilityZone;
    }
    if (options?.dbSubnetGroupName) {
      params.DBSubnetGroupName = options.dbSubnetGroupName;
    }
    if (options?.multiAZ !== void 0) {
      params.MultiAZ = options.multiAZ;
    }
    if (options?.publiclyAccessible !== void 0) {
      params.PubliclyAccessible = options.publiclyAccessible;
    }
    if (options?.autoMinorVersionUpgrade !== void 0) {
      params.AutoMinorVersionUpgrade = options.autoMinorVersionUpgrade;
    }
    if (options?.storageType) {
      params.StorageType = options.storageType;
    }
    if (options?.vpcSecurityGroupIds && options.vpcSecurityGroupIds.length > 0) {
      params.VpcSecurityGroupIds = options.vpcSecurityGroupIds;
    }
    if (options?.dbName) {
      params.DBName = options.dbName;
    }
    if (options?.engine) {
      params.Engine = options.engine;
    }
    if (options?.tags && Object.keys(options.tags).length > 0) {
      const tagList = [];
      Object.entries(options.tags).forEach(([key, value]) => {
        tagList.push({ Key: key, Value: value });
      });
      params.Tags = tagList;
    }
    return this.makeRDSRequest("RestoreDBInstanceFromDBSnapshot", params);
  }
  /**
   * Parse snapshot information from RDS API XML response
   */
  parseSnapshotsFromResponse(response) {
    const snapshots = [];
    if (response.DBSnapshot) {
      snapshots.push(this.parseSnapshotObject(response.DBSnapshot));
      return snapshots;
    }
    if (response.DBSnapshots && Array.isArray(response.DBSnapshots)) {
      for (const snapshot of response.DBSnapshots) {
        snapshots.push(this.parseSnapshotObject(snapshot));
      }
    }
    return snapshots;
  }
  parseSnapshotObject(snapshot) {
    return {
      db_snapshot_identifier: snapshot.DBSnapshotIdentifier,
      db_instance_identifier: snapshot.DBInstanceIdentifier,
      snapshot_create_time: snapshot.SnapshotCreateTime,
      engine: snapshot.Engine,
      engine_version: snapshot.EngineVersion,
      status: snapshot.Status,
      allocated_storage: snapshot.AllocatedStorage ? parseInt(snapshot.AllocatedStorage) : void 0,
      availability_zone: snapshot.AvailabilityZone,
      vpc_id: snapshot.VpcId,
      snapshot_type: snapshot.SnapshotType,
      percent_progress: snapshot.PercentProgress ? parseInt(snapshot.PercentProgress) : void 0,
      storage_type: snapshot.StorageType,
      encrypted: snapshot.Encrypted === "true" || snapshot.Encrypted === true,
      kms_key_id: snapshot.KmsKeyId,
      db_snapshot_arn: snapshot.DBSnapshotArn
    };
  }
  /**
   * Override makeRDSRequest to handle snapshot responses
   */
  parseSnapshotXmlResponse(xmlBody) {
    const result = {};
    const snapshotsMatch = /<DBSnapshots>(.*?)<\/DBSnapshots>/s.exec(xmlBody);
    if (snapshotsMatch) {
      result.DBSnapshots = [];
      const snapshotMatches = snapshotsMatch[1].match(/<DBSnapshot>(.*?)<\/DBSnapshot>/gs);
      if (snapshotMatches) {
        for (const snapshotXml of snapshotMatches) {
          result.DBSnapshots.push(this.parseSnapshotXml(snapshotXml));
        }
      }
      return result;
    }
    const singleSnapshotMatch = /<DBSnapshot>(.*?)<\/DBSnapshot>/s.exec(xmlBody);
    if (singleSnapshotMatch) {
      result.DBSnapshot = this.parseSnapshotXml(singleSnapshotMatch[0]);
      return result;
    }
    return result;
  }
  parseSnapshotXml(snapshotXml) {
    const snapshot = {};
    const fields = [
      "DBSnapshotIdentifier",
      "DBInstanceIdentifier",
      "SnapshotCreateTime",
      "Engine",
      "EngineVersion",
      "Status",
      "AllocatedStorage",
      "AvailabilityZone",
      "VpcId",
      "SnapshotType",
      "PercentProgress",
      "StorageType",
      "Encrypted",
      "KmsKeyId",
      "DBSnapshotArn",
      "MasterUsername",
      "Port",
      "InstanceCreateTime",
      "OptionGroupName",
      "SourceRegion",
      "SourceDBSnapshotIdentifier"
    ];
    for (const field of fields) {
      const match = new RegExp(`<${field}>(.*?)</${field}>`).exec(snapshotXml);
      if (match) {
        snapshot[field] = match[1];
      }
    }
    return snapshot;
  }
  /**
   * Enhanced RDS request that handles snapshot responses
   */
  makeSnapshotRequest(action, params = {}) {
    const url = `https://rds.${this.region}.amazonaws.com/`;
    const formParams = {
      "Action": action,
      "Version": "2014-10-31"
    };
    addParamsToFormData(formParams, params);
    const formBody = Object.entries(formParams).map(([key, value]) => `${encodeURIComponent(key)}=${encodeURIComponent(value)}`).join("&");
    const response = import_aws2.default.post(url, {
      service: "rds",
      region: this.region,
      headers: {
        "Content-Type": "application/x-www-form-urlencoded"
      },
      body: formBody
    });
    if (response.statusCode >= 400) {
      let errorMessage = `AWS RDS API error: ${response.statusCode} ${response.status}`;
      try {
        const errorMatch = /<Message>(.*?)<\/Message>/.exec(response.body);
        if (errorMatch) {
          errorMessage += ` - ${errorMatch[1]}`;
        }
        const codeMatch = /<Code>(.*?)<\/Code>/.exec(response.body);
        if (codeMatch) {
          errorMessage += ` (${codeMatch[1]})`;
        }
      } catch (_parseError) {
        errorMessage += ` - Raw: ${response.body}`;
      }
      throw new Error(errorMessage);
    }
    return this.parseSnapshotXmlResponse(response.body);
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  AWSRDSEntity
});
