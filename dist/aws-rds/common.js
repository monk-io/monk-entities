// Generated by MonkEC - targeting Goja runtime
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// input/aws-rds/common.ts
var common_exports = {};
__export(common_exports, {
  addParamsToFormData: () => addParamsToFormData,
  buildCreateInstanceParams: () => buildCreateInstanceParams,
  buildModifyInstanceParams: () => buildModifyInstanceParams,
  formatInstanceState: () => formatInstanceState,
  getDefaultPort: () => getDefaultPort,
  makeEC2Request: () => makeEC2Request,
  normalizeEngine: () => normalizeEngine,
  parseRDSError: () => parseRDSError,
  validateDBInstanceIdentifier: () => validateDBInstanceIdentifier,
  validateStorageSize: () => validateStorageSize
});
module.exports = __toCommonJS(common_exports);
var import_aws = __toESM(require("cloud/aws"));
function validateDBInstanceIdentifier(identifier) {
  if (!identifier || identifier.length < 1 || identifier.length > 63) {
    return false;
  }
  if (!/^[a-zA-Z]/.test(identifier)) {
    return false;
  }
  if (identifier.endsWith("-") || identifier.includes("--")) {
    return false;
  }
  return /^[a-zA-Z][a-zA-Z0-9-]*$/.test(identifier);
}
function validateStorageSize(engine, storageSize) {
  const minStorage = {
    "mysql": 20,
    "postgres": 20,
    "mariadb": 20,
    "oracle-ee": 20,
    "oracle-se2": 20,
    "sqlserver-ex": 20,
    "sqlserver-web": 20,
    "sqlserver-se": 20,
    "sqlserver-ee": 20
  };
  const minimum = minStorage[engine] || 20;
  return storageSize >= minimum;
}
function normalizeEngine(engine) {
  const engineMap = {
    "mysql": "mysql",
    "postgres": "postgres",
    "postgresql": "postgres",
    "mariadb": "mariadb",
    "oracle": "oracle-ee",
    "oracle-ee": "oracle-ee",
    "oracle-se2": "oracle-se2",
    "sqlserver": "sqlserver-se",
    "sqlserver-ex": "sqlserver-ex",
    "sqlserver-web": "sqlserver-web",
    "sqlserver-se": "sqlserver-se",
    "sqlserver-ee": "sqlserver-ee"
  };
  return engineMap[engine.toLowerCase()] || engine;
}
function getDefaultPort(engine) {
  const portMap = {
    "mysql": 3306,
    "postgres": 5432,
    "mariadb": 3306,
    "oracle-ee": 1521,
    "oracle-se2": 1521,
    "sqlserver-ex": 1433,
    "sqlserver-web": 1433,
    "sqlserver-se": 1433,
    "sqlserver-ee": 1433
  };
  return portMap[engine] || 3306;
}
function buildCreateInstanceParams(definition, password, securityGroupIds) {
  const params = {
    DBInstanceIdentifier: definition.db_instance_identifier,
    DBInstanceClass: definition.db_instance_class,
    Engine: normalizeEngine(definition.engine),
    MasterUsername: definition.master_username,
    MasterUserPassword: password,
    AllocatedStorage: definition.allocated_storage
  };
  if (definition.engine_version) {
    params.EngineVersion = definition.engine_version;
  }
  if (definition.port) {
    params.Port = definition.port;
  } else {
    params.Port = getDefaultPort(normalizeEngine(definition.engine));
  }
  if (securityGroupIds?.length) {
    params.VpcSecurityGroupIds = securityGroupIds;
  } else if (definition.vpc_security_group_ids?.length) {
    params.VpcSecurityGroupIds = definition.vpc_security_group_ids;
  }
  if (definition.db_subnet_group_name) {
    params.DBSubnetGroupName = definition.db_subnet_group_name;
  }
  if (definition.backup_retention_period !== void 0) {
    params.BackupRetentionPeriod = definition.backup_retention_period;
  }
  if (definition.preferred_backup_window) {
    params.PreferredBackupWindow = definition.preferred_backup_window;
  }
  if (definition.preferred_maintenance_window) {
    params.PreferredMaintenanceWindow = definition.preferred_maintenance_window;
  }
  if (definition.auto_minor_version_upgrade !== void 0) {
    params.AutoMinorVersionUpgrade = String(definition.auto_minor_version_upgrade);
  }
  if (definition.multi_az !== void 0) {
    params.MultiAZ = String(definition.multi_az);
  }
  if (definition.publicly_accessible !== void 0) {
    params.PubliclyAccessible = String(definition.publicly_accessible);
  }
  if (definition.storage_type) {
    params.StorageType = definition.storage_type;
  }
  if (definition.storage_encrypted !== void 0) {
    params.StorageEncrypted = String(definition.storage_encrypted);
  }
  if (definition.kms_key_id) {
    params.KmsKeyId = definition.kms_key_id;
  }
  if (definition.deletion_protection !== void 0) {
    params.DeletionProtection = String(definition.deletion_protection);
  }
  if (definition.skip_final_snapshot !== void 0) {
    params.SkipFinalSnapshot = String(definition.skip_final_snapshot);
  }
  if (definition.tags && Object.keys(definition.tags).length > 0) {
    const tags = [];
    Object.entries(definition.tags).forEach(([key, value]) => {
      if (key && value !== null && value !== void 0) {
        tags.push({
          Key: String(key),
          Value: String(value)
        });
      }
    });
    if (tags.length > 0) {
      params.Tags = tags;
    }
  }
  return params;
}
function formatInstanceState(dbInstance, wasPreExisting = false) {
  return {
    existing: wasPreExisting,
    // true = don't delete (pre-existing), false = we created it (can delete)
    db_instance_identifier: dbInstance.DBInstanceIdentifier,
    db_instance_arn: dbInstance.DBInstanceArn,
    db_instance_status: dbInstance.DBInstanceStatus,
    endpoint_address: dbInstance.Endpoint?.Address,
    endpoint_port: dbInstance.Endpoint?.Port,
    allocated_storage: dbInstance.AllocatedStorage,
    creation_time: dbInstance.InstanceCreateTime,
    last_modified: dbInstance.LastModifiedTime
  };
}
function buildModifyInstanceParams(definition, securityGroupIds) {
  const params = {};
  if (definition.allocated_storage !== void 0) {
    params.AllocatedStorage = definition.allocated_storage;
  }
  if (definition.max_allocated_storage !== void 0) {
    params.MaxAllocatedStorage = definition.max_allocated_storage;
  }
  if (definition.db_instance_class !== void 0) {
    params.DBInstanceClass = definition.db_instance_class;
  }
  if (definition.engine_version !== void 0) {
    params.EngineVersion = definition.engine_version;
  }
  if (definition.auto_minor_version_upgrade !== void 0) {
    params.AutoMinorVersionUpgrade = definition.auto_minor_version_upgrade ? "true" : "false";
  }
  if (definition.backup_retention_period !== void 0) {
    params.BackupRetentionPeriod = definition.backup_retention_period;
  }
  if (definition.backup_window !== void 0) {
    params.PreferredBackupWindow = definition.backup_window;
  }
  if (definition.maintenance_window !== void 0) {
    params.PreferredMaintenanceWindow = definition.maintenance_window;
  }
  if (definition.multi_az !== void 0) {
    params.MultiAZ = definition.multi_az ? "true" : "false";
  }
  if (definition.performance_insights_enabled !== void 0) {
    params.EnablePerformanceInsights = definition.performance_insights_enabled ? "true" : "false";
  }
  if (definition.monitoring_interval !== void 0) {
    params.MonitoringInterval = definition.monitoring_interval;
  }
  if (definition.enabled_cloudwatch_logs_exports && Array.isArray(definition.enabled_cloudwatch_logs_exports)) {
    params.CloudwatchLogsExportConfiguration = {
      LogTypesToEnable: definition.enabled_cloudwatch_logs_exports
    };
  }
  if (definition.deletion_protection !== void 0) {
    params.DeletionProtection = definition.deletion_protection ? "true" : "false";
  }
  if (securityGroupIds && securityGroupIds.length > 0) {
    params.VpcSecurityGroupIds = securityGroupIds;
  } else if (definition.vpc_security_group_ids && Array.isArray(definition.vpc_security_group_ids)) {
    params.VpcSecurityGroupIds = definition.vpc_security_group_ids;
  }
  params.ApplyImmediately = "true";
  return params;
}
function parseRDSError(xmlBody) {
  try {
    const errorMatch = /<Message>(.*?)<\/Message>/.exec(xmlBody);
    const codeMatch = /<Code>(.*?)<\/Code>/.exec(xmlBody);
    if (errorMatch && codeMatch) {
      return `${codeMatch[1]}: ${errorMatch[1]}`;
    } else if (errorMatch) {
      return errorMatch[1];
    }
  } catch (_error) {
  }
  return xmlBody;
}
function addParamsToFormData(formParams, params, prefix = "") {
  for (const [key, value] of Object.entries(params)) {
    const paramKey = prefix ? `${prefix}.${key}` : key;
    if (value === null || value === void 0) {
      continue;
    }
    if (Array.isArray(value)) {
      value.forEach((item, index) => {
        if (typeof item === "object") {
          addParamsToFormData(formParams, item, `${paramKey}.member.${index + 1}`);
        } else {
          formParams[`${paramKey}.member.${index + 1}`] = String(item);
        }
      });
    } else if (typeof value === "object") {
      addParamsToFormData(formParams, value, paramKey);
    } else {
      formParams[paramKey] = String(value);
    }
  }
}
function makeEC2Request(region, action, params = {}) {
  const url = `https://ec2.${region}.amazonaws.com/`;
  const formParams = {
    "Action": action,
    "Version": "2016-11-15"
  };
  addParamsToFormData(formParams, params);
  const formBody = Object.entries(formParams).map(([key, value]) => `${encodeURIComponent(key)}=${encodeURIComponent(value)}`).join("&");
  const response = import_aws.default.post(url, {
    service: "ec2",
    region,
    headers: {
      "Content-Type": "application/x-www-form-urlencoded"
    },
    body: formBody
  });
  if (response.statusCode >= 400) {
    let errorMessage = `AWS EC2 API error: ${response.statusCode} ${response.status}`;
    try {
      const errorMatch = /<message>(.*?)<\/message>/i.exec(response.body);
      if (errorMatch) {
        errorMessage += ` - ${errorMatch[1]}`;
      }
      const codeMatch = /<code>(.*?)<\/code>/i.exec(response.body);
      if (codeMatch) {
        errorMessage += ` (${codeMatch[1]})`;
      }
    } catch (_parseError) {
      errorMessage += ` - Raw: ${response.body}`;
    }
    throw new Error(errorMessage);
  }
  const parsedResponse = parseEC2Response(response.body);
  return parsedResponse;
}
function parseEC2Response(xmlBody) {
  const result = {};
  const groupIdMatch = /<groupId>(.*?)<\/groupId>/.exec(xmlBody);
  if (groupIdMatch) {
    result.GroupId = groupIdMatch[1];
  }
  const groupNameMatch = /<groupName>(.*?)<\/groupName>/.exec(xmlBody);
  if (groupNameMatch) {
    result.GroupName = groupNameMatch[1];
  }
  const descriptionMatch = /<groupDescription>(.*?)<\/groupDescription>/.exec(xmlBody);
  if (descriptionMatch) {
    result.Description = descriptionMatch[1];
  }
  const vpcIdMatch = /<vpcId>(.*?)<\/vpcId>/.exec(xmlBody);
  if (vpcIdMatch) {
    result.VpcId = vpcIdMatch[1];
  }
  const isDefaultMatch = /<isDefault>true<\/isDefault>/.exec(xmlBody);
  if (isDefaultMatch && vpcIdMatch) {
    result.IsDefault = true;
  }
  const securityGroupInfoMatch = /<securityGroupInfo>(.*?)<\/securityGroupInfo>/s.exec(xmlBody);
  if (securityGroupInfoMatch) {
    const securityGroupInfoXml = securityGroupInfoMatch[1];
    const sgMatches = [];
    let currentIndex = 0;
    let itemStart = securityGroupInfoXml.indexOf("<item>", currentIndex);
    while (itemStart !== -1) {
      let depth = 1;
      let searchPos = itemStart + 6;
      let itemEnd = -1;
      while (depth > 0 && searchPos < securityGroupInfoXml.length) {
        const nextOpen = securityGroupInfoXml.indexOf("<item>", searchPos);
        const nextClose = securityGroupInfoXml.indexOf("</item>", searchPos);
        if (nextClose === -1) break;
        if (nextOpen !== -1 && nextOpen < nextClose) {
          depth++;
          searchPos = nextOpen + 6;
        } else {
          depth--;
          if (depth === 0) {
            itemEnd = nextClose + 7;
          }
          searchPos = nextClose + 7;
        }
      }
      if (itemEnd !== -1) {
        sgMatches.push(securityGroupInfoXml.substring(itemStart, itemEnd));
        currentIndex = itemEnd;
        itemStart = securityGroupInfoXml.indexOf("<item>", currentIndex);
      } else {
        break;
      }
    }
    if (sgMatches.length > 0) {
      result.SecurityGroups = [];
      sgMatches.forEach((sgItemXml) => {
        const sgContentMatch = /<item>(.*?)<\/item>/s.exec(sgItemXml);
        if (!sgContentMatch) return;
        const sgXml = sgContentMatch[1];
        const sgIdMatch = /<groupId>(.*?)<\/groupId>/.exec(sgXml);
        const sgNameMatch = /<groupName>(.*?)<\/groupName>/.exec(sgXml);
        if (sgIdMatch && sgNameMatch) {
          const vpcIdMatch2 = /<vpcId>(.*?)<\/vpcId>/.exec(sgXml);
          const securityGroup = {
            GroupId: sgIdMatch[1],
            GroupName: sgNameMatch[1],
            VpcId: vpcIdMatch2 ? vpcIdMatch2[1] : void 0
          };
          const ipPermissionsMatch = /<ipPermissions>(.*?)<\/ipPermissions>/s.exec(sgItemXml);
          if (ipPermissionsMatch) {
            const ipPermissionsXml = ipPermissionsMatch[1];
            const permissionItems = [];
            let currentIndex2 = 0;
            let itemStart2 = ipPermissionsXml.indexOf("<item>", currentIndex2);
            while (itemStart2 !== -1) {
              let depth = 1;
              let searchPos = itemStart2 + 6;
              let itemEnd = -1;
              while (depth > 0 && searchPos < ipPermissionsXml.length) {
                const nextOpen = ipPermissionsXml.indexOf("<item>", searchPos);
                const nextClose = ipPermissionsXml.indexOf("</item>", searchPos);
                if (nextClose === -1) break;
                if (nextOpen !== -1 && nextOpen < nextClose) {
                  depth++;
                  searchPos = nextOpen + 6;
                } else {
                  depth--;
                  if (depth === 0) {
                    itemEnd = nextClose + 7;
                  }
                  searchPos = nextClose + 7;
                }
              }
              if (itemEnd !== -1) {
                permissionItems.push(ipPermissionsXml.substring(itemStart2, itemEnd));
                currentIndex2 = itemEnd;
                itemStart2 = ipPermissionsXml.indexOf("<item>", currentIndex2);
              } else {
                break;
              }
            }
            if (permissionItems.length > 0) {
              securityGroup.IpPermissions = [];
              permissionItems.forEach((permXml) => {
                const protocolMatch = /<ipProtocol>(.*?)<\/ipProtocol>/.exec(permXml);
                const fromPortMatch = /<fromPort>(.*?)<\/fromPort>/.exec(permXml);
                const toPortMatch = /<toPort>(.*?)<\/toPort>/.exec(permXml);
                if (protocolMatch) {
                  const permission = {
                    IpProtocol: protocolMatch[1],
                    FromPort: fromPortMatch ? fromPortMatch[1] : null,
                    ToPort: toPortMatch ? toPortMatch[1] : null
                  };
                  const ipRangesMatch = /<ipRanges>(.*?)<\/ipRanges>/s.exec(permXml);
                  if (ipRangesMatch) {
                    const ipRangesXml = ipRangesMatch[1];
                    const ipRangeItems = ipRangesXml.match(/<item>.*?<\/item>/gs);
                    if (ipRangeItems) {
                      permission.IpRanges = [];
                      ipRangeItems.forEach((ipXml) => {
                        const cidrMatch = /<cidrIp>(.*?)<\/cidrIp>/.exec(ipXml);
                        if (cidrMatch) {
                          permission.IpRanges.push({ CidrIp: cidrMatch[1] });
                        }
                      });
                    }
                  }
                  const groupsMatch = /<groups>(.*?)<\/groups>/s.exec(permXml);
                  if (groupsMatch) {
                    const groupsXml = groupsMatch[1];
                    const groupItems = groupsXml.match(/<item>.*?<\/item>/gs);
                    if (groupItems) {
                      permission.UserIdGroupPairs = [];
                      groupItems.forEach((grpXml) => {
                        const grpIdMatch = /<groupId>(.*?)<\/groupId>/.exec(grpXml);
                        if (grpIdMatch) {
                          permission.UserIdGroupPairs.push({ GroupId: grpIdMatch[1] });
                        }
                      });
                    }
                  }
                  securityGroup.IpPermissions.push(permission);
                }
              });
            }
          }
          result.SecurityGroups.push(securityGroup);
        }
      });
    }
  }
  return result;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  addParamsToFormData,
  buildCreateInstanceParams,
  buildModifyInstanceParams,
  formatInstanceState,
  getDefaultPort,
  makeEC2Request,
  normalizeEngine,
  parseRDSError,
  validateDBInstanceIdentifier,
  validateStorageSize
});
