
// Generated by MonkEC - targeting Goja runtime
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __knownSymbol = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __decoratorStart = (base) => [, , , __create(base?.[__knownSymbol("metadata")] ?? null)];
var __decoratorStrings = ["class", "method", "getter", "setter", "accessor", "field", "value", "get", "set"];
var __expectFn = (fn) => fn !== void 0 && typeof fn !== "function" ? __typeError("Function expected") : fn;
var __decoratorContext = (kind, name, done, metadata, fns) => ({ kind: __decoratorStrings[kind], name, metadata, addInitializer: (fn) => done._ ? __typeError("Already initialized") : fns.push(__expectFn(fn || null)) });
var __decoratorMetadata = (array, target) => __defNormalProp(target, __knownSymbol("metadata"), array[3]);
var __runInitializers = (array, flags, self, value) => {
  for (var i = 0, fns = array[flags >> 1], n = fns && fns.length; i < n; i++) flags & 1 ? fns[i].call(self) : value = fns[i].call(self, value);
  return value;
};
var __decorateElement = (array, flags, name, decorators, target, extra) => {
  var fn, it, done, ctx, access, k = flags & 7, s = !!(flags & 8), p = !!(flags & 16);
  var j = k > 3 ? array.length + 1 : k ? s ? 1 : 2 : 0, key = __decoratorStrings[k + 5];
  var initializers = k > 3 && (array[j - 1] = []), extraInitializers = array[j] || (array[j] = []);
  var desc = k && (!p && !s && (target = target.prototype), k < 5 && (k > 3 || !p) && __getOwnPropDesc(k < 4 ? target : { get [name]() {
    return __privateGet(this, extra);
  }, set [name](x) {
    return __privateSet(this, extra, x);
  } }, name));
  k ? p && k < 4 && __name(extra, (k > 2 ? "set " : k > 1 ? "get " : "") + name) : __name(target, name);
  for (var i = decorators.length - 1; i >= 0; i--) {
    ctx = __decoratorContext(k, name, done = {}, array[3], extraInitializers);
    if (k) {
      ctx.static = s, ctx.private = p, access = ctx.access = { has: p ? (x) => __privateIn(target, x) : (x) => name in x };
      if (k ^ 3) access.get = p ? (x) => (k ^ 1 ? __privateGet : __privateMethod)(x, target, k ^ 4 ? extra : desc.get) : (x) => x[name];
      if (k > 2) access.set = p ? (x, y) => __privateSet(x, target, y, k ^ 4 ? extra : desc.set) : (x, y) => x[name] = y;
    }
    it = (0, decorators[i])(k ? k < 4 ? p ? extra : desc[key] : k > 4 ? void 0 : { get: desc.get, set: desc.set } : target, ctx), done._ = 1;
    if (k ^ 4 || it === void 0) __expectFn(it) && (k > 4 ? initializers.unshift(it) : k ? p ? extra = it : desc[key] = it : target = it);
    else if (typeof it !== "object" || it === null) __typeError("Object expected");
    else __expectFn(fn = it.get) && (desc.get = fn), __expectFn(fn = it.set) && (desc.set = fn), __expectFn(fn = it.init) && initializers.unshift(fn);
  }
  return k || __decoratorMetadata(array, target), desc && __defProp(target, name, desc), p ? k ^ 4 ? extra : desc : target;
};
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateIn = (member, obj) => Object(obj) !== obj ? __typeError('Cannot use the "in" operator on this value') : member.has(obj);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);

// input/aws-rds/instance.ts
const base = require("aws-rds/base");
const AWSRDSEntity = base.AWSRDSEntity;
const MonkecBase = require("monkec/base");
const cli = require("cli");
const secret = require("secret");
const common = require("aws-rds/common");
const validateDBInstanceIdentifier = common.validateDBInstanceIdentifier;
const validateStorageSize = common.validateStorageSize;
const buildCreateInstanceParams = common.buildCreateInstanceParams;
const buildModifyInstanceParams = common.buildModifyInstanceParams;
const formatInstanceState = common.formatInstanceState;
var action2 = MonkecBase.action;
var _getConnectionInfo_dec, _deleteSnapshot_dec, _describeSnapshot_dec, _listSnapshots_dec, _createSnapshot_dec, _updatePassword_dec, _getInstanceInfo_dec, _a, _init;
var _RDSInstance = class _RDSInstance extends (_a = AWSRDSEntity, _getInstanceInfo_dec = [action2("get-instance-info")], _updatePassword_dec = [action2("update-password")], _createSnapshot_dec = [action2("create-snapshot")], _listSnapshots_dec = [action2("list-snapshots")], _describeSnapshot_dec = [action2("describe-snapshot")], _deleteSnapshot_dec = [action2("delete-snapshot")], _getConnectionInfo_dec = [action2("get-connection-info")], _a) {
  constructor() {
    super(...arguments);
    __runInitializers(_init, 5, this);
  }
  getDBInstanceIdentifier() {
    return this.definition.db_instance_identifier;
  }
  updatePasswordForExistingInstance(dbInstanceIdentifier) {
    try {
      const password = this.getOrCreatePassword();
      const modifyParams = {
        MasterUserPassword: password,
        ApplyImmediately: "true"
      };
      const response = this.modifyDBInstance(dbInstanceIdentifier, modifyParams);
      if (response?.DBInstance) {
        const updatedState = formatInstanceState(response.DBInstance, true);
        Object.assign(this.state, updatedState);
      }
    } catch (error) {
      console.log(`Warning: Could not update password for existing instance ${dbInstanceIdentifier}: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  /** Get or create password for the RDS instance */
  getOrCreatePassword() {
    const secretRef = this.definition.password_secret_ref || `${this.definition.db_instance_identifier}-master-password`;
    try {
      const storedPassword = secret.get(secretRef);
      if (!storedPassword) {
        throw new Error("Password not found");
      }
      return storedPassword;
    } catch (_e) {
      const password = secret.randString(16);
      secret.set(secretRef, password);
      return password;
    }
  }
  create() {
    const dbInstanceIdentifier = this.getDBInstanceIdentifier();
    if (!validateDBInstanceIdentifier(dbInstanceIdentifier)) {
      throw new Error(`Invalid DB instance identifier: ${dbInstanceIdentifier}. Must be 1-63 alphanumeric characters or hyphens, start with a letter, and not end with hyphen or contain consecutive hyphens.`);
    }
    if (!validateStorageSize(this.definition.engine, this.definition.allocated_storage)) {
      throw new Error(`Invalid storage size: ${this.definition.allocated_storage}GB. Minimum storage for ${this.definition.engine} is 20GB.`);
    }
    const existingInstance = this.checkDBInstanceExists(dbInstanceIdentifier);
    if (existingInstance) {
      const state = formatInstanceState(existingInstance.DBInstance, true);
      Object.assign(this.state, state);
      this.updatePasswordForExistingInstance(dbInstanceIdentifier);
      return;
    }
    const password = this.getOrCreatePassword();
    const securityGroupIds = this.getOrCreateSecurityGroup();
    const params = buildCreateInstanceParams(this.definition, password, securityGroupIds);
    try {
      const response = this.createDBInstance(params);
      if (response.DBInstance) {
        const state = formatInstanceState(response.DBInstance, false);
        Object.assign(this.state, state);
      }
    } catch (error) {
      throw new Error(`Failed to create DB instance ${dbInstanceIdentifier}: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  start() {
    this.updateStateFromAWS();
  }
  stop() {
    const dbInstanceIdentifier = this.getDBInstanceIdentifier();
    try {
      const response = this.checkDBInstanceExists(dbInstanceIdentifier);
      if (response) {
        this.updateStateFromAWS();
      }
    } catch (error) {
      throw new Error(`Failed to stop DB instance ${dbInstanceIdentifier}: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  update() {
    const dbInstanceIdentifier = this.getDBInstanceIdentifier();
    if (!this.state.db_instance_identifier) {
      throw new Error(`Cannot update DB instance: instance not found in state`);
    }
    try {
      this.updateSecurityGroupRules();
      const securityGroupIds = this.getOrCreateSecurityGroup();
      const modifyParams = buildModifyInstanceParams(this.definition, securityGroupIds);
      if (Object.keys(modifyParams).length > 1) {
        const isAvailable = this.waitForDBInstanceState(dbInstanceIdentifier, "available", 40);
        if (!isAvailable) {
          throw new Error(`DB instance ${dbInstanceIdentifier} did not become available within timeout`);
        }
        const response = this.modifyDBInstance(dbInstanceIdentifier, modifyParams);
        if (response?.DBInstance) {
          const updatedState = formatInstanceState(response.DBInstance, this.state.existing);
          Object.assign(this.state, updatedState);
        }
      } else {
        this.updateStateFromAWS();
      }
    } catch (error) {
      throw new Error(`Failed to update DB instance ${dbInstanceIdentifier}: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  delete() {
    const dbInstanceIdentifier = this.getDBInstanceIdentifier();
    if (this.state.db_instance_identifier && !this.state.existing) {
      try {
        const skipFinalSnapshot = this.definition.skip_final_snapshot ?? true;
        const finalSnapshotId = this.definition.final_db_snapshot_identifier;
        this.deleteDBInstance(dbInstanceIdentifier, skipFinalSnapshot, finalSnapshotId);
        console.log(`Waiting for DB instance ${dbInstanceIdentifier} deletion to complete before security group cleanup...`);
        const deletionComplete = this.waitForDBInstanceDeletion(dbInstanceIdentifier, 40);
        if (!deletionComplete) {
          console.log(`Warning: DB instance ${dbInstanceIdentifier} deletion did not complete within timeout. Security group cleanup may fail.`);
        }
        this.state.existing = false;
        this.state.db_instance_status = void 0;
        this.state.db_instance_identifier = void 0;
      } catch (error) {
        throw new Error(`Failed to delete DB instance ${dbInstanceIdentifier}: ${error instanceof Error ? error.message : "Unknown error"}`);
      }
    } else if (this.state.existing) {
      this.state.db_instance_identifier = void 0;
      this.state.db_instance_status = void 0;
    }
    this.cleanupCreatedSecurityGroup();
  }
  checkReadiness() {
    const dbInstanceIdentifier = this.getDBInstanceIdentifier();
    try {
      if (this.state && this.state.db_instance_identifier && this.state.db_instance_status === "available") {
        return true;
      }
      const response = this.checkDBInstanceExists(dbInstanceIdentifier);
      if (!response) {
        return false;
      }
      if (!response.DBInstance) {
        return false;
      }
      const status = response.DBInstance.DBInstanceStatus;
      if (status === "available" || status === "Available") {
        const state = formatInstanceState(response.DBInstance, this.state.existing);
        Object.assign(this.state, state);
        return true;
      }
      return false;
    } catch (error) {
      console.log(`Readiness check failed for ${dbInstanceIdentifier}: ${error instanceof Error ? error.message : "Unknown error"}`);
      return false;
    }
  }
  checkLiveness() {
    return this.checkReadiness();
  }
  getInstanceInfo(_args) {
    const dbInstanceIdentifier = this.getDBInstanceIdentifier();
    try {
      if (!this.state.db_instance_identifier) {
        cli.output(`DB instance ${dbInstanceIdentifier} not found in entity state`);
        throw new Error(`DB instance ${dbInstanceIdentifier} not found`);
      }
      const response = this.checkDBInstanceExists(dbInstanceIdentifier);
      if (!response) {
        cli.output(`DB instance ${dbInstanceIdentifier} not found in AWS`);
        throw new Error(`DB instance ${dbInstanceIdentifier} not found`);
      }
      const dbInstance = response.DBInstance;
      if (!dbInstance) {
        cli.output(`No DB instance data returned for ${dbInstanceIdentifier}`);
        throw new Error(`No DB instance data returned for ${dbInstanceIdentifier}`);
      }
      cli.output("=== DB Instance Information ===");
      cli.output(`Identifier: ${dbInstance.DBInstanceIdentifier || "N/A"}`);
      cli.output(`Status: ${dbInstance.DBInstanceStatus || "unknown"}`);
      cli.output(`Engine: ${dbInstance.Engine || "unknown"} ${dbInstance.EngineVersion || ""}`);
      cli.output(`Class: ${dbInstance.DBInstanceClass || "N/A"}`);
      cli.output(`Storage: ${dbInstance.AllocatedStorage || 0}GB (${dbInstance.StorageType || "N/A"})`);
      cli.output(`Master Username: ${dbInstance.MasterUsername || "N/A"}`);
      if (dbInstance.Endpoint) {
        cli.output(`Endpoint: ${dbInstance.Endpoint.Address}:${dbInstance.Endpoint.Port}`);
      } else {
        cli.output(`Endpoint: Not available`);
      }
      cli.output(`Multi-AZ: ${dbInstance?.MultiAZ ? "Yes" : "No"}`);
      const publiclyAccessible = dbInstance.PubliclyAccessible;
      const accessibilityDisplay = publiclyAccessible === void 0 ? "Unknown (check AWS Console)" : publiclyAccessible === true || publiclyAccessible === "true" ? "Yes" : "No";
      cli.output(`Publicly Accessible: ${accessibilityDisplay}`);
      cli.output(`Backup Retention: ${dbInstance.BackupRetentionPeriod || 0} days`);
      cli.output(`Preferred Backup Window: ${dbInstance.PreferredBackupWindow || "N/A"}`);
      cli.output(`Preferred Maintenance Window: ${dbInstance.PreferredMaintenanceWindow || "N/A"}`);
      if (dbInstance.VpcSecurityGroups && dbInstance.VpcSecurityGroups.length > 0) {
        cli.output("Security Groups:");
        dbInstance.VpcSecurityGroups.forEach((sg) => {
          cli.output(`  - ${sg.VpcSecurityGroupId} (${sg.Status})`);
        });
      }
      const engine = (dbInstance.Engine || "").toLowerCase();
      const status = (dbInstance.DBInstanceStatus || "").toLowerCase();
      if (engine.includes("mysql")) {
        cli.output(`\u2713 Engine type: mysql detected`);
      }
      if (engine.includes("postgres")) {
        cli.output(`\u2713 Engine type: postgres detected`);
      }
      if (status === "available") {
        cli.output(`\u2713 Status: available confirmed`);
      }
      const state = formatInstanceState(dbInstance, this.state.existing);
      Object.assign(this.state, state);
      cli.output("=== End DB Instance Information ===");
    } catch (error) {
      const errorMsg = `Failed to get instance info for ${dbInstanceIdentifier}: ${error instanceof Error ? error.message : "Unknown error"}`;
      cli.output(errorMsg);
      throw new Error(errorMsg);
    }
  }
  updatePassword(_args) {
    const dbInstanceIdentifier = this.getDBInstanceIdentifier();
    try {
      if (!this.state.db_instance_identifier) {
        cli.output(`DB instance ${dbInstanceIdentifier} not found in entity state`);
        throw new Error(`DB instance ${dbInstanceIdentifier} not found`);
      }
      cli.output("=== Updating Database Password ===");
      cli.output(`Instance ID: ${dbInstanceIdentifier}`);
      const secretRef = this.definition.password_secret_ref || `${dbInstanceIdentifier}-master-password`;
      const password = this.getOrCreatePassword();
      cli.output(`Secret Reference: ${secretRef}`);
      cli.output("Updating master password...");
      const modifyParams = {
        MasterUserPassword: password,
        ApplyImmediately: "true"
      };
      const response = this.modifyDBInstance(dbInstanceIdentifier, modifyParams);
      if (response?.DBInstance) {
        const updatedState = formatInstanceState(response.DBInstance, this.state.existing);
        Object.assign(this.state, updatedState);
        cli.output(`Status: ${response.DBInstance.DBInstanceStatus || "Unknown"}`);
        cli.output("Password update initiated successfully");
        cli.output("Note: Password change may take a few minutes to complete");
      }
      cli.output("=== Password Update Completed ===");
    } catch (error) {
      const errorMsg = `Failed to update password: ${error instanceof Error ? error.message : "Unknown error"}`;
      cli.output(errorMsg);
      throw new Error(errorMsg);
    }
  }
  createSnapshot(args) {
    const dbInstanceIdentifier = this.getDBInstanceIdentifier();
    cli.output(`==================================================`);
    cli.output(`Creating backup snapshot for RDS instance`);
    cli.output(`Instance: ${dbInstanceIdentifier}`);
    cli.output(`Region: ${this.region}`);
    cli.output(`==================================================`);
    if (!this.state.db_instance_identifier) {
      cli.output(`
\u274C DB instance ${dbInstanceIdentifier} not found in entity state`);
      throw new Error(`DB instance ${dbInstanceIdentifier} not found`);
    }
    const snapshotId = args?.snapshot_id || `${dbInstanceIdentifier}-snapshot-${Date.now()}`;
    const description = args?.description;
    cli.output(`Snapshot ID: ${snapshotId}`);
    if (description) {
      cli.output(`Description: ${description}`);
    }
    try {
      const tags = {};
      if (description) {
        tags["Description"] = description;
      }
      tags["CreatedBy"] = "monk-rds-entity";
      tags["CreatedAt"] = (/* @__PURE__ */ new Date()).toISOString();
      const snapshot = this.createDBSnapshot(dbInstanceIdentifier, snapshotId, tags);
      cli.output(`
\u2705 Snapshot creation initiated successfully!`);
      cli.output(`Snapshot ID: ${snapshot.db_snapshot_identifier}`);
      cli.output(`Status: ${snapshot.status || "creating"}`);
      cli.output(`Engine: ${snapshot.engine || this.definition.engine}`);
      if (snapshot.snapshot_create_time) {
        cli.output(`Created at: ${snapshot.snapshot_create_time}`);
      }
      cli.output(`
\u{1F4CB} Note: Snapshot creation may take several minutes depending on database size.`);
      cli.output(`Use 'monk do namespace/instance list-snapshots' to check status.`);
      cli.output(`==================================================`);
    } catch (error) {
      cli.output(`
\u274C Failed to create backup snapshot`);
      throw new Error(`Snapshot creation failed: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  listSnapshots(args) {
    const dbInstanceIdentifier = this.getDBInstanceIdentifier();
    cli.output(`==================================================`);
    cli.output(`Listing backup snapshots for RDS instance`);
    cli.output(`Instance: ${dbInstanceIdentifier}`);
    cli.output(`Region: ${this.region}`);
    cli.output(`==================================================`);
    if (!this.state.db_instance_identifier) {
      cli.output(`
\u274C DB instance ${dbInstanceIdentifier} not found in entity state`);
      throw new Error(`DB instance ${dbInstanceIdentifier} not found`);
    }
    const limit = Number(args?.limit) || 10;
    const snapshotType = args?.snapshot_type;
    if (snapshotType) {
      cli.output(`Filter: ${snapshotType} snapshots only`);
    }
    try {
      const snapshots = this.listDBSnapshots(dbInstanceIdentifier, snapshotType);
      cli.output(`
Total snapshots found: ${snapshots.length}`);
      cli.output(`Showing: ${Math.min(snapshots.length, limit)} snapshot(s)
`);
      if (snapshots.length === 0) {
        cli.output(`No snapshots found for this instance.`);
        cli.output(`Create a snapshot using: monk do namespace/instance create-snapshot`);
      } else {
        const sortedSnapshots = [...snapshots].sort((a, b) => {
          const timeA = a.snapshot_create_time ? new Date(a.snapshot_create_time).getTime() : 0;
          const timeB = b.snapshot_create_time ? new Date(b.snapshot_create_time).getTime() : 0;
          return timeB - timeA;
        });
        const displaySnapshots = sortedSnapshots.slice(0, limit);
        for (let i = 0; i < displaySnapshots.length; i++) {
          const snapshot = displaySnapshots[i];
          const statusIcon = this.getSnapshotStatusIcon(snapshot.status);
          cli.output(`${statusIcon} Snapshot #${i + 1}`);
          cli.output(`   ID: ${snapshot.db_snapshot_identifier}`);
          cli.output(`   Status: ${snapshot.status || "unknown"}`);
          cli.output(`   Type: ${snapshot.snapshot_type || "manual"}`);
          cli.output(`   Created: ${snapshot.snapshot_create_time || "N/A"}`);
          cli.output(`   Engine: ${snapshot.engine || "N/A"} ${snapshot.engine_version || ""}`);
          cli.output(`   Storage: ${snapshot.allocated_storage || 0} GB (${snapshot.storage_type || "N/A"})`);
          if (snapshot.encrypted) {
            cli.output(`   Encrypted: Yes`);
          }
          if (snapshot.percent_progress !== void 0 && snapshot.percent_progress < 100) {
            cli.output(`   Progress: ${snapshot.percent_progress}%`);
          }
          cli.output(``);
        }
        if (snapshots.length > limit) {
          cli.output(`... and ${snapshots.length - limit} more snapshot(s)`);
          cli.output(`Increase limit with: monk do namespace/instance list-snapshots limit=${snapshots.length}`);
        }
      }
      cli.output(`==================================================`);
    } catch (error) {
      cli.output(`
\u274C Failed to list backup snapshots`);
      throw new Error(`List snapshots failed: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  describeSnapshot(args) {
    cli.output(`==================================================`);
    cli.output(`Describing backup snapshot`);
    cli.output(`==================================================`);
    const snapshotId = args?.snapshot_id;
    if (!snapshotId) {
      cli.output(`
\u274C 'snapshot_id' is required`);
      throw new Error(
        `'snapshot_id' is required.
Usage: monk do namespace/instance describe-snapshot snapshot_id="your-snapshot-id"

To find snapshot IDs, run: monk do namespace/instance list-snapshots`
      );
    }
    cli.output(`Snapshot ID: ${snapshotId}`);
    try {
      const snapshot = this.describeDBSnapshot(snapshotId);
      if (!snapshot) {
        cli.output(`
\u274C Snapshot not found: ${snapshotId}`);
        throw new Error(`Snapshot ${snapshotId} not found`);
      }
      const statusIcon = this.getSnapshotStatusIcon(snapshot.status);
      cli.output(`
${statusIcon} Snapshot Details`);
      cli.output(`   Identifier: ${snapshot.db_snapshot_identifier}`);
      cli.output(`   Source Instance: ${snapshot.db_instance_identifier}`);
      cli.output(`   Status: ${snapshot.status || "unknown"}`);
      cli.output(`   Type: ${snapshot.snapshot_type || "manual"}`);
      cli.output(`   Created: ${snapshot.snapshot_create_time || "N/A"}`);
      cli.output(`   Engine: ${snapshot.engine || "N/A"} ${snapshot.engine_version || ""}`);
      cli.output(`   Storage: ${snapshot.allocated_storage || 0} GB`);
      cli.output(`   Storage Type: ${snapshot.storage_type || "N/A"}`);
      cli.output(`   Availability Zone: ${snapshot.availability_zone || "N/A"}`);
      cli.output(`   VPC ID: ${snapshot.vpc_id || "N/A"}`);
      cli.output(`   Encrypted: ${snapshot.encrypted ? "Yes" : "No"}`);
      if (snapshot.kms_key_id) {
        cli.output(`   KMS Key: ${snapshot.kms_key_id}`);
      }
      if (snapshot.db_snapshot_arn) {
        cli.output(`   ARN: ${snapshot.db_snapshot_arn}`);
      }
      if (snapshot.percent_progress !== void 0) {
        cli.output(`   Progress: ${snapshot.percent_progress}%`);
      }
      if (snapshot.status === "available") {
        cli.output(`
\u{1F4CB} This snapshot can be used for restore operations.`);
        cli.output(`   Use: monk do namespace/instance restore snapshot_id="${snapshotId}"`);
      } else if (snapshot.status === "creating") {
        cli.output(`
\u23F3 Snapshot is still being created. Check back later.`);
      }
      cli.output(`
==================================================`);
    } catch (error) {
      if (error instanceof Error && error.message.includes("not found")) {
        throw error;
      }
      cli.output(`
\u274C Failed to describe snapshot`);
      throw new Error(`Describe snapshot failed: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  deleteSnapshot(args) {
    cli.output(`==================================================`);
    cli.output(`\u26A0\uFE0F  DELETE SNAPSHOT - READ CAREFULLY!`);
    cli.output(`==================================================`);
    const snapshotId = args?.snapshot_id;
    if (!snapshotId) {
      cli.output(`
\u274C 'snapshot_id' is required`);
      throw new Error(
        `'snapshot_id' is required.
Usage: monk do namespace/instance delete-snapshot snapshot_id="your-snapshot-id"

To find snapshot IDs, run: monk do namespace/instance list-snapshots`
      );
    }
    cli.output(`Snapshot ID: ${snapshotId}`);
    try {
      const snapshot = this.describeDBSnapshot(snapshotId);
      if (!snapshot) {
        cli.output(`
\u274C Snapshot not found: ${snapshotId}`);
        throw new Error(`Snapshot ${snapshotId} not found`);
      }
      if (snapshot.snapshot_type === "automated") {
        cli.output(`
\u274C Cannot delete automated snapshots`);
        throw new Error(
          "Automated snapshots cannot be deleted directly. They are managed by the backup_retention_period setting. Only manual snapshots can be deleted."
        );
      }
      cli.output(`
\u26A0\uFE0F  WARNING: This will permanently delete the snapshot!`);
      cli.output(`   Type: ${snapshot.snapshot_type || "manual"}`);
      cli.output(`   Created: ${snapshot.snapshot_create_time || "N/A"}`);
      cli.output(`   Storage: ${snapshot.allocated_storage || 0} GB`);
      this.deleteDBSnapshot(snapshotId);
      cli.output(`
\u2705 Snapshot deletion initiated successfully!`);
      cli.output(`Snapshot ID: ${snapshotId}`);
      cli.output(`
\u{1F4CB} Note: Snapshot deletion may take a few moments to complete.`);
      cli.output(`==================================================`);
    } catch (error) {
      if (error instanceof Error && (error.message.includes("not found") || error.message.includes("Cannot delete"))) {
        throw error;
      }
      cli.output(`
\u274C Failed to delete snapshot`);
      throw new Error(`Delete snapshot failed: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  /**
   * Get status icon for snapshot status
   */
  getSnapshotStatusIcon(status) {
    const statusLower = (status || "").toLowerCase();
    switch (statusLower) {
      case "available":
        return "\u{1F4F8}";
      case "creating":
      case "pending":
        return "\u23F3";
      case "deleting":
        return "\u{1F5D1}\uFE0F";
      case "failed":
      case "error":
        return "\u274C";
      default:
        return "\u{1F4F7}";
    }
  }
  getConnectionInfo(_args) {
    const dbInstanceIdentifier = this.getDBInstanceIdentifier();
    try {
      if (!this.state.db_instance_identifier) {
        cli.output(`DB instance ${dbInstanceIdentifier} not found in entity state`);
        throw new Error(`DB instance ${dbInstanceIdentifier} not found`);
      }
      const response = this.checkDBInstanceExists(dbInstanceIdentifier);
      if (!response) {
        cli.output(`DB instance ${dbInstanceIdentifier} not found in AWS`);
        throw new Error(`DB instance ${dbInstanceIdentifier} not found`);
      }
      const dbInstance = response.DBInstance;
      if (dbInstance?.Endpoint) {
        cli.output("=== Connection Information ===");
        cli.output(`Host: ${dbInstance.Endpoint.Address}`);
        cli.output(`Port: ${dbInstance.Endpoint.Port}`);
        cli.output(`Database Engine: ${dbInstance.Engine}`);
        cli.output(`Master Username: ${dbInstance.MasterUsername}`);
        cli.output(`Connection String: ${dbInstance.Engine}://${dbInstance.MasterUsername}@${dbInstance.Endpoint.Address}:${dbInstance.Endpoint.Port}/`);
        if (dbInstance.Engine === "mysql" || dbInstance.Engine === "mariadb") {
          cli.output(`MySQL/MariaDB CLI: mysql -h ${dbInstance.Endpoint.Address} -P ${dbInstance.Endpoint.Port} -u ${dbInstance.MasterUsername} -p`);
        } else if (dbInstance.Engine === "postgres") {
          cli.output(`PostgreSQL CLI: psql -h ${dbInstance.Endpoint.Address} -p ${dbInstance.Endpoint.Port} -U ${dbInstance.MasterUsername} -d postgres`);
        }
        cli.output("=== End Connection Information ===");
      } else {
        cli.output(`DB instance ${dbInstanceIdentifier} endpoint not available yet`);
      }
    } catch (error) {
      const errorMsg = `Failed to get connection info for ${dbInstanceIdentifier}: ${error instanceof Error ? error.message : "Unknown error"}`;
      cli.output(errorMsg);
      throw new Error(errorMsg);
    }
  }
  updateStateFromAWS() {
    const dbInstanceIdentifier = this.getDBInstanceIdentifier();
    try {
      const response = this.checkDBInstanceExists(dbInstanceIdentifier);
      if (response) {
        const state = formatInstanceState(response.DBInstance, this.state.existing);
        Object.assign(this.state, state);
      } else {
        this.state.existing = false;
      }
    } catch (_error) {
    }
  }
};
_init = __decoratorStart(_a);
__decorateElement(_init, 1, "getInstanceInfo", _getInstanceInfo_dec, _RDSInstance);
__decorateElement(_init, 1, "updatePassword", _updatePassword_dec, _RDSInstance);
__decorateElement(_init, 1, "createSnapshot", _createSnapshot_dec, _RDSInstance);
__decorateElement(_init, 1, "listSnapshots", _listSnapshots_dec, _RDSInstance);
__decorateElement(_init, 1, "describeSnapshot", _describeSnapshot_dec, _RDSInstance);
__decorateElement(_init, 1, "deleteSnapshot", _deleteSnapshot_dec, _RDSInstance);
__decorateElement(_init, 1, "getConnectionInfo", _getConnectionInfo_dec, _RDSInstance);
__decoratorMetadata(_init, _RDSInstance);
__name(_RDSInstance, "RDSInstance");
__publicField(_RDSInstance, "readiness", { period: 10, initialDelay: 10, attempts: 100 });
var RDSInstance = _RDSInstance;



function main(def, state, ctx) {
  const entity = new RDSInstance(def, state, ctx);
  return entity.main(ctx);
}
