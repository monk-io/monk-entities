
// Generated by MonkEC - targeting Goja runtime
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __knownSymbol = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __decoratorStart = (base) => [, , , __create(base?.[__knownSymbol("metadata")] ?? null)];
var __decoratorStrings = ["class", "method", "getter", "setter", "accessor", "field", "value", "get", "set"];
var __expectFn = (fn) => fn !== void 0 && typeof fn !== "function" ? __typeError("Function expected") : fn;
var __decoratorContext = (kind, name, done, metadata, fns) => ({ kind: __decoratorStrings[kind], name, metadata, addInitializer: (fn) => done._ ? __typeError("Already initialized") : fns.push(__expectFn(fn || null)) });
var __decoratorMetadata = (array, target) => __defNormalProp(target, __knownSymbol("metadata"), array[3]);
var __runInitializers = (array, flags, self, value) => {
  for (var i = 0, fns = array[flags >> 1], n = fns && fns.length; i < n; i++) flags & 1 ? fns[i].call(self) : value = fns[i].call(self, value);
  return value;
};
var __decorateElement = (array, flags, name, decorators, target, extra) => {
  var fn, it, done, ctx, access, k = flags & 7, s = !!(flags & 8), p = !!(flags & 16);
  var j = k > 3 ? array.length + 1 : k ? s ? 1 : 2 : 0, key = __decoratorStrings[k + 5];
  var initializers = k > 3 && (array[j - 1] = []), extraInitializers = array[j] || (array[j] = []);
  var desc = k && (!p && !s && (target = target.prototype), k < 5 && (k > 3 || !p) && __getOwnPropDesc(k < 4 ? target : { get [name]() {
    return __privateGet(this, extra);
  }, set [name](x) {
    return __privateSet(this, extra, x);
  } }, name));
  k ? p && k < 4 && __name(extra, (k > 2 ? "set " : k > 1 ? "get " : "") + name) : __name(target, name);
  for (var i = decorators.length - 1; i >= 0; i--) {
    ctx = __decoratorContext(k, name, done = {}, array[3], extraInitializers);
    if (k) {
      ctx.static = s, ctx.private = p, access = ctx.access = { has: p ? (x) => __privateIn(target, x) : (x) => name in x };
      if (k ^ 3) access.get = p ? (x) => (k ^ 1 ? __privateGet : __privateMethod)(x, target, k ^ 4 ? extra : desc.get) : (x) => x[name];
      if (k > 2) access.set = p ? (x, y) => __privateSet(x, target, y, k ^ 4 ? extra : desc.set) : (x, y) => x[name] = y;
    }
    it = (0, decorators[i])(k ? k < 4 ? p ? extra : desc[key] : k > 4 ? void 0 : { get: desc.get, set: desc.set } : target, ctx), done._ = 1;
    if (k ^ 4 || it === void 0) __expectFn(it) && (k > 4 ? initializers.unshift(it) : k ? p ? extra = it : desc[key] = it : target = it);
    else if (typeof it !== "object" || it === null) __typeError("Object expected");
    else __expectFn(fn = it.get) && (desc.get = fn), __expectFn(fn = it.set) && (desc.set = fn), __expectFn(fn = it.init) && initializers.unshift(fn);
  }
  return k || __decoratorMetadata(array, target), desc && __defProp(target, name, desc), p ? k ^ 4 ? extra : desc : target;
};
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateIn = (member, obj) => Object(obj) !== obj ? __typeError('Cannot use the "in" operator on this value') : member.has(obj);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);

// input/aws-rds/instance.ts
const base = require("aws-rds/base");
const AWSRDSEntity = base.AWSRDSEntity;
const MonkecBase = require("monkec/base");
const cli = require("cli");
const secret = require("secret");
const common = require("aws-rds/common");
const validateDBInstanceIdentifier = common.validateDBInstanceIdentifier;
const validateStorageSize = common.validateStorageSize;
const buildCreateInstanceParams = common.buildCreateInstanceParams;
const buildModifyInstanceParams = common.buildModifyInstanceParams;
const formatInstanceState = common.formatInstanceState;
var action2 = MonkecBase.action;
var _getConnectionInfo_dec, _createSnapshot_dec, _updatePassword_dec, _getInstanceInfo_dec, _a, _init;
var _RDSInstance = class _RDSInstance extends (_a = AWSRDSEntity, _getInstanceInfo_dec = [action2("get-instance-info")], _updatePassword_dec = [action2("update-password")], _createSnapshot_dec = [action2("create-snapshot")], _getConnectionInfo_dec = [action2("get-connection-info")], _a) {
  constructor() {
    super(...arguments);
    __runInitializers(_init, 5, this);
  }
  getDBInstanceIdentifier() {
    return this.definition.db_instance_identifier;
  }
  updatePasswordForExistingInstance(dbInstanceIdentifier) {
    try {
      const password = this.getOrCreatePassword();
      const modifyParams = {
        MasterUserPassword: password,
        ApplyImmediately: "true"
      };
      const response = this.modifyDBInstance(dbInstanceIdentifier, modifyParams);
      if (response?.DBInstance) {
        const updatedState = formatInstanceState(response.DBInstance, true);
        Object.assign(this.state, updatedState);
      }
    } catch (error) {
      console.log(`Warning: Could not update password for existing instance ${dbInstanceIdentifier}: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  /** Get or create password for the RDS instance */
  getOrCreatePassword() {
    const secretRef = this.definition.password_secret_ref || `${this.definition.db_instance_identifier}-master-password`;
    try {
      const storedPassword = secret.get(secretRef);
      if (!storedPassword) {
        throw new Error("Password not found");
      }
      return storedPassword;
    } catch (_e) {
      const password = secret.randString(16);
      secret.set(secretRef, password);
      return password;
    }
  }
  create() {
    const dbInstanceIdentifier = this.getDBInstanceIdentifier();
    if (!validateDBInstanceIdentifier(dbInstanceIdentifier)) {
      throw new Error(`Invalid DB instance identifier: ${dbInstanceIdentifier}. Must be 1-63 alphanumeric characters or hyphens, start with a letter, and not end with hyphen or contain consecutive hyphens.`);
    }
    if (!validateStorageSize(this.definition.engine, this.definition.allocated_storage)) {
      throw new Error(`Invalid storage size: ${this.definition.allocated_storage}GB. Minimum storage for ${this.definition.engine} is 20GB.`);
    }
    const existingInstance = this.checkDBInstanceExists(dbInstanceIdentifier);
    if (existingInstance) {
      const state = formatInstanceState(existingInstance.DBInstance, true);
      Object.assign(this.state, state);
      this.updatePasswordForExistingInstance(dbInstanceIdentifier);
      return;
    }
    const password = this.getOrCreatePassword();
    const securityGroupIds = this.getOrCreateSecurityGroup();
    const params = buildCreateInstanceParams(this.definition, password, securityGroupIds);
    try {
      const response = this.createDBInstance(params);
      if (response.DBInstance) {
        const state = formatInstanceState(response.DBInstance, false);
        Object.assign(this.state, state);
      }
    } catch (error) {
      throw new Error(`Failed to create DB instance ${dbInstanceIdentifier}: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  start() {
    this.updateStateFromAWS();
  }
  stop() {
    const dbInstanceIdentifier = this.getDBInstanceIdentifier();
    try {
      const response = this.checkDBInstanceExists(dbInstanceIdentifier);
      if (response) {
        this.updateStateFromAWS();
      }
    } catch (error) {
      throw new Error(`Failed to stop DB instance ${dbInstanceIdentifier}: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  update() {
    const dbInstanceIdentifier = this.getDBInstanceIdentifier();
    if (!this.state.db_instance_identifier) {
      throw new Error(`Cannot update DB instance: instance not found in state`);
    }
    try {
      this.updateSecurityGroupRules();
      const securityGroupIds = this.getOrCreateSecurityGroup();
      const modifyParams = buildModifyInstanceParams(this.definition, securityGroupIds);
      if (Object.keys(modifyParams).length > 1) {
        const isAvailable = this.waitForDBInstanceState(dbInstanceIdentifier, "available", 40);
        if (!isAvailable) {
          throw new Error(`DB instance ${dbInstanceIdentifier} did not become available within timeout`);
        }
        const response = this.modifyDBInstance(dbInstanceIdentifier, modifyParams);
        if (response?.DBInstance) {
          const updatedState = formatInstanceState(response.DBInstance, this.state.existing);
          Object.assign(this.state, updatedState);
        }
      } else {
        this.updateStateFromAWS();
      }
    } catch (error) {
      throw new Error(`Failed to update DB instance ${dbInstanceIdentifier}: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  delete() {
    const dbInstanceIdentifier = this.getDBInstanceIdentifier();
    if (this.state.db_instance_identifier && !this.state.existing) {
      try {
        const skipFinalSnapshot = this.definition.skip_final_snapshot ?? true;
        const finalSnapshotId = this.definition.final_db_snapshot_identifier;
        this.deleteDBInstance(dbInstanceIdentifier, skipFinalSnapshot, finalSnapshotId);
        console.log(`Waiting for DB instance ${dbInstanceIdentifier} deletion to complete before security group cleanup...`);
        const deletionComplete = this.waitForDBInstanceDeletion(dbInstanceIdentifier, 40);
        if (!deletionComplete) {
          console.log(`Warning: DB instance ${dbInstanceIdentifier} deletion did not complete within timeout. Security group cleanup may fail.`);
        }
        this.state.existing = false;
        this.state.db_instance_status = void 0;
        this.state.db_instance_identifier = void 0;
      } catch (error) {
        throw new Error(`Failed to delete DB instance ${dbInstanceIdentifier}: ${error instanceof Error ? error.message : "Unknown error"}`);
      }
    } else if (this.state.existing) {
      this.state.db_instance_identifier = void 0;
      this.state.db_instance_status = void 0;
    }
    this.cleanupCreatedSecurityGroup();
  }
  checkReadiness() {
    const dbInstanceIdentifier = this.getDBInstanceIdentifier();
    try {
      if (this.state && this.state.db_instance_identifier && this.state.db_instance_status === "available") {
        return true;
      }
      const response = this.checkDBInstanceExists(dbInstanceIdentifier);
      if (!response) {
        return false;
      }
      if (!response.DBInstance) {
        return false;
      }
      const status = response.DBInstance.DBInstanceStatus;
      if (status === "available" || status === "Available") {
        const state = formatInstanceState(response.DBInstance, this.state.existing);
        Object.assign(this.state, state);
        return true;
      }
      return false;
    } catch (error) {
      console.log(`Readiness check failed for ${dbInstanceIdentifier}: ${error instanceof Error ? error.message : "Unknown error"}`);
      return false;
    }
  }
  getInstanceInfo(_args) {
    const dbInstanceIdentifier = this.getDBInstanceIdentifier();
    try {
      if (!this.state.db_instance_identifier) {
        cli.output(`DB instance ${dbInstanceIdentifier} not found in entity state`);
        throw new Error(`DB instance ${dbInstanceIdentifier} not found`);
      }
      const response = this.checkDBInstanceExists(dbInstanceIdentifier);
      if (!response) {
        cli.output(`DB instance ${dbInstanceIdentifier} not found in AWS`);
        throw new Error(`DB instance ${dbInstanceIdentifier} not found`);
      }
      const dbInstance = response.DBInstance;
      if (!dbInstance) {
        cli.output(`No DB instance data returned for ${dbInstanceIdentifier}`);
        throw new Error(`No DB instance data returned for ${dbInstanceIdentifier}`);
      }
      cli.output("=== DB Instance Information ===");
      cli.output(`Identifier: ${dbInstance.DBInstanceIdentifier || "N/A"}`);
      cli.output(`Status: ${dbInstance.DBInstanceStatus || "unknown"}`);
      cli.output(`Engine: ${dbInstance.Engine || "unknown"} ${dbInstance.EngineVersion || ""}`);
      cli.output(`Class: ${dbInstance.DBInstanceClass || "N/A"}`);
      cli.output(`Storage: ${dbInstance.AllocatedStorage || 0}GB (${dbInstance.StorageType || "N/A"})`);
      cli.output(`Master Username: ${dbInstance.MasterUsername || "N/A"}`);
      if (dbInstance.Endpoint) {
        cli.output(`Endpoint: ${dbInstance.Endpoint.Address}:${dbInstance.Endpoint.Port}`);
      } else {
        cli.output(`Endpoint: Not available`);
      }
      cli.output(`Multi-AZ: ${dbInstance?.MultiAZ ? "Yes" : "No"}`);
      const publiclyAccessible = dbInstance.PubliclyAccessible;
      const accessibilityDisplay = publiclyAccessible === void 0 ? "Unknown (check AWS Console)" : publiclyAccessible === true || publiclyAccessible === "true" ? "Yes" : "No";
      cli.output(`Publicly Accessible: ${accessibilityDisplay}`);
      cli.output(`Backup Retention: ${dbInstance.BackupRetentionPeriod || 0} days`);
      cli.output(`Preferred Backup Window: ${dbInstance.PreferredBackupWindow || "N/A"}`);
      cli.output(`Preferred Maintenance Window: ${dbInstance.PreferredMaintenanceWindow || "N/A"}`);
      if (dbInstance.VpcSecurityGroups && dbInstance.VpcSecurityGroups.length > 0) {
        cli.output("Security Groups:");
        dbInstance.VpcSecurityGroups.forEach((sg) => {
          cli.output(`  - ${sg.VpcSecurityGroupId} (${sg.Status})`);
        });
      }
      const engine = (dbInstance.Engine || "").toLowerCase();
      const status = (dbInstance.DBInstanceStatus || "").toLowerCase();
      if (engine.includes("mysql")) {
        cli.output(`\u2713 Engine type: mysql detected`);
      }
      if (engine.includes("postgres")) {
        cli.output(`\u2713 Engine type: postgres detected`);
      }
      if (status === "available") {
        cli.output(`\u2713 Status: available confirmed`);
      }
      const state = formatInstanceState(dbInstance, this.state.existing);
      Object.assign(this.state, state);
      cli.output("=== End DB Instance Information ===");
    } catch (error) {
      const errorMsg = `Failed to get instance info for ${dbInstanceIdentifier}: ${error instanceof Error ? error.message : "Unknown error"}`;
      cli.output(errorMsg);
      throw new Error(errorMsg);
    }
  }
  updatePassword(_args) {
    const dbInstanceIdentifier = this.getDBInstanceIdentifier();
    try {
      if (!this.state.db_instance_identifier) {
        cli.output(`DB instance ${dbInstanceIdentifier} not found in entity state`);
        throw new Error(`DB instance ${dbInstanceIdentifier} not found`);
      }
      cli.output("=== Updating Database Password ===");
      cli.output(`Instance ID: ${dbInstanceIdentifier}`);
      const secretRef = this.definition.password_secret_ref || `${dbInstanceIdentifier}-master-password`;
      const password = this.getOrCreatePassword();
      cli.output(`Secret Reference: ${secretRef}`);
      cli.output("Updating master password...");
      const modifyParams = {
        MasterUserPassword: password,
        ApplyImmediately: "true"
      };
      const response = this.modifyDBInstance(dbInstanceIdentifier, modifyParams);
      if (response?.DBInstance) {
        const updatedState = formatInstanceState(response.DBInstance, this.state.existing);
        Object.assign(this.state, updatedState);
        cli.output(`Status: ${response.DBInstance.DBInstanceStatus || "Unknown"}`);
        cli.output("Password update initiated successfully");
        cli.output("Note: Password change may take a few minutes to complete");
      }
      cli.output("=== Password Update Completed ===");
    } catch (error) {
      const errorMsg = `Failed to update password: ${error instanceof Error ? error.message : "Unknown error"}`;
      cli.output(errorMsg);
      throw new Error(errorMsg);
    }
  }
  createSnapshot(args) {
    const dbInstanceIdentifier = this.getDBInstanceIdentifier();
    const snapshotId = args?.snapshot_id || `${dbInstanceIdentifier}-snapshot-${Date.now()}`;
    try {
      if (!this.state.db_instance_identifier) {
        cli.output(`DB instance ${dbInstanceIdentifier} not found in entity state`);
        throw new Error(`DB instance ${dbInstanceIdentifier} not found`);
      }
      this.makeRDSRequest("CreateDBSnapshot", {
        DBInstanceIdentifier: dbInstanceIdentifier,
        DBSnapshotIdentifier: snapshotId
      });
      cli.output(`Snapshot creation initiated: ${snapshotId}`);
    } catch (error) {
      const errorMsg = `Failed to create snapshot for ${dbInstanceIdentifier}: ${error instanceof Error ? error.message : "Unknown error"}`;
      cli.output(errorMsg);
      throw new Error(errorMsg);
    }
  }
  getConnectionInfo(_args) {
    const dbInstanceIdentifier = this.getDBInstanceIdentifier();
    try {
      if (!this.state.db_instance_identifier) {
        cli.output(`DB instance ${dbInstanceIdentifier} not found in entity state`);
        throw new Error(`DB instance ${dbInstanceIdentifier} not found`);
      }
      const response = this.checkDBInstanceExists(dbInstanceIdentifier);
      if (!response) {
        cli.output(`DB instance ${dbInstanceIdentifier} not found in AWS`);
        throw new Error(`DB instance ${dbInstanceIdentifier} not found`);
      }
      const dbInstance = response.DBInstance;
      if (dbInstance?.Endpoint) {
        cli.output("=== Connection Information ===");
        cli.output(`Host: ${dbInstance.Endpoint.Address}`);
        cli.output(`Port: ${dbInstance.Endpoint.Port}`);
        cli.output(`Database Engine: ${dbInstance.Engine}`);
        cli.output(`Master Username: ${dbInstance.MasterUsername}`);
        cli.output(`Connection String: ${dbInstance.Engine}://${dbInstance.MasterUsername}@${dbInstance.Endpoint.Address}:${dbInstance.Endpoint.Port}/`);
        if (dbInstance.Engine === "mysql" || dbInstance.Engine === "mariadb") {
          cli.output(`MySQL/MariaDB CLI: mysql -h ${dbInstance.Endpoint.Address} -P ${dbInstance.Endpoint.Port} -u ${dbInstance.MasterUsername} -p`);
        } else if (dbInstance.Engine === "postgres") {
          cli.output(`PostgreSQL CLI: psql -h ${dbInstance.Endpoint.Address} -p ${dbInstance.Endpoint.Port} -U ${dbInstance.MasterUsername} -d postgres`);
        }
        cli.output("=== End Connection Information ===");
      } else {
        cli.output(`DB instance ${dbInstanceIdentifier} endpoint not available yet`);
      }
    } catch (error) {
      const errorMsg = `Failed to get connection info for ${dbInstanceIdentifier}: ${error instanceof Error ? error.message : "Unknown error"}`;
      cli.output(errorMsg);
      throw new Error(errorMsg);
    }
  }
  updateStateFromAWS() {
    const dbInstanceIdentifier = this.getDBInstanceIdentifier();
    try {
      const response = this.checkDBInstanceExists(dbInstanceIdentifier);
      if (response) {
        const state = formatInstanceState(response.DBInstance, this.state.existing);
        Object.assign(this.state, state);
      } else {
        this.state.existing = false;
      }
    } catch (_error) {
    }
  }
};
_init = __decoratorStart(_a);
__decorateElement(_init, 1, "getInstanceInfo", _getInstanceInfo_dec, _RDSInstance);
__decorateElement(_init, 1, "updatePassword", _updatePassword_dec, _RDSInstance);
__decorateElement(_init, 1, "createSnapshot", _createSnapshot_dec, _RDSInstance);
__decorateElement(_init, 1, "getConnectionInfo", _getConnectionInfo_dec, _RDSInstance);
__decoratorMetadata(_init, _RDSInstance);
__name(_RDSInstance, "RDSInstance");
__publicField(_RDSInstance, "readiness", { period: 10, initialDelay: 10, attempts: 100 });
var RDSInstance = _RDSInstance;



function main(def, state, ctx) {
  const entity = new RDSInstance(def, state, ctx);
  return entity.main(ctx);
}
