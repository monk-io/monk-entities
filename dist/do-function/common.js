// Generated by MonkEC - targeting Goja runtime
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// input/do-function/common.ts
var common_exports = {};
__export(common_exports, {
  buildDefaultRoutes: () => buildDefaultRoutes,
  buildEnvironmentVariables: () => buildEnvironmentVariables,
  buildLogDestinations: () => buildLogDestinations,
  formatFunctionState: () => formatFunctionState,
  generateComponentName: () => generateComponentName,
  getDeploymentStatusDescription: () => getDeploymentStatusDescription,
  isDeploymentFailed: () => isDeploymentFailed,
  isDeploymentInProgress: () => isDeploymentInProgress,
  isDeploymentReady: () => isDeploymentReady,
  mergeEnvironmentVariables: () => mergeEnvironmentVariables,
  normalizeGitHubRepo: () => normalizeGitHubRepo,
  parseGitHubRepo: () => parseGitHubRepo,
  sanitizeAppName: () => sanitizeAppName,
  sanitizeComponentName: () => sanitizeComponentName,
  validateAlertRule: () => validateAlertRule,
  validateCpuKind: () => validateCpuKind,
  validateDomainType: () => validateDomainType,
  validateEnvScope: () => validateEnvScope,
  validateEnvType: () => validateEnvType,
  validateEnvironmentSlug: () => validateEnvironmentSlug,
  validateFunctionDefinition: () => validateFunctionDefinition,
  validateGitHubRepo: () => validateGitHubRepo,
  validateInstanceSize: () => validateInstanceSize,
  validateRegion: () => validateRegion
});
module.exports = __toCommonJS(common_exports);
function validateGitHubRepo(repoUrl) {
  const patterns = [
    /^https:\/\/github\.com\/[\w\-\.]+\/[\w\-\.]+$/,
    /^https:\/\/github\.com\/[\w\-\.]+\/[\w\-\.]+\.git$/
  ];
  return patterns.some((pattern) => pattern.test(repoUrl));
}
function normalizeGitHubRepo(repoUrl) {
  if (!repoUrl.includes("://")) {
    return repoUrl;
  }
  const match = repoUrl.match(/github\.com\/([^\/]+\/[^\/]+)/);
  if (match) {
    return match[1].replace(/\.git$/, "");
  }
  throw new Error(`Invalid GitHub repository URL: ${repoUrl}. Expected format: https://github.com/owner/repo`);
}
function validateRegion(region) {
  const validRegions = [
    "nyc1",
    "nyc3",
    "ams2",
    "ams3",
    "sfo1",
    "sfo2",
    "sfo3",
    "sgp1",
    "lon1",
    "fra1",
    "tor1",
    "blr1",
    "syd1"
  ];
  return validRegions.includes(region);
}
function validateInstanceSize(size) {
  const validSizes = [
    "basic-xxs",
    "basic-xs",
    "basic-s",
    "basic-m",
    "professional-xs",
    "professional-s",
    "professional-m",
    "professional-l",
    "professional-xl"
  ];
  return validSizes.includes(size);
}
function validateEnvironmentSlug(slug) {
  const validSlugs = [
    "node-js",
    "python",
    "go",
    "php",
    "ruby",
    "static-site"
  ];
  return validSlugs.includes(slug);
}
function validateEnvScope(scope) {
  const validScopes = ["RUN_TIME", "BUILD_TIME", "RUN_AND_BUILD_TIME"];
  return validScopes.includes(scope);
}
function validateEnvType(type) {
  const validTypes = ["GENERAL", "SECRET"];
  return validTypes.includes(type);
}
function validateAlertRule(rule) {
  const validRules = [
    "DEPLOYMENT_FAILED",
    "DOMAIN_FAILED",
    "FUNCTIONS_ACTIVATION_COUNT",
    "FUNCTIONS_AVERAGE_DURATION_MS",
    "FUNCTIONS_ERROR_RATE_PER_MINUTE"
  ];
  return validRules.includes(rule);
}
function validateDomainType(type) {
  const validTypes = ["DEFAULT", "PRIMARY", "ALIAS"];
  return validTypes.includes(type);
}
function validateCpuKind(kind) {
  const validKinds = ["shared", "dedicated"];
  return validKinds.includes(kind);
}
function sanitizeAppName(name) {
  return name.toLowerCase().replace(/[^a-z0-9-]/g, "-").replace(/^-+|-+$/g, "").replace(/-+/g, "-").substring(0, 32);
}
function sanitizeComponentName(name) {
  return name.toLowerCase().replace(/[^a-z0-9-]/g, "-").replace(/^-+|-+$/g, "").replace(/-+/g, "-").substring(0, 32);
}
function buildEnvironmentVariables(envs = [], secretResolver) {
  return envs.map((env) => {
    let value = env.value || "";
    if (env.type === "SECRET" && value.includes("secret(")) {
      const secretMatch = value.match(/secret\("([^"]+)"\)/);
      if (secretMatch) {
        const secretRef = secretMatch[1];
        try {
          value = secretResolver(secretRef);
        } catch (error) {
          throw new Error(`Failed to resolve secret ${secretRef}: ${error instanceof Error ? error.message : "Unknown error"}`);
        }
      }
    }
    return {
      key: env.key,
      value,
      scope: env.scope || "RUN_AND_BUILD_TIME",
      type: env.type || "GENERAL"
    };
  });
}
function buildLogDestinations(destinations = [], secretResolver) {
  return destinations.map((dest) => {
    const logDest = { name: dest.name };
    if (dest.datadog) {
      logDest.datadog = {
        endpoint: dest.datadog.endpoint,
        api_key: secretResolver(dest.datadog.api_key_secret_ref)
      };
    }
    if (dest.logtail) {
      logDest.logtail = {
        token: secretResolver(dest.logtail.token_secret_ref)
      };
    }
    return logDest;
  });
}
function validateFunctionDefinition(definition) {
  const errors = [];
  if (!definition.app_name) {
    errors.push("app_name is required");
  } else if (definition.app_name !== sanitizeAppName(definition.app_name)) {
    errors.push(`app_name "${definition.app_name}" contains invalid characters. Use: ${sanitizeAppName(definition.app_name)}`);
  }
  if (!definition.component_name) {
    errors.push("component_name is required");
  } else if (definition.component_name !== sanitizeComponentName(definition.component_name)) {
    errors.push(`component_name "${definition.component_name}" contains invalid characters. Use: ${sanitizeComponentName(definition.component_name)}`);
  }
  if (!definition.github_repo) {
    errors.push("github_repo is required");
  } else if (!validateGitHubRepo(definition.github_repo)) {
    errors.push("github_repo must be a valid GitHub repository URL");
  }
  if (definition.region && !validateRegion(definition.region)) {
    errors.push(`Invalid region: ${definition.region}`);
  }
  if (definition.instance_size_slug && !validateInstanceSize(definition.instance_size_slug)) {
    errors.push(`Invalid instance_size_slug: ${definition.instance_size_slug}`);
  }
  if (definition.environment_slug && !validateEnvironmentSlug(definition.environment_slug)) {
    errors.push(`Invalid environment_slug: ${definition.environment_slug}`);
  }
  if (definition.cpu_kind && !validateCpuKind(definition.cpu_kind)) {
    errors.push(`Invalid cpu_kind: ${definition.cpu_kind}`);
  }
  if (definition.instance_count !== void 0) {
    if (!Number.isInteger(definition.instance_count) || definition.instance_count < 1 || definition.instance_count > 10) {
      errors.push("instance_count must be an integer between 1 and 10");
    }
  }
  if (definition.envs) {
    definition.envs.forEach((env, index) => {
      if (!env.key) {
        errors.push(`Environment variable at index ${index} is missing key`);
      }
      if (env.scope && !validateEnvScope(env.scope)) {
        errors.push(`Invalid scope for environment variable ${env.key}: ${env.scope}`);
      }
      if (env.type && !validateEnvType(env.type)) {
        errors.push(`Invalid type for environment variable ${env.key}: ${env.type}`);
      }
      if (env.type === "SECRET" && env.value && !env.value.includes("secret(")) {
        errors.push(`SECRET type environment variable ${env.key} should use secret() reference`);
      }
    });
  }
  if (definition.alerts) {
    definition.alerts.forEach((alert, index) => {
      if (!validateAlertRule(alert.rule)) {
        errors.push(`Invalid alert rule at index ${index}: ${alert.rule}`);
      }
    });
  }
  if (definition.domains) {
    definition.domains.forEach((domain, index) => {
      if (!domain.domain) {
        errors.push(`Domain at index ${index} is missing domain name`);
      }
      if (domain.type && !validateDomainType(domain.type)) {
        errors.push(`Invalid domain type at index ${index}: ${domain.type}`);
      }
    });
  }
  if (definition.log_destinations) {
    definition.log_destinations.forEach((dest, index) => {
      if (!dest.name) {
        errors.push(`Log destination at index ${index} is missing name`);
      }
      if (!dest.datadog && !dest.logtail) {
        errors.push(`Log destination ${dest.name} must have either datadog or logtail configuration`);
      }
      if (dest.datadog) {
        if (!dest.datadog.endpoint) {
          errors.push(`Datadog log destination ${dest.name} is missing endpoint`);
        }
        if (!dest.datadog.api_key_secret_ref) {
          errors.push(`Datadog log destination ${dest.name} is missing api_key_secret_ref`);
        }
      }
      if (dest.logtail) {
        if (!dest.logtail.token_secret_ref) {
          errors.push(`Logtail log destination ${dest.name} is missing token_secret_ref`);
        }
      }
    });
  }
  return errors;
}
function formatFunctionState(app, wasPreExisting = false, componentName) {
  return {
    existing: wasPreExisting,
    app_id: app.id,
    component_name: componentName || app.spec?.functions?.[0]?.name
  };
}
function isDeploymentReady(phase) {
  return phase === "ACTIVE";
}
function isDeploymentFailed(phase) {
  return ["ERROR", "CANCELED"].includes(phase);
}
function isDeploymentInProgress(phase) {
  return ["PENDING_BUILD", "BUILDING", "PENDING_DEPLOY", "DEPLOYING"].includes(phase);
}
function getDeploymentStatusDescription(phase) {
  const descriptions = {
    "UNKNOWN": "Unknown status",
    "PENDING_BUILD": "Waiting to build",
    "BUILDING": "Building application",
    "PENDING_DEPLOY": "Waiting to deploy",
    "DEPLOYING": "Deploying application",
    "ACTIVE": "Successfully deployed and running",
    "SUPERSEDED": "Replaced by newer deployment",
    "ERROR": "Deployment failed",
    "CANCELED": "Deployment was canceled"
  };
  return descriptions[phase] || `Unknown phase: ${phase}`;
}
function parseGitHubRepo(repoUrl) {
  const normalizedUrl = normalizeGitHubRepo(repoUrl);
  const match = normalizedUrl.match(/https:\/\/github\.com\/([^\/]+)\/([^\/]+)/);
  if (!match) {
    throw new Error(`Invalid GitHub repository URL: ${repoUrl}`);
  }
  return {
    owner: match[1],
    repo: match[2]
  };
}
function generateComponentName(appName) {
  return `${sanitizeComponentName(appName)}-function`;
}
function buildDefaultRoutes() {
  return [{
    path: "/",
    preserve_path_prefix: false
  }];
}
function mergeEnvironmentVariables(base = [], override = []) {
  const merged = [...base];
  override.forEach((overrideEnv) => {
    const existingIndex = merged.findIndex((env) => env.key === overrideEnv.key);
    if (existingIndex >= 0) {
      merged[existingIndex] = overrideEnv;
    } else {
      merged.push(overrideEnv);
    }
  });
  return merged;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  buildDefaultRoutes,
  buildEnvironmentVariables,
  buildLogDestinations,
  formatFunctionState,
  generateComponentName,
  getDeploymentStatusDescription,
  isDeploymentFailed,
  isDeploymentInProgress,
  isDeploymentReady,
  mergeEnvironmentVariables,
  normalizeGitHubRepo,
  parseGitHubRepo,
  sanitizeAppName,
  sanitizeComponentName,
  validateAlertRule,
  validateCpuKind,
  validateDomainType,
  validateEnvScope,
  validateEnvType,
  validateEnvironmentSlug,
  validateFunctionDefinition,
  validateGitHubRepo,
  validateInstanceSize,
  validateRegion
});
