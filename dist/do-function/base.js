// Generated by MonkEC - targeting Goja runtime
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);

// input/do-function/base.ts
var base_exports = {};
__export(base_exports, {
  DOFunctionEntity: () => DOFunctionEntity
});
module.exports = __toCommonJS(base_exports);
var import_base = require("monkec/base");
var import_http = __toESM(require("http"));
var import_secret = __toESM(require("secret"));
var import_cli = __toESM(require("cli"));
var DOFunctionEntity = class extends import_base.MonkEntity {
  constructor() {
    super(...arguments);
    __publicField(this, "baseUrl", "https://api.digitalocean.com/v2");
  }
  /**
   * Make authenticated request to DigitalOcean API with debug output
   */
  makeDORequest(method, endpoint, data, debug = false) {
    const url = `${this.baseUrl}${endpoint}`;
    const token = this.getDOAPIToken();
    const headers = {
      "Authorization": `Bearer ${token}`,
      "Content-Type": "application/json"
    };
    if (debug) {
      import_cli.default.output(`[DEBUG] API Request: ${method} ${url}`);
      if (data) {
        import_cli.default.output(`[DEBUG] Request Body: ${JSON.stringify(data, null, 2)}`);
      }
    }
    try {
      let response;
      if (method.toLowerCase() === "get") {
        response = import_http.default.get(url, { headers });
      } else if (method.toLowerCase() === "post") {
        response = import_http.default.post(url, {
          headers,
          body: data ? JSON.stringify(data) : void 0
        });
      } else if (method.toLowerCase() === "put") {
        response = import_http.default.put(url, {
          headers,
          body: data ? JSON.stringify(data) : void 0
        });
      } else if (method.toLowerCase() === "delete") {
        response = import_http.default.delete(url, { headers });
      } else {
        throw new Error(`Unsupported HTTP method: ${method}`);
      }
      if (debug) {
        import_cli.default.output(`[DEBUG] API Response: ${response.status}`);
        if (response.body) {
          import_cli.default.output(`[DEBUG] Response Body: ${response.body}`);
        }
      }
      if (Number(response.status) >= 400) {
        throw new Error(`DigitalOcean API error: ${response.status} - ${response.body}`);
      }
      return response.body ? JSON.parse(response.body) : null;
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : "Unknown error";
      if (debug) {
        import_cli.default.output(`[DEBUG] API Error: ${errorMessage}`);
      }
      import_cli.default.output(`[ERROR] DigitalOcean API request failed:`);
      import_cli.default.output(`[ERROR] Method: ${method}`);
      import_cli.default.output(`[ERROR] URL: ${url}`);
      import_cli.default.output(`[ERROR] Error: ${errorMessage}`);
      throw new Error(`DigitalOcean API request failed: ${errorMessage}`);
    }
  }
  /**
   * Get DigitalOcean API token from secrets
   */
  getDOAPIToken() {
    const secretRef = this.definition.api_token_secret_ref || "do-api-token";
    try {
      const token = import_secret.default.get(secretRef);
      if (!token) {
        throw new Error(`DigitalOcean API token not found in secret: ${secretRef}`);
      }
      return token;
    } catch (error) {
      throw new Error(`Failed to get DigitalOcean API token: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  /**
   * Check if an app exists by name
   */
  checkAppExists(appName) {
    try {
      const response = this.makeDORequest("GET", "/apps");
      const existingApp = response.apps.find((app) => app.spec.name === appName);
      if (existingApp) {
        const fullApp = this.makeDORequest("GET", `/apps/${existingApp.id}`);
        return fullApp.app;
      }
      return null;
    } catch (error) {
      console.log(`Error checking if app exists: ${error instanceof Error ? error.message : "Unknown error"}`);
      return null;
    }
  }
  /**
   * Get app by ID
   */
  getApp(appId) {
    const response = this.makeDORequest("GET", `/apps/${appId}`);
    return response.app;
  }
  /**
   * Create a new app with function component
   */
  createApp(appSpec) {
    const response = this.makeDORequest("POST", "/apps", { spec: appSpec }, true);
    return response.app;
  }
  /**
   * Update an existing app
   */
  updateApp(appId, appSpec) {
    const response = this.makeDORequest("PUT", `/apps/${appId}`, { spec: appSpec });
    return response.app;
  }
  /**
   * Delete an app
   */
  deleteApp(appId) {
    this.makeDORequest("DELETE", `/apps/${appId}`);
  }
  /**
   * Get app deployments
   */
  getAppDeployments(appId) {
    return this.makeDORequest("GET", `/apps/${appId}/deployments`);
  }
  /**
   * Get deployment logs
   */
  getDeploymentLogs(appId, deploymentId, componentName) {
    return this.makeDORequest("GET", `/apps/${appId}/deployments/${deploymentId}/components/${componentName}/logs`);
  }
  /**
   * Validate the definition
   */
  validateDefinition() {
    if (!this.definition.app_name) {
      throw new Error("app_name is required");
    }
    if (!this.definition.component_name) {
      throw new Error("component_name is required");
    }
    if (!this.definition.github_repo) {
      throw new Error("github_repo is required");
    }
    const repoPattern = /^https:\/\/github\.com\/[\w\-\.]+\/[\w\-\.]+(?:\.git)?$/;
    if (!repoPattern.test(this.definition.github_repo)) {
      throw new Error("github_repo must be a valid GitHub repository URL");
    }
    if (this.definition.envs) {
      for (const env of this.definition.envs) {
        if (!env.key) {
          throw new Error("Environment variable key is required");
        }
        if (env.type === "SECRET" && !env.value && !env.value?.includes("secret(")) {
          import_cli.default.output(`Warning: SECRET type environment variable ${env.key} should use secret reference`);
        }
      }
    }
  }
  /**
   * Build app specification for DigitalOcean App Platform
   */
  buildAppSpec() {
    const functionComponent = {
      name: this.definition.component_name,
      source_dir: this.definition.source_dir || "/",
      github: {
        repo: this.definition.github_repo,
        branch: this.definition.github_branch || "main",
        deploy_on_push: this.definition.github_deploy_on_push !== false
      }
      // Note: Functions API doesn't support instance_count, instance_size_slug, environment_slug
      // These are managed automatically by the platform
    };
    if (this.definition.routes && this.definition.routes.length > 0) {
      functionComponent.routes = [...this.definition.routes];
    }
    if (this.definition.envs && this.definition.envs.length > 0) {
      functionComponent.envs = this.definition.envs.map((env) => ({
        key: env.key,
        value: env.value || "",
        scope: env.scope || "RUN_AND_BUILD_TIME",
        type: env.type || "GENERAL"
      }));
    }
    if (this.definition.log_destinations && this.definition.log_destinations.length > 0) {
      functionComponent.log_destinations = this.definition.log_destinations.map((dest) => {
        const logDest = { name: dest.name };
        if (dest.datadog) {
          logDest.datadog = {
            endpoint: dest.datadog.endpoint,
            api_key: this.getSecretValue(dest.datadog.api_key_secret_ref)
          };
        }
        if (dest.logtail) {
          logDest.logtail = {
            token: this.getSecretValue(dest.logtail.token_secret_ref)
          };
        }
        return logDest;
      });
    }
    if (this.definition.build_command) {
      functionComponent.build_command = this.definition.build_command;
    }
    if (this.definition.run_command) {
      functionComponent.run_command = this.definition.run_command;
    }
    if (this.definition.cpu_kind) {
      functionComponent.cpu_kind = this.definition.cpu_kind;
    }
    const spec = {
      name: this.definition.app_name,
      region: this.definition.region || "nyc",
      functions: [functionComponent]
    };
    if (this.definition.alerts && this.definition.alerts.length > 0) {
      spec.alerts = [...this.definition.alerts];
    }
    if (this.definition.domains && this.definition.domains.length > 0) {
      spec.domains = [...this.definition.domains];
    }
    return spec;
  }
  /**
   * Get secret value by reference
   */
  getSecretValue(secretRef) {
    try {
      const value = import_secret.default.get(secretRef);
      if (!value) {
        throw new Error(`Secret not found: ${secretRef}`);
      }
      return value;
    } catch (error) {
      throw new Error(`Failed to get secret ${secretRef}: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  /**
   * Format app state for storage - minimal essential data only
   */
  formatAppState(app, wasPreExisting = false) {
    return {
      existing: wasPreExisting,
      app_id: app.id,
      component_name: this.definition.component_name
    };
  }
  /**
   * Check if the function component is ready
   */
  isFunctionReady(app) {
    if (!app.active_deployment) {
      return false;
    }
    const deployment = app.active_deployment;
    if (deployment.phase === "ACTIVE") {
      return true;
    }
    if (deployment.phase === "ERROR" || deployment.phase === "CANCELED") {
      return false;
    }
    return false;
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  DOFunctionEntity
});
