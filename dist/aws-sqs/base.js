// Generated by MonkEC - targeting Goja runtime
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// input/aws-sqs/base.ts
var base_exports = {};
__export(base_exports, {
  AWSSQSEntity: () => AWSSQSEntity
});
module.exports = __toCommonJS(base_exports);
var import_base = require("monkec/base");
var import_aws = __toESM(require("cloud/aws"));

// input/aws-sqs/common.ts
function parseSQSError(responseBody) {
  try {
    const parsed = JSON.parse(responseBody);
    return {
      code: parsed.Error?.Code || "UnknownError",
      message: parsed.Error?.Message || "Unknown error occurred"
    };
  } catch (error) {
    return {
      code: "ParseError",
      message: `Failed to parse error response: ${responseBody}`
    };
  }
}
var DEFAULT_STANDARD_QUEUE_ATTRIBUTES = {
  DelaySeconds: 0,
  MaximumMessageSize: 262144,
  // 256 KiB
  MessageRetentionPeriod: 345600,
  // 4 days
  ReceiveMessageWaitTimeSeconds: 0,
  VisibilityTimeout: 30
  // Note: FifoQueue is not included as AWS rejects this attribute for standard queues
};
var DEFAULT_FIFO_QUEUE_ATTRIBUTES = {
  ...DEFAULT_STANDARD_QUEUE_ATTRIBUTES,
  FifoQueue: true,
  ContentBasedDeduplication: false
};

// input/aws-sqs/base.ts
var AWSSQSEntity = class extends import_base.MonkEntity {
  get region() {
    return this.definition.region;
  }
  getQueueUrl(queueName) {
    const url = `https://sqs.${this.region}.amazonaws.com/`;
    const body = `Action=GetQueueUrl&QueueName=${encodeURIComponent(queueName)}&Version=2012-11-05`;
    const response = import_aws.default.post(url, {
      service: "sqs",
      region: this.region,
      headers: {
        "Content-Type": "application/x-www-form-urlencoded"
      },
      body
    });
    if (response.statusCode !== 200) {
      const errorMessage = parseSQSError(response.body);
      throw new Error(`Failed to get queue URL: ${errorMessage}`);
    }
    const urlMatch = /<QueueUrl>(.*?)<\/QueueUrl>/.exec(response.body);
    if (urlMatch && urlMatch[1]) {
      return urlMatch[1];
    }
    throw new Error("Queue URL not found in response");
  }
  createQueue(queueName, attributes) {
    const url = `https://sqs.${this.region}.amazonaws.com/`;
    let body = `Action=CreateQueue&QueueName=${encodeURIComponent(queueName)}&Version=2012-11-05`;
    if (attributes) {
      let attrIndex = 1;
      for (const [name, value] of Object.entries(attributes)) {
        body += `&Attribute.${attrIndex}.Name=${encodeURIComponent(name)}`;
        body += `&Attribute.${attrIndex}.Value=${encodeURIComponent(value)}`;
        attrIndex++;
      }
    }
    const response = import_aws.default.post(url, {
      service: "sqs",
      region: this.region,
      headers: {
        "Content-Type": "application/x-www-form-urlencoded"
      },
      body
    });
    if (response.statusCode !== 200) {
      const errorMessage = parseSQSError(response.body);
      throw new Error(`Failed to create queue: ${errorMessage}`);
    }
    const urlMatch = /<QueueUrl>(.*?)<\/QueueUrl>/.exec(response.body);
    if (urlMatch && urlMatch[1]) {
      return { QueueUrl: urlMatch[1] };
    }
    throw new Error("Queue URL not found in response");
  }
  deleteQueue(queueUrl) {
    const body = `Action=DeleteQueue&QueueUrl=${encodeURIComponent(queueUrl)}&Version=2012-11-05`;
    const response = import_aws.default.post(queueUrl, {
      service: "sqs",
      region: this.region,
      headers: {
        "Content-Type": "application/x-www-form-urlencoded"
      },
      body
    });
    if (response.statusCode !== 200) {
      const errorMessage = parseSQSError(response.body);
      throw new Error(`Failed to delete queue: ${errorMessage}`);
    }
  }
  getQueueAttributes(queueUrl, attributeNames = ["All"]) {
    const url = queueUrl;
    let body = `Action=GetQueueAttributes&Version=2012-11-05`;
    attributeNames.forEach((name, index) => {
      body += `&AttributeName.${index + 1}=${encodeURIComponent(name)}`;
    });
    const response = import_aws.default.post(url, {
      service: "sqs",
      region: this.region,
      headers: {
        "Content-Type": "application/x-www-form-urlencoded"
      },
      body
    });
    if (response.statusCode !== 200) {
      const errorMessage = parseSQSError(response.body);
      throw new Error(`Failed to get queue attributes: ${errorMessage}`);
    }
    const attributes = {};
    const patterns = [
      /<Attribute><n>(.*?)<\/n><Value>(.*?)<\/Value><\/Attribute>/g,
      /<Attribute><Name>(.*?)<\/Name><Value>(.*?)<\/Value><\/Attribute>/g,
      /<member><Name>(.*?)<\/Name><Value>(.*?)<\/Value><\/member>/g
    ];
    for (const regex of patterns) {
      let match;
      while ((match = regex.exec(response.body)) !== null) {
        attributes[match[1]] = match[2];
      }
      regex.lastIndex = 0;
    }
    return { Attributes: attributes };
  }
  setQueueAttributes(queueUrl, attributes) {
    let body = `Action=SetQueueAttributes&QueueUrl=${encodeURIComponent(queueUrl)}&Version=2012-11-05`;
    let attrIndex = 1;
    for (const [name, value] of Object.entries(attributes)) {
      body += `&Attribute.${attrIndex}.Name=${encodeURIComponent(name)}`;
      body += `&Attribute.${attrIndex}.Value=${encodeURIComponent(value)}`;
      attrIndex++;
    }
    const response = import_aws.default.post(queueUrl, {
      service: "sqs",
      region: this.region,
      headers: {
        "Content-Type": "application/x-www-form-urlencoded"
      },
      body
    });
    if (response.statusCode !== 200) {
      const errorMessage = parseSQSError(response.body);
      throw new Error(`Failed to set queue attributes: ${errorMessage}`);
    }
  }
  sendMessage(queueUrl, messageBody, messageAttributes) {
    let body = `Action=SendMessage&QueueUrl=${encodeURIComponent(queueUrl)}&MessageBody=${encodeURIComponent(messageBody)}&Version=2012-11-05`;
    if (messageAttributes) {
      let attrIndex = 1;
      for (const [name, attr] of Object.entries(messageAttributes)) {
        body += `&MessageAttribute.${attrIndex}.Name=${encodeURIComponent(name)}`;
        body += `&MessageAttribute.${attrIndex}.Value.DataType=${encodeURIComponent(attr.DataType || "String")}`;
        body += `&MessageAttribute.${attrIndex}.Value.StringValue=${encodeURIComponent(attr.StringValue || "")}`;
        attrIndex++;
      }
    }
    const response = import_aws.default.post(queueUrl, {
      service: "sqs",
      region: this.region,
      headers: {
        "Content-Type": "application/x-www-form-urlencoded"
      },
      body
    });
    if (response.statusCode !== 200) {
      const errorMessage = parseSQSError(response.body);
      throw new Error(`Failed to send message: ${errorMessage}`);
    }
    const messageIdMatch = /<MessageId>(.*?)<\/MessageId>/.exec(response.body);
    const md5Match = /<MD5OfBody>(.*?)<\/MD5OfBody>/.exec(response.body);
    return {
      MessageId: messageIdMatch ? messageIdMatch[1] : void 0,
      MD5OfBody: md5Match ? md5Match[1] : void 0
    };
  }
  receiveMessage(queueUrl, maxNumberOfMessages = 1, waitTimeSeconds = 0) {
    let body = `Action=ReceiveMessage&QueueUrl=${encodeURIComponent(queueUrl)}&MaxNumberOfMessages=${maxNumberOfMessages}&WaitTimeSeconds=${waitTimeSeconds}&Version=2012-11-05`;
    const response = import_aws.default.post(queueUrl, {
      service: "sqs",
      region: this.region,
      headers: {
        "Content-Type": "application/x-www-form-urlencoded"
      },
      body
    });
    if (response.statusCode !== 200) {
      const errorMessage = parseSQSError(response.body);
      throw new Error(`Failed to receive messages: ${errorMessage}`);
    }
    return { Messages: [] };
  }
  deleteMessage(queueUrl, receiptHandle) {
    let body = `Action=DeleteMessage&QueueUrl=${encodeURIComponent(queueUrl)}&ReceiptHandle=${encodeURIComponent(receiptHandle)}&Version=2012-11-05`;
    const response = import_aws.default.post(queueUrl, {
      service: "sqs",
      region: this.region,
      headers: {
        "Content-Type": "application/x-www-form-urlencoded"
      },
      body
    });
    if (response.statusCode !== 200) {
      const errorMessage = parseSQSError(response.body);
      throw new Error(`Failed to delete message: ${errorMessage}`);
    }
  }
  queueExists(queueName) {
    try {
      this.getQueueUrl(queueName);
      return true;
    } catch (error) {
      return false;
    }
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  AWSSQSEntity
});
