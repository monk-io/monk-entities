
// Generated by MonkEC - targeting Goja runtime
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __knownSymbol = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __decoratorStart = (base) => [, , , __create(base?.[__knownSymbol("metadata")] ?? null)];
var __decoratorStrings = ["class", "method", "getter", "setter", "accessor", "field", "value", "get", "set"];
var __expectFn = (fn) => fn !== void 0 && typeof fn !== "function" ? __typeError("Function expected") : fn;
var __decoratorContext = (kind, name, done, metadata, fns) => ({ kind: __decoratorStrings[kind], name, metadata, addInitializer: (fn) => done._ ? __typeError("Already initialized") : fns.push(__expectFn(fn || null)) });
var __decoratorMetadata = (array, target) => __defNormalProp(target, __knownSymbol("metadata"), array[3]);
var __runInitializers = (array, flags, self, value) => {
  for (var i = 0, fns = array[flags >> 1], n = fns && fns.length; i < n; i++) flags & 1 ? fns[i].call(self) : value = fns[i].call(self, value);
  return value;
};
var __decorateElement = (array, flags, name, decorators, target, extra) => {
  var fn, it, done, ctx, access, k = flags & 7, s = !!(flags & 8), p = !!(flags & 16);
  var j = k > 3 ? array.length + 1 : k ? s ? 1 : 2 : 0, key = __decoratorStrings[k + 5];
  var initializers = k > 3 && (array[j - 1] = []), extraInitializers = array[j] || (array[j] = []);
  var desc = k && (!p && !s && (target = target.prototype), k < 5 && (k > 3 || !p) && __getOwnPropDesc(k < 4 ? target : { get [name]() {
    return __privateGet(this, extra);
  }, set [name](x) {
    return __privateSet(this, extra, x);
  } }, name));
  k ? p && k < 4 && __name(extra, (k > 2 ? "set " : k > 1 ? "get " : "") + name) : __name(target, name);
  for (var i = decorators.length - 1; i >= 0; i--) {
    ctx = __decoratorContext(k, name, done = {}, array[3], extraInitializers);
    if (k) {
      ctx.static = s, ctx.private = p, access = ctx.access = { has: p ? (x) => __privateIn(target, x) : (x) => name in x };
      if (k ^ 3) access.get = p ? (x) => (k ^ 1 ? __privateGet : __privateMethod)(x, target, k ^ 4 ? extra : desc.get) : (x) => x[name];
      if (k > 2) access.set = p ? (x, y) => __privateSet(x, target, y, k ^ 4 ? extra : desc.set) : (x, y) => x[name] = y;
    }
    it = (0, decorators[i])(k ? k < 4 ? p ? extra : desc[key] : k > 4 ? void 0 : { get: desc.get, set: desc.set } : target, ctx), done._ = 1;
    if (k ^ 4 || it === void 0) __expectFn(it) && (k > 4 ? initializers.unshift(it) : k ? p ? extra = it : desc[key] = it : target = it);
    else if (typeof it !== "object" || it === null) __typeError("Object expected");
    else __expectFn(fn = it.get) && (desc.get = fn), __expectFn(fn = it.set) && (desc.set = fn), __expectFn(fn = it.init) && initializers.unshift(fn);
  }
  return k || __decoratorMetadata(array, target), desc && __defProp(target, name, desc), p ? k ^ 4 ? extra : desc : target;
};
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateIn = (member, obj) => Object(obj) !== obj ? __typeError('Cannot use the "in" operator on this value') : member.has(obj);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);

// input/aws-sqs/queue.ts
const sqsBase = require("aws-sqs/sqs-base");
const AWSSQSEntity = sqsBase.AWSSQSEntity;
const base = require("monkec/base");
const action = base.action;
const cli = require("cli");
const common = require("aws-sqs/common");
const validateQueueName = common.validateQueueName;
const convertAttributesToApiFormat = common.convertAttributesToApiFormat;
const validateMessageBodySize = common.validateMessageBodySize;
const DEFAULT_STANDARD_QUEUE_ATTRIBUTES = common.DEFAULT_STANDARD_QUEUE_ATTRIBUTES;
const DEFAULT_FIFO_QUEUE_ATTRIBUTES = common.DEFAULT_FIFO_QUEUE_ATTRIBUTES;
var _getQueueStatistics_dec, _purgeQueue_dec, _receiveMessagesAction_dec, _sendMessageAction_dec, _a, _init;
var _SQSQueue = class _SQSQueue extends (_a = AWSSQSEntity, _sendMessageAction_dec = [action("send-message")], _receiveMessagesAction_dec = [action("receive-messages")], _purgeQueue_dec = [action("purge-messages")], _getQueueStatistics_dec = [action("get-statistics")], _a) {
  constructor() {
    super(...arguments);
    __runInitializers(_init, 5, this);
  }
  getQueueName() {
    const baseName = this.definition.queue_name;
    if (this.definition.fifo_queue && !baseName.endsWith(".fifo")) {
      return `${baseName}.fifo`;
    }
    return baseName;
  }
  buildQueueAttributes() {
    const def = this.definition;
    const baseAttributes = def.fifo_queue ? { ...DEFAULT_FIFO_QUEUE_ATTRIBUTES } : { ...DEFAULT_STANDARD_QUEUE_ATTRIBUTES };
    const attributes = {
      ...baseAttributes,
      ...def.delay_seconds !== void 0 && { DelaySeconds: def.delay_seconds },
      ...def.maximum_message_size !== void 0 && { MaximumMessageSize: def.maximum_message_size },
      ...def.message_retention_period !== void 0 && { MessageRetentionPeriod: def.message_retention_period },
      ...def.receive_message_wait_time_seconds !== void 0 && { ReceiveMessageWaitTimeSeconds: def.receive_message_wait_time_seconds },
      ...def.visibility_timeout !== void 0 && { VisibilityTimeout: def.visibility_timeout },
      // Include FifoQueue attribute only for FIFO queues (AWS rejects this attribute for standard queues)
      ...def.fifo_queue === true && { FifoQueue: def.fifo_queue },
      ...def.content_based_deduplication !== void 0 && def.fifo_queue && { ContentBasedDeduplication: def.content_based_deduplication },
      ...def.kms_master_key_id !== void 0 && { KmsMasterKeyId: def.kms_master_key_id },
      ...def.kms_data_key_reuse_period_seconds !== void 0 && { KmsDataKeyReusePeriodSeconds: def.kms_data_key_reuse_period_seconds },
      ...def.redrive_policy !== void 0 && { RedrivePolicy: { deadLetterTargetArn: def.redrive_policy.dead_letter_target_arn, maxReceiveCount: def.redrive_policy.max_receive_count } },
      ...def.redrive_allow_policy !== void 0 && { RedriveAllowPolicy: { redrivePermission: def.redrive_allow_policy.redrive_permission, sourceQueueArns: def.redrive_allow_policy.source_queue_arns ? [...def.redrive_allow_policy.source_queue_arns] : void 0 } },
      ...def.sqs_managed_sse_enabled !== void 0 && { SqsManagedSseEnabled: def.sqs_managed_sse_enabled },
      ...def.policy !== void 0 && { Policy: def.policy }
    };
    return convertAttributesToApiFormat(attributes);
  }
  create() {
    if (!validateQueueName(this.getQueueName())) {
      throw new Error(`Invalid queue name: ${this.getQueueName()}`);
    }
    if (this.queueExists(this.getQueueName())) {
      const queueUrl = this.getQueueUrl(this.getQueueName());
      const attributes2 = this.getQueueAttributes(queueUrl, ["QueueArn"]);
      const queueArn2 = attributes2.Attributes?.QueueArn;
      this.state.existing = true;
      this.state.queue_name = this.getQueueName();
      this.state.queue_url = queueUrl;
      this.state.queue_arn = queueArn2;
      return;
    }
    const apiAttributes = this.buildQueueAttributes();
    const createResponse = this.createQueue(this.getQueueName(), apiAttributes);
    if (!createResponse.QueueUrl) {
      throw new Error(`Failed to create queue: No queue URL returned`);
    }
    const attributes = this.getQueueAttributes(createResponse.QueueUrl, ["QueueArn"]);
    const queueArn = attributes.Attributes?.QueueArn;
    this.state.existing = false;
    this.state.queue_name = this.getQueueName();
    this.state.queue_url = createResponse.QueueUrl;
    this.state.queue_arn = queueArn;
  }
  start() {
    this.checkReadiness();
  }
  stop() {
  }
  update() {
    if (!this.state.queue_url) {
      throw new Error("Queue URL not available for update");
    }
    const apiAttributes = this.buildQueueAttributes();
    this.setQueueAttributes(this.state.queue_url, apiAttributes);
  }
  delete() {
    if (!this.state.queue_url) {
      try {
        this.state.queue_url = this.getQueueUrl(this.getQueueName());
      } catch (error) {
        return;
      }
    }
    try {
      this.deleteQueue(this.state.queue_url);
    } catch (error) {
      throw new Error(`Failed to delete queue: ${error.toString()}`);
    }
    this.state.queue_url = void 0;
    this.state.queue_name = void 0;
    this.state.queue_arn = void 0;
    this.state.existing = false;
  }
  checkReadiness() {
    if (!this.state.queue_url) {
      return false;
    }
    try {
      const attributes = this.getQueueAttributes(this.state.queue_url, ["QueueArn"]);
      const isReady = !!(attributes.Attributes && attributes.Attributes.QueueArn);
      return isReady;
    } catch (error) {
      return false;
    }
  }
  checkLiveness() {
    return this.checkReadiness();
  }
  sendMessageAction(args) {
    const body = args?.body || args?.message;
    if (!body) {
      throw new Error("Message body is required");
    }
    if (!this.state.queue_url) {
      return;
    }
    try {
      if (!validateMessageBodySize(body)) {
        return;
      }
      const response = this.sendMessage(this.state.queue_url, body);
      cli.output(`Message sent: ${response.MessageId}`);
    } catch (error) {
      throw new Error(`Failed to send message: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  receiveMessagesAction(args) {
    const maxMessages = args?.maxMessages ? Math.min(parseInt(args.maxMessages), 10) : 1;
    const waitTimeSeconds = args?.waitTimeSeconds ? parseInt(args.waitTimeSeconds) : 0;
    if (!this.state.queue_url) {
      return;
    }
    try {
      const response = this.receiveMessage(this.state.queue_url, maxMessages, waitTimeSeconds);
      const messages = (response.Messages || []).map((msg) => ({
        MessageId: msg.MessageId || "",
        ReceiptHandle: msg.ReceiptHandle || "",
        MD5OfBody: "",
        // Will be empty since our receiveMessage implementation is simplified
        Body: msg.Body || "",
        Attributes: msg.Attributes || {},
        MD5OfMessageAttributes: void 0,
        MessageAttributes: msg.MessageAttributes || {}
      }));
      cli.output(`Received ${messages.length} messages`);
      cli.output(JSON.stringify(messages, null, 2));
    } catch (error) {
      throw new Error(`Failed to receive messages: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  purgeQueue() {
    if (!this.state.queue_url) {
      return;
    }
    try {
      let totalPurged = 0;
      const maxIterations = 100;
      for (let i = 0; i < maxIterations; i++) {
        const response = this.receiveMessage(this.state.queue_url, 10, 0);
        if (!response.Messages || response.Messages.length === 0) {
          break;
        }
        for (const message of response.Messages) {
          if (message.ReceiptHandle) {
            try {
              this.deleteMessage(this.state.queue_url, message.ReceiptHandle);
              totalPurged++;
            } catch (error) {
              cli.output(`Failed to delete message: ${error instanceof Error ? error.message : "Unknown error"}`);
            }
          }
        }
      }
      cli.output(`Purged ${totalPurged} messages`);
    } catch (error) {
      throw new Error(`Failed to purge messages: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  getQueueStatistics() {
    if (!this.state.queue_url) {
      return { success: false, error: "Queue URL not available" };
    }
    try {
      const attributes = this.getQueueAttributes(this.state.queue_url, [
        "ApproximateNumberOfMessages",
        "ApproximateNumberOfMessagesNotVisible",
        "ApproximateNumberOfMessagesDelayed",
        "CreatedTimestamp",
        "LastModifiedTimestamp"
      ]);
      if (!attributes.Attributes) {
        return { success: false, error: "No attributes returned" };
      }
      const statistics = {
        approximateNumberOfMessages: parseInt(attributes.Attributes.ApproximateNumberOfMessages || "0"),
        approximateNumberOfMessagesNotVisible: parseInt(attributes.Attributes.ApproximateNumberOfMessagesNotVisible || "0"),
        approximateNumberOfMessagesDelayed: parseInt(attributes.Attributes.ApproximateNumberOfMessagesDelayed || "0"),
        createdTimestamp: parseInt(attributes.Attributes.CreatedTimestamp || "0"),
        lastModifiedTimestamp: parseInt(attributes.Attributes.LastModifiedTimestamp || "0"),
        queueArn: this.state.queue_arn
        // Use stored ARN from state
      };
      return statistics;
    } catch (error) {
      throw new Error(`Failed to get queue statistics: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
};
_init = __decoratorStart(_a);
__decorateElement(_init, 1, "sendMessageAction", _sendMessageAction_dec, _SQSQueue);
__decorateElement(_init, 1, "receiveMessagesAction", _receiveMessagesAction_dec, _SQSQueue);
__decorateElement(_init, 1, "purgeQueue", _purgeQueue_dec, _SQSQueue);
__decorateElement(_init, 1, "getQueueStatistics", _getQueueStatistics_dec, _SQSQueue);
__decoratorMetadata(_init, _SQSQueue);
__name(_SQSQueue, "SQSQueue");
var SQSQueue = _SQSQueue;



function main(def, state, ctx) {
  const entity = new SQSQueue(def, state, ctx);
  return entity.main(ctx);
}
